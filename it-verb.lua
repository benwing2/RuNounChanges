local export = {}


--[=[

Authorship: Ben Wing <benwing2>

]=]

--[=[

TERMINOLOGY:

-- "slot" = A particular combination of tense/mood/person/number/etc.
	 Example slot names for verbs are "pres_1s" (present indicative first-person singular), "pres_sub_2sv" (present
	 subjunctive second-person singular voseo form) "impf_sub_ra_3p" (imperfect subjunctive -ra form third-person
	 plural), "imp_1p_comb_lo" (imperative first-person plural combined with clitic [[lo]]).
	 Each slot is filled with zero or more forms.

-- "form" = The conjugated Italian form representing the value of a given slot.

-- "lemma" = The dictionary form of a given Italian term. For Italian, always the infinitive.
]=]

--[=[

RULES FOR CONJUGATION:

1. Present indicative:
-- Individual form overrides always take precedence.
-- Otherwise, if presrow: if given, this specifies all six forms (1s, 2s, 3s, 1p, 2p, 3p).
-- Otherwise:
   1. The 1s form is generated from the explicitly specified pres1s form.
   2. The 3p form is generated from the explicitly specified pres1s form by replacing -o with -ano (for -are verbs)
      or with -ono (for -ere/-ire verbs).
   3. If the spec AUX\VOWEL\PRES1S is given, the 2s and 3s forms are generated from the root-stressed infinitive stem
      by adding -i (2s form) and -e (3s form). This is used e.g. with [[togliere]] (tòlgo, tògli, tòglie, togliàmo,
	  togliéte, tòlgono), where the stem of the 1s and 3p forms is different from the stem of the 2s and 3s forms.
	  Otherwise, the 2s and 3s forms are generated from the explicitly specified pres1s form by replacing -o with -i
	  (2s form) and with -a (3s form, -are verbs) or -e (3s form, -ere/-ire verbs).
   4. The 1p and 2p forms are generated from the infinitive stem by adding -iàmo (1p form) and -àte/-éte/-ìte
      (2p form, -are/-ere/-ire verbs). We don't use the pres1s form because it might have a different stem (e.g. +isc
	  verbs).

2. Present subjunctive:
-- Individual form overrides always take precedence.
-- Otherwise, if subrow: if given, this specifies all four forms (123s, 1p, 2p, 3p).
-- Otherwise:
   1. If sub: is given, this specifies the 123s form; otherwise the 123s form is generated from the pres1s form by
   changing -o to -a (for -ere/-ire verbs), or to -i (for -are verbs). E.g. for [[venire]], vèngo -> vènga;
   for [[potere]], pòsso -> pòssa. sub: needs to be given for e.g. [[essere]] (pres1s sóno, sub1s sìa),
   [[sapere]] (pres1s sò* but sub1s sàppia), [[fare]] (pres1s fàccio:fò*[archaic or dialectal] but sub1s just fàccia),
   [[andare]] (similar to [[fare]]), [[dovere]].
   2. The 3p form is generated from the 123s form by adding -no.
   3. The 1p form is copied from the pres1p form.
   4. The 2p form is generated from the 1p form by replacing -mo with -te.

3. Imperative:
-- If noimp given, the imperative is suppressed.
-- Otherwise, individual form overrides take precedence.
-- Otherwise, if improw: if given, this specifies 2s, 2p.
-- Otherwise:
   1. If imp: given, this specifies the 2s form; otherwise the 2s form is generated by copying the pres2s form
      (for -ere/-ire verbs) or by copying the pres3s form (for -are verbs). We use the present indicative 2s/3s
	  forms to preserve vowel and other alternations in the root-stressed forms (for all -are verbs, for
	  [[venire]] and [[tenere]], for +isc verbs, etc.).
   2. The 2p form is generated by copying the pres2p form.
   3. The 3s, 1p, 3p forms are copied from the corresponding present subjunctive forms.
]=]

--[=[

EXAMPLES OF CONJUGATION:

{{it-conj|mettere<a\é,mìsi,mésso>}}

{{it-conj|arrivare<e:a[transitive]/ì>}}

{{it-conj|trovare<a/ò>}}

{{it-conj|sembrare<e/é>}}

{{it-conj|temprare<e/é:#è>}}

{{it-conj|essere<e\è\-,-,stàto.
  presrow:sóno,sèi,è,siàmo,siète,sóno.
  imperfrow:èro,èri,èra,eravàmo,eravàte,èrano.
  phisrow:fùi,fósti,fù*,fùmmo,fóste,fùrono.
  fut:sarò.
  sub:sìa.
  impsub:fóssi.
  improw:sìi:siàte.
  presp:essènte[rare]
>}}

; Including archaic and literary forms:
{{it-conj|essere<e\è\-,-,stàto:essùto[archaic]:sùto[archaic].
  presrow:sóno,sèi,è,siàmo:sémo[archaic],siète:sète[archaic],sóno:èmmo[archaic].
  imperfrow:èro:èra[literary],èri,èra,eravàmo:èramo[archaic],eravàte,èrano.
  phisrow:fùi,fósti:fùsti[archaic],fù*,fùmmo,fóste:fùste[archaic],fùrono:fùro[archaic]:fóre[archaic]:fòro[archaic].
  futrow:sarò,sarài,sarà:fìa[archaic]:fìe[archaic],sarémo,saréte,sarànno:fìano[archaic]:fìeno[archaic].
  condrow:sarèi:sarìa[archaic]:fòra[archaic],sarésti,sarèbbe:sarìa[archaic]:fòra[archaic],sarémmo,saréste,sarèbbero:sarìano[archaic]:fòro[archaic].
  subrow:sìa,siàmo,siàte,sìano:sìeno[literary].
  impsub:fóssi:fùssi[archaic].
  improw:sìi:siàte.
  ger:essèndo:sèndo[archaic].
  presp:essènte[rare]:ènte[archaic]
>}}

{{it-conj|fare<a/-,féci,fàtto.
  stem:fàce.
  presrow:fàccio:fò*[archaic or dialectal],fài,fà*,facciàmo,fàte,fànno.
  sub:fàccia.
  imp:fà*:fài:fà'
>}}

{{it-conj|potere<a:e[as an auxiliary, with main verbs taking ''essere'']/-,potéi:potètti[less common].
  presrow:pòsso,puòi,può*,possiàmo,potéte,pòssono.
  fut:potrò.
  noimp
>}}

{{it-conj|dire<a/-,dìssi,détto.
  stem:dìce.
  pres2p:dìte.
  imp:dì':*dì*
>}}

{{it-conj|dare<a/dò*:*dò*,dièdi:dètti,dàto.
  presrow:dò*:*dò*,dài,*dà*,diàmo,dàte,dànno.
  sub:dìa.
  fut:darò.
  impsub:déssi.
  imp:dài:da':*dà*
>}}

{{it-conj|dovere<a:e[as an auxiliary, with main verbs taking ''essere'']/-.
  presrow:dèvo:dévo:dèbbo:débbo,dèvi:dévi,dève:déve,dobbiàmo,dovéte,dèvono:dévono:dèbbono:débbono.
  fut:dovrò.
  sub:dèbba:débba:dèva[rare]:déva[rare].
  noimp
>}}

; Including archaic and poetic forms:
{{it-conj|dovere<a:e[as an auxiliary, with main verbs taking ''essere'']/-.
  presrow:
    dèvo:dévo:dèbbo:débbo:dèggio[archaic or poetic]:déggio[archaic or poetic],
    dèvi:dévi:dèi[archaic, poetic or popular Tuscan]:déi[archaic, poetic or popular Tuscan],
    dève:déve:dèe[archaic, poetic or popular Tuscan]:dée[archaic, poetic or popular Tuscan]:dèbbe[archaic]:débbe[archaic],
    dobbiàmo,
    dovéte,
	dèvono:dévono:dèbbono:débbono:dènno[archaic or poetic]:dénno[archaic or poetic].
  fut:dovrò.
  sub:dèbba:débba:dèva[rare]:déva[rare]:dèggia[archaic or poetic]:déggia[archaic or poetic]:dèbbia[obsolete]:débbia[obsolete].
  noimp
>}}

{{it-conj|andare<e/-.
  presrow:vàdo:vò*[less common],vài,và*,andiàmo,andàte,vànno.
  fut:andrò.
  sub:vàda.
  imp:vài:và':và*
>}}

{{it-conj|vedere<a/é,vìdi,vìsto:vedùto[less popular].
  pres1s3p:védo:véggo[literary].
  fut:vedrò
>}}

{{it-conj|venire<e/-,vénni,venùto.
  presrow:vèngo,vièni,viène,veniàmo,venìte,vèngono.
  fut:verrò
>}}

{{it-conj|sapere<a:e[as an auxiliary, with main verbs taking ''essere'']/-,sèppi.
  presrow:sò*,sài,sà*,sappiàmo,sapéte,sànno.
  fut:saprò.
  sub:sàppia.
  improw:sàppi:sappiàte
>}}

{{it-conj|togliere<a\ò\tòlgo,tòlsi,tòlto.fut:+:torrò[literary].presp:+>}}

]=]

--[=[

FIXME:

1. Implement no_pres_stressed for aterir, garantir. (NOTE: Per RAE, garantir used in all forms in Argentina/Uruguay.) [DONE]
2. Support concluyo. [DONE]
3. Fixes for veo -> ve vs. preveo -> prevé. [DONE]
4. Various more irregular verbs, e.g. predecir, redecir, bendecir, maldecir. [DONE]
5. Raising of e -> i, o -> u before -iendo, -ió, etc. occurs only in -ir verbs. [DONE]
6. Raising of e -> i, o -> u happens before subjunctive -amos, -áis in -ir verbs. [DONE]
7. Implement reflexive verbs. [DONE]
8. Implement categories. [DONE]
9. Implement show_forms. [DONE]
10. Reconcile stems.vowel_alt from irregular verbs with vowel_alt from indicators. May require
    moving the irregular-verb handling code in construct_stems() into detect_indicator_spec(). [DONE]
11. Implement make_table. [DONE]
12. Vowel alternation should show u-ue (jugar), i-ie (adquirir), e-í (reír) alternations specially. [DONE]
13. Handle linking of multiword forms as is done in [[Module:es-headword]]. [DONE]
14. Implement comparison against previous module. [DONE]
15. Implement categorization of irregularities for individual tenses.
16. Support nocomb=1. [DONE]
17. (Possibly) display irregular forms in a different color, as with the old module.
18. (Possibly) display a "rule" description indicating the types of alternations.
19. Implement replace_reflexive_indicators().
20. Implement verbs with attached clitics e.g. [[pasarlo]], [[corrérsela]]. [DONE]
21. When footnote + tú/vos notation, add a space before tú/vos.
22. Fix [[erguir]] so ie-i vowel alternation produces ye- at beginning of word, similarly for errar. Also allow
    multiple vowel alternation specs in irregular verbs, for errar. Finally, ie should show as e-ye for errar
    and as e-ye-i for erguir. [DONE]
23. Figure out why red links in combined forms show up as black not red.
24. Consider including alternative superseded forms of verbs like [[ciar]] (e.g. pret_3s = cio, ció with footnote).
25. Allow conjugation of suffixes e.g. -ir, -ecer; need to fix in [[Module:inflection utilities]]. [DONE]
26. Allow specification of stems esp. so that footnotes can be hung off them; use + for the default.
27. Don't remove monosyllabic accents when conjugating suffixes. [DONE]
28. If multiword expression with no <>, add <> after first word, as with [[Module:es-headword]]. [DONE]
29. (Possibly) link the parts of a reflexive or cliticized infinitive, as done in [[Module:es-headword]]. [DONE]
30. Final fixes to allow [[Module:es-headword]] to use this module. [DONE]
--]=]

local lang = require("Module:languages").getByCode("it")
local m_string_utilities = require("Module:string utilities")
local m_links = require("Module:links")
local m_table = require("Module:table")
local iut = require("Module:inflection utilities")
local com = require("Module:it-common")

local force_cat = false -- set to true for debugging
local check_for_red_links = false -- set to false for debugging

local rfind = mw.ustring.find
local rmatch = mw.ustring.match
local rsplit = mw.text.split
local rsub = com.rsub

local function link_term(term, face)
	return m_links.full_link({ lang = lang, term = term }, face)
end

local irreg_forms = { "imperf", "fut", "sub", "impsub", "imp" }
local row_all_6 = {"1s", "2s", "3s", "1p", "2p", "3p"}
local irregrow_forms = {
	["presrow"] = row_all_6,
	["phisrow"] = row_all_6,
	["imperfrow"] = row_all_6,
	["futrow"] = row_all_6,
	["condrow"] = row_all_6,
	["impsubrow"] = row_all_6,
	["subrow"] = {"123s", "1p", "2p", "3p"},
	["improw"] = {"2s", "2p"},
}

local all_persons_numbers = {
	["1s"] = "1|s",
	["2s"] = "2|s",
	["3s"] = "3|s",
	["1p"] = "1|p",
	["2p"] = "2|p",
	["3p"] = "3|p",
	["me"] = "me",
	["te"] = "te",
	["se"] = "se",
	["nos"] = "nos",
	["os"] = "os",
	["lo"] = "lo",
	["la"] = "la",
	["le"] = "le",
	["los"] = "los",
	["las"] = "las",
	["les"] = "les",
}

local person_number_list = { "1s", "2s", "3s", "1p", "2p", "3p", }
-- local persnum_to_index = {}
-- for k, v in pairs(person_number_list) do
-- 	persnum_to_index[v] = k
-- end
local imp_person_number_list = { "2s", "2p", }

person_number_to_reflexive_pronoun = {
	["1s"] = "me",
	["2s"] = "te",
	["3s"] = "se",
	["1p"] = "nos",
	["2p"] = "os",
	["3p"] = "se",
}


local verb_slots_basic = {
	{"infinitive", "inf"},
	{"infinitive_linked", "inf"},
	{"gerund", "ger"},
	{"pp_ms", "m|s|past|part"},
	{"pp_fs", "f|s|past|part"},
	{"pp_mp", "m|p|past|part"},
	{"pp_fp", "f|p|past|part"},
}

local verb_slots_combined = {}

local verb_slot_combined_rows = {}

-- Add entries for a slot with person/number variants.
-- `verb_slots` is the table to add to.
-- `slot_prefix` is the prefix of the slot, typically specifying the tense/aspect.
-- `tag_suffix` is the set of inflection tags to add after the person/number tags,
-- or "-" to use "-" as the inflection tags (which indicates that no accelerator entry
-- should be generated).
local function add_slot_personal(verb_slots, slot_prefix, tag_suffix, persnum_list)
	persnum_list = persnum_list or person_number_list
	for _, persnum in ipairs(persnum_list) do
		local persnum_tag = all_persons_numbers[persnum]
		local slot = slot_prefix .. "_" .. persnum
		if tag_suffix == "-" then
			table.insert(verb_slots, {slot, "-"})
		else
			table.insert(verb_slots, {slot, persnum_tag .. "|" .. tag_suffix})
		end
	end
end

add_slot_personal(verb_slots_basic, "pres", "pres|ind", person_number_list)
add_slot_personal(verb_slots_basic, "impf", "impf|ind", person_number_list)
add_slot_personal(verb_slots_basic, "phis", "phis", person_number_list)
add_slot_personal(verb_slots_basic, "fut", "fut|ind", person_number_list)
add_slot_personal(verb_slots_basic, "cond", "cond", person_number_list)
add_slot_personal(verb_slots_basic, "pres_sub", "pres|sub", person_number_list)
add_slot_personal(verb_slots_basic, "impf_sub", "impf|sub", person_number_list)
add_slot_personal(verb_slots_basic, "imp", "imp", {"2s", "3s", "1p", "2p", "3p"})
add_slot_personal(verb_slots_basic, "neg_imp", "-", {"2s", "3s", "1p", "2p", "3p"})

local function add_combined_slot(basic_slot, slot_prefix, pronouns)
	add_slot_personal(verb_slots_combined, basic_slot .. "_comb", slot_prefix .. "|combined", pronouns)
	table.insert(verb_slot_combined_rows, {basic_slot, pronouns})
end

add_combined_slot("infinitive", "inf", {"me", "te", "se", "nos", "os", "lo", "la", "le", "los", "las", "les"})
add_combined_slot("gerund", "gerund", {"me", "te", "se", "nos", "os", "lo", "la", "le", "los", "las", "les"})
add_combined_slot("imp_2s", "imp|2s", {"me", "te", "nos", "lo", "la", "le", "los", "las", "les"})
add_combined_slot("imp_3s", "imp|3s", {"me", "se", "nos", "lo", "la", "le", "los", "las", "les"})
add_combined_slot("imp_1p", "imp|1p", {"te", "nos", "os", "lo", "la", "le", "los", "las", "les"})
add_combined_slot("imp_2p", "imp|2p", {"me", "nos", "os", "lo", "la", "le", "los", "las", "les"})
add_combined_slot("imp_3p", "imp|3p", {"me", "se", "nos", "lo", "la", "le", "los", "las", "les"})

local all_verb_slots = {}
for _, slot_and_accel in ipairs(verb_slots_basic) do
	table.insert(all_verb_slots, slot_and_accel)
end
for _, slot_and_accel in ipairs(verb_slots_combined) do
	table.insert(all_verb_slots, slot_and_accel)
end

local verb_slots_basic_map = {}
for _, slotaccel in ipairs(verb_slots_basic) do
	local slot, accel = unpack(slotaccel)
	verb_slots_basic_map[slot] = accel
end

local verb_slots_combined_map = {}
for _, slotaccel in ipairs(verb_slots_combined) do
	local slot, accel = unpack(slotaccel)
	verb_slots_combined_map[slot] = accel
end

local reflexive_masc_forms = {
	["su"] = {"mi", "tu", "su", "nuestro", "vuestro", "su"},
	["sus"] = {"mis", "tus", "sus", "nuestros", "vuestros", "sus"},
	["sí"] = {"mí", "ti", "sí", "nosotros", "vosotros", "sí"},
	["consigo"] = {"conmigo", "contigo", "consigo", "con nosotros", "con vosotros", "consigo"},
}

local reflexive_fem_forms = {
	["su"] = {"mi", "tu", "su", "nuestra", "vuestra", "su"},
	["sus"] = {"mis", "tus", "sus", "nuestras", "vuestras", "sus"},
	["sí"] = {"mí", "ti", "sí", "nosotras", "vosotras", "sí"},
	["consigo"] = {"conmigo", "contigo", "consigo", "con nosotras", "con vosotras", "consigo"},
}

local reflexive_forms = {
	["se"] = {"me", "te", "se", "nos", "os", "se"},
	["suyo"] = {"mío", "tuyo", "suyo", "nuestro", "vuestro", "suyo"},
	["suya"] = {"mía", "tuya", "suya", "nuestra", "vuestra", "suya"},
	["suyos"] = {"míos", "tuyos", "suyos", "nuestros", "vuestros", "suyos"},
	["suyas"] = {"mías", "tuyas", "suyas", "nuestras", "vuestras", "suyas"},
}


local function skip_slot(base, slot, allow_overrides)
	if not allow_overrides and (base.basic_overrides[slot] or base.combined_overrides[slot] or
		base.refl and base.basic_reflexive_only_overrides[slot]) then
		-- Skip any slots for which there are overrides.
		return true
	end

	if base.only3s and (slot:find("^pp_f") or slot:find("^pp_mp")) then
		-- diluviar, atardecer, neviscar; impersonal verbs have only masc sing pp
		return true
	end

	if not slot:find("[123]") then
		-- Don't skip non-personal slots.
		return false
	end

	if base.nofinite then
		return true
	end

	if base.only3s and (not slot:find("3s") or slot:find("^imp_") or slot:find("^neg_imp_")) then
		-- diluviar, atardecer, neviscar
		return true
	end

	if base.only3sp and (not slot:find("3[sp]") or slot:find("^imp_") or slot:find("^neg_imp_")) then
		-- atañer, concernir
		return true
	end

	return false
end


local function escape_reflexive_indicators(arg1)
	if not arg1:find("pron>") then
		return arg1
	end
	local segments = iut.parse_balanced_segment_run(arg1, "<", ">")
	-- Loop over every other segment. The even-numbered segments are angle-bracket specs while
	-- the odd-numbered segments are the text between them.
	for i = 2, #segments - 1, 2 do
		if segments[i] == "<mpron>" then
			segments[i] = "⦃⦃mpron⦄⦄"
		elseif segments[i] == "<fpron>" then
			segments[i] = "⦃⦃fpron⦄⦄"
		elseif segments[i] == "<pron>" then
			segments[i] = "⦃⦃pron⦄⦄"
		end
	end
	return table.concat(segments)
end


local function undo_escape_form(form)
	-- assign to var to throw away second value
	local newform = form:gsub("⦃⦃", "<"):gsub("⦄⦄", ">")
	return newform
end


local function remove_reflexive_indicators(form)
	-- assign to var to throw away second value
	local newform = form:gsub("⦃⦃.-⦄⦄", "")
	return newform
end


local function replace_reflexive_indicators(slot, form)
	if not form:find("⦃") then
		return form
	end
	error("Internal error: replace_reflexive_indicators not implemented yet")
end


-- Add the `stem` to the `ending` for the given `slot` and apply any phonetic modifications.
local function combine_stem_ending(base, slot, stem, ending)
	-- Add h after c/g in -are forms to preserve the sound.
	if base.conj == "are" and stem:find("[cg]$") and rfind(ending, "^[eèéiì]") then
		stem = stem .. "h"
	end

	-- Two unstressed i's coming together compress to one.
	if ending:find("^i") then
		stem = stem:gsub("i$", "")
	end

	-- Remove accents from stem if ending is accented.
	if rfind(ending, com.AV) then
		stem = com.remove_accents(stem)
	end

	return stem .. ending
end


local function add(base, slot, stems, endings, from_existing_form, allow_overrides)
	if skip_slot(base, slot, allow_overrides) then
		return
	end
	local function do_combine_stem_ending(stem, ending)
		return combine_stem_ending(base, slot, stem, ending)
	end
	iut.add_forms(base.forms, slot, stems, endings, do_combine_stem_ending, nil, nil,
		not from_existing_form and base.all_footnotes or nil)
end


local function insert_form(base, slot, form)
	if not skip_slot(base, slot) then
		iut.insert_form(base.forms, slot, form)
	end
end


local function insert_forms(base, slot, forms)
	if not skip_slot(base, slot) then
		iut.insert_forms(base.forms, slot, forms)
	end
end


local function create_base_forms(base)
	com.add_default_verb_forms(base)

	local function process_specs(slot, specs, is_finite, special_case)
		specs = specs or {{form = "+"}}
		for _, spec in ipairs(specs) do
			local decorated_form = spec.form
			local prespec, form, syntactic_gemination =
				rmatch(decorated_form, "^([*!#]*)(.-)(%**)$")
			local forms = special_case(base, form)
			forms = iut.convert_to_general_list_form(forms, spec.footnotes)
			for _, formobj in ipairs(forms) do
				local qualifiers = formobj.footnotes
				local form = formobj.form
				-- If the form is -, insert it directly, unlinked; we handle this specially
				-- below, turning it into special labels like "no past participle".
				if form ~= "-" then
					if prespec:find("!!") then
						qualifiers = iut.combine_footnotes({"[elevated style]"}, qualifiers)
						prespec = prespec:gsub("!!", "")
					end
					if prespec:find("!") then
						qualifiers = iut.combine_footnotes({"[careful style]"}, qualifiers)
						prespec = prespec:gsub("!", "")
					end
					if prespec:find("#") then
						qualifiers = iut.combine_footnotes({"[traditional]"}, qualifiers)
						prespec = prespec:gsub("#", "")
					end
					local preserve_monosyllabic_accent
					if prespec:find("%*") then
						preserve_monosyllabic_accent = true
						prespec = prespec:gsub("%*", "")
					end
					local unaccented_form
					if rfind(form, "^.*" .. com.V .. ".*" .. com.AV .. "$") then
						-- final accented vowel with preceding vowel; keep accent
						unaccented_form = form
					elseif rfind(form, com.AV .. "$") and preserve_monosyllabic_accent then
						unaccented_form = form
						qualifiers = iut.combine_footnotes(qualifiers, {"[with written accent]"})
					else
						unaccented_form = rsub(form, com.AV, function(v) return usub(unfd(v), 1, 1) end)
					end
					if syntactic_gemination == "*" then
						qualifiers = iut.combine_footnotes(qualifiers, {"[with following syntactic gemination]"})
					elseif syntactic_gemination == "**" then
						qualifiers = iut.combine_footnotes(qualifiers, {"[with optional following syntactic gemination]"})
					elseif syntactic_gemination ~= "" then
						error("Decorated form '" .. decorated_form .. "' has too many asterisks after it, use '*' for syntactic gemination and '**' for optional syntactic gemination")
					end
					form = "[[" .. unaccented_form .. "|" .. form .. "]]"
					if is_finite then
						if unaccented_form == "ho" then
							form = base.verb.finite_pref_ho .. form
						else
							form = base.verb.finite_pref .. form
						end
					end
				end
				iut.insert_form(base.stems, slot, {form = form, footnotes = qualifiers})
			end
		end
	end

	process_specs("pres_form", base.pres, "finite", com.pres_special_case)
	process_specs("phis_form", base.phis, "finite", com.phis_special_case)
	process_specs("pp_form", base.pp, false, com.pp_special_case)

	local function irreg_special_case(base, form, def)
		return form
	end

	for _, irreg_form in ipairs(com.irreg_forms) do
		if base.irreg_forms[irreg_form] then
			process_specs(irreg_form .. "_form", base.irreg_forms[irreg_form], irreg_form ~= "imp",
				irreg_special_case)
		end
	end

	iut.insert_form(base.forms, "lemma", {form = base.lemma})
	-- Add linked version of lemma for use in head=.
	if base.root_stressed_inf then
		com.do_root_stressed_inf(iut, base, base.root_stressed_inf)
	else
		com.do_ending_stressed_inf(iut, base)
	end
end


local function add_irregrow(base, slot_pref, irregrow_key)
	if base.irregrow_forms[irregrow_key] then
		for _, irregrow_persnum in ipairs(irregrow_forms[irregrow_key]) do
			add(base, slot_pref .. "_" .. irregrow_persnum, base.irregrow_forms[irregrow_key][irregrow_persnum], "")
		end
		return true
	else
		return false
	end
end


-- Generate the present indicative. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
local function add_present_indic(base)
	local prespref = "pres_"

	if add_irregrow(base, prespref, "presrow") then
		return
	end

	local function addit(pers, stems, endings, from_existing_form)
		add(base, prespref .. pers, stems, endings, from_existing_form)
	end

	addit("1s", base.stems.pres_form, "")
	local pres_1s_stem = iut.map_forms(base.stems.pres_form, function(form)
		if not form:find("o$") then
			error("presrow: must be given in order to generate the present indicative because explicit first-person "
				.. "singular present indicative '" .. form .. "' does not end in -o")
		end
		return rsub(form, "o$", "")
	end)
	addit("3p", pres_1s_stem, base.conj == "are" and "ano" or "ono")
	local pres_23s_stem = base.stems.root_stressed_stem or pres_1s_stem
	addit("2s", pres_23s_stem, "i")
	addit("3s", pres_23s_stem, base.conj == "are" and "a" or "e")
	addit("1p", base.verb.stem, "iàmo")
	addit("2p", base.verb.stem, base.conj_vowel .. "te")
end


-- Generate the present subjunctive. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
local function add_present_subj(base)
	local subpref = "pres_sub_"

	if add_irregrow(base, subpref, "subrow") then
		return
	end

	local function addit(pers, stems, endings, from_existing_form)
		add(base, subpref .. pers, stems, endings, from_existing_form)
	end
	local function insit(pers, forms)
		insert_forms(base, subpref .. pers, forms)
	end

	-- Generate the 123s and 3p forms. Don't copy the 123s form to the 3p form with -no added in case there's an
	-- override of the 123s form (in which case the 123s form won't be added).
	if base.irregrow_forms.sub then
		addit("123s", base.irregrow_forms.sub, "")
		addit("3p", base.irregrow_forms.sub, "no")
	else
		local pres_1s_stem = iut.map_forms(base.forms.pres_1s, function(form)
			if not form:find("o$") then
				error("sub: or subrow: must be given in order to generate the singular present subjunctive "
					.. "because first-person singular present indicative '" .. form .. "' does not end in -o")
			end
			return rsub(form, "o$", "")
		end)
		addit("123s", s123_stem, base.conj == "are" and "i" or "a", "existing form")
		addit("3p", s123_stem, base.conj == "are" and "ino" or "ano", "existing form")
	end

	-- Copy present indicative 1p to present subjunctive.
	insit("1p", iut.map_forms(base.forms.pres_1p, iut.identity end))
	-- Generate present subjunctive 2p from present indicative 1p by replacing -mo with -te.
	insit("2p", iut.map_forms(base.forms.pres_1p, function(form)
		if not form:find("mo$") then
			error("subrow: must be given in order to generate the second-person plural present subjunctive "
				.. "because first-person plural present indicative '" .. form .. "' does not end in -mo")
		end
		return rsub(form, "mo$", "te")
	end)
end


-- Generate the imperative. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
local function add_imper(base)
	local imppref = "imp_"

	if base.noimp then
		return
	end

	if add_irregrow(base, imppref, "improw") then
		return
	end

	local function addit(pers, stems, endings, from_existing_form)
		add(base, imppref .. pers, stems, endings, from_existing_form)
	end
	local function insit(pers, forms)
		insert_forms(base, imppref .. pers, forms)
	end

	if base.irregrow_forms.imp then
		addit("2s", base.irregrow_forms.imp, "")
	elseif base.conj == "are" then
		-- Copy present indicative 3s to imperative 2s.
		insit("2s", iut.map_forms(base.forms.pres_3s, iut.identity end))
	else
		-- Copy present indicative 2s to imperative 2s.
		insit("2s", iut.map_forms(base.forms.pres_2s, iut.identity end))
	end
	-- Copy present indicative 2p to imperative 2p.
	insit("2p", iut.map_forms(base.forms.pres_2p, iut.identity end))
	-- Copy present subjunctive 3s, 1p, 2p to imperative.
	insit("3s", iut.map_forms(base.forms.sub_3s, iut.identity end))
	insit("1p", iut.map_forms(base.forms.sub_1p, iut.identity end))
	insit("2p", iut.map_forms(base.forms.sub_2p, iut.identity end))
end


local function add_tense(base, prefix, stems, s1, s2, s3, p1, p2, p3)
	local function addit(pers, endings)
		add(base, prefix .. pers, stems, endings)
	end
	addit("1s", s1)
	addit("2s", s2)
	addit("3s", s3)
	addit("1p", p1)
	addit("2p", p2)
	addit("3p", p3)
end


local function add_imperfect(base)
	local imperfpref = "impf_"

	if add_irregrow(base, imperfpref, "imperfrow") then
		return
	end

	local imperf_stem
	if base.irregrow_forms.imperf then
		imperf_stem = iut.map_forms(base.irregrow_forms.imperf, function(form)
			if not form:find("o$") then
				error("imperfrow: must be given in order to generate the imperfect because explicit first-person "
					.. "singular imperfect '" .. form .. "' does not end in -o")
			end
			return rsub(form, "o$", "")
		end)
	else
		imperf_stem = base.verb.stem .. base.conj_vowel .. "v"
		add_tense(base, imperfpref, imperf_stem, "o", "i", "a", "àmo", "àte", "ano")
	end
end


local function add_past_historic(base)
	local phispref = "phis_"

	if add_irregrow(base, phispref, "phisrow") then
		return
	end

	for _, form in ipairs(base.stems.phis_form) do
		local function add_phis(pref, s1, s2, s3, p1, p2, p3)
			local newform = {form = pref, footnotes = form.footnotes}
			add_tense(base, phispref, newform, s1, s3, s3, p1, p2, p3)
		end
		while true do
			local pref = rmatch(form.form, "^(.*)ài$")
			if pref then
				add_phis(pref, "ài", "àsti", "ò", "àmmo", "àste", "àrono")
				break
			end
			pref = rmatch(form.form, "^(.*)éi$")
			if pref then
				add_phis(pref, "éi", "ésti", "é", "émmo", "éste", "érono")
				break
			end
			pref = rmatch(form.form, "^(.*)ètti$")
			if pref then
				add_phis(pref, "ètti", "ésti", "ètte", "émmo", "éste", "èttero")
				break
			end
			pref = rmatch(form.form, "^(.*)ìi$")
			if pref then
				add_phis(pref, "ìi", "ìsti", "ì", "ìmmo", "ìste", "ìrono")
				break
			end
			pref = rmatch(form.form, "^(.*)i$")
			if pref then
				add_phis(pref, "i", {}, "e", {}, {}, "ero")
				add_phis(base.verb.stem, {}, base.conj_vowel .. "sti", {}, base.conj_vowel .. "mmo",
					base.conj_vowel .. "ste", {})
				break
			end
			error("phisrow: must be given in order to generate the past historic because explicit first-person "
				.. "singular past historic '" .. form.form .. "' does not end in -i")
		end
	end
end


local function add_imperfect_sub(base)
	local impsubpref = "impf_sub_"

	if add_irregrow(base, impsubpref, "impsubrow") then
		return
	end

	local impsub_stem
	if base.irregrow_forms.impsub then
		impsub_stem = iut.map_forms(base.irregrow_forms.impsub, function(form)
			if not form:find("ssi$") then
				error("impsubrow: must be given in order to generate the imperfect subjunctive because explicit "
					.. "first/second-person singular imperfect subjunctive '" .. form .. "' does not end in -ssi")
			end
			return rsub(form, "ssi$", "")
		end)
	else
		impsub_stem = base.verb.stem .. base.conj_vowel
	end

	local function addit(pers, endings)
		add(base, impsubpref .. pers, impsub_stem, endings)
	end

	addit("12s", "ssi")
	addit("3s", "sse")
	addit("1p", "ssimo")
	addit("2p", "ste")
	addit("3p", "ssero")
end


local function generate_future_cond_stem(base)
	if base.conj == "are" then
		if base.verb.stem:find("[cg]$") then
			fut_stem = base.verb.stem .. "he"
		elseif base.verb.stem:find("[cg]i$") then
			fut_stem = rsub(base.verb.stem, "i$", "e")
		else
			fut_stem = base.verb.stem .. "e"
		end
	elseif base.conj == "ere" then
		fut_stem = base.verb.stem .. "e"
	elseif base.conj == "ire" then
		fut_stem = base.verb.stem .. "i"
	end
	return fut_stem .. "r"
end


local function generate_future_stem_from_irregrow_fut(base)
	return iut.map_forms(base.irregrow_forms.fut, function(form)
		if not form:find("ò$") then
			error("futrow: must be given in order to generate the future because explicit first-person "
				.. "singular future '" .. form .. "' does not end in -ò")
		end
		return rsub(form, "ò$", "")
	end)
end


local function add_future(base)
	local futpref = "fut_"

	if add_irregrow(base, futpref, "futrow") then
		return
	end

	local fut_stem
	if base.irregrow_forms.fut then
		fut_stem = generate_future_stem_from_irregrow_fut(base)
	else
		fut_stem = generate_future_cond_stem(base)
	end
	add_tense(base, futpref, fut_stem, "ò", "ài", "à", "émo", "éte", "ànno")
end


local function add_cond(base)
	local imperfpref = "cond_"

	if add_irregrow(base, condpref, "condrow") then
		return
	end

	local cond_stem
	if base.irregrow_forms.cond then
		cond_stem = iut.map_forms(base.irregrow_forms.cond, function(form)
			if not form:find("éi$") then
				error("condrow: must be given in order to generate the conditional because explicit first-person "
					.. "singular conditional '" .. form .. "' does not end in -éi")
			end
			return rsub(form, "éi$", "")
		end)
	elseif base.irregrow_forms.fut then
		cond_stem = generate_future_stem_from_irregrow_fut(base)
	else
		cond_stem = generate_future_cond_stem(base)
	end
	add_tense(base, condpref, cond_stem, "éi", "ésti", "èbbe", "émmo", "éste", "èbbero")
end


local function add_participles(base)
	-- Do the participles.
	local function addit(slot, stems, ending)
		add3(base, slot, base.prefix, stems, ending)
	end
	insert_form(base, "infinitive", {form = base.verb})
	addit("gerund", stems.pres_unstressed, base.conj == "are" and "àndo" or "èndo")
	addit("pp_ms", stems.pp, "o")
	addit("pp_fs", stems.pp, "a")
	addit("pp_mp", stems.pp, "os")
	addit("pp_fp", stems.pp, "as")
end


-- Remove monosyllabic accents (e.g. the 3sg preterite of fiar is fio not #fió). Note that there are a
-- few monosyllabic verb forms that intentionally have an accent, to distinguish them from other words
-- with the same pronunciation. These are as follows:
-- (1) [[sé]] 1sg present indicative of [[saber]];
-- (2) [[sé]] 2sg imperative of [[ser]];
-- (3) [[dé]] 1sg and 3sg present subjunctive of [[dar]].
-- For these, a * is added, which indicates that the accent needs to remain. If we see such a *, we remove
-- it but otherwise leave the form alone.
local function remove_monosyllabic_accents(base)
	for _, slotaccel in ipairs(verb_slots_basic) do
		local slot, accel = unpack(slotaccel)
		if base.forms[slot] then
			for _, form in ipairs(base.forms[slot]) do
				if form.form:find("%*") then -- * means leave alone any accented vowel
					form.form = form.form:gsub("%*", "")
				elseif not rfind(form.form, "^%-") and rfind(form.form, AV) and not rfind(form.form, V .. C .. V) then
					-- Has an accented vowel and no VCV sequence and not a suffix; may be monosyllabic, in which
					-- case we need to remove the accent. Check # of syllables and remove accent if only 1. Note
					-- that the checks for accented vowel and VCV sequence are not strictly needed, but are
					-- optimizations to avoid running the whole syllabification algorithm on every verb form.
					local syllables = com.syllabify(form.form)
					if #syllables == 1 then
						form.form = com.remove_accent_from_syllable(syllables[1])
					end
				end
			end
		end
	end
end


-- Add the clitic pronouns in `pronouns` to the forms in `base_slot`. If `do_combined_slots` is given,
-- store the results into the appropriate combined slots, e.g. `imp_2s_comb_lo` for second singular imperative + lo.
-- Otherwise, directly modify `base_slot`. The latter case is used for handling reflexive verbs, and in that case
-- `pronouns` should contain only a single pronoun.
local function add_forms_with_clitic(base, base_slot, pronouns, do_combined_slots)
	if not base.forms[base_slot] then
		-- This can happen, e.g. in only3s/only3sp verbs.
		return
	end
	for _, form in ipairs(base.forms[base_slot]) do
		-- Figure out that correct accenting of the verb when a clitic pronoun is attached to it. We may need to
		-- add or remove an accent mark:
		-- (1) No accent mark currently, none needed: infinitive sentar because of sentarlo; imperative singular
		--     ten because of tenlo;
		-- (2) Accent mark currently, still needed: infinitive oír because of oírlo;
		-- (3) No accent mark currently, accent needed: imperative singular siente -> siénte because of siéntelo;
		-- (4) Accent mark currently, not needed: imperative singular está -> estálo, sé -> selo.
		local syllables = com.syllabify(form.form)
		local sylno = com.stressed_syllable(syllables)
		table.insert(syllables, "lo")
		local needs_accent = com.accent_needed(syllables, sylno)
		if needs_accent then
			syllables[sylno] = com.add_accent_to_syllable(syllables[sylno])
		else
			syllables[sylno] = com.remove_accent_from_syllable(syllables[sylno])
		end
		table.remove(syllables) -- remove added clitic pronoun
		local reaccented_verb = table.concat(syllables)
		for _, pronoun in ipairs(pronouns) do
			local cliticized_verb
			-- Some further special cases.
			if base_slot == "imp_1p" and (pronoun == "nos" or pronoun == "os") then
				-- Final -s disappears: sintamos + nos -> sintámonos, sintamos + os -> sintámoos
				cliticized_verb = reaccented_verb:gsub("s$", "") .. pronoun
			elseif base_slot == "imp_2p" and pronoun == "os" then
				-- Final -d disappears, which may cause an accent to be required:
				-- haced + os -> haceos, sentid + os -> sentíos
				if reaccented_verb:find("id$") then
					cliticized_verb = reaccented_verb:gsub("id$", "íos")
				else
					cliticized_verb = reaccented_verb:gsub("d$", "os")
				end
			else
				cliticized_verb = reaccented_verb .. pronoun
			end
			if do_combined_slots then
				insert_form(base, base_slot .. "_comb_" .. pronoun,
					{form = cliticized_verb, footnotes = form.footnotes})
			else
				form.form = cliticized_verb
			end
		end
	end
end


-- Generate the combinations of verb form (infinitive, gerund or various imperatives) + clitic pronoun.
local function add_combined_forms(base)
	for _, base_slot_and_pronouns in ipairs(verb_slot_combined_rows) do
		local base_slot, pronouns = unpack(base_slot_and_pronouns)
		-- Skip non-infinitive/gerund combinations for reflexive verbs. We will copy the appropriate imperative
		-- combinations later.
		if not base.refl or base_slot == "infinitive" or base_slot == "gerund" then
			add_forms_with_clitic(base, base_slot, pronouns, "do combined slots")
		end
	end
end


local function process_slot_overrides(base, do_basic, reflexive_only)
	local overrides = reflexive_only and base.basic_reflexive_only_overrides or
		do_basic and base.basic_overrides or base.combined_overrides
	for slot, forms in pairs(overrides) do
		add(base, slot, base.prefix, forms, false, "allow overrides")
	end
end


-- Add a reflexive pronoun or fixed clitic, e.g. [[lo]], as appropriate to the base form that were generated.
-- `do_joined` means to do only the forms where the pronoun is joined to the end of the form; otherwise, do only the
-- forms where it is not joined and precedes the form.
local function add_reflexive_or_fixed_clitic_to_forms(base, do_reflexive, do_joined)
	for _, slotaccel in ipairs(verb_slots_basic) do
		local slot, accel = unpack(slotaccel)
		local clitic
		if not do_reflexive then
			clitic = base.clitic
		elseif slot:find("[123]") then
			local persnum = slot:match("^.*_(.-)$")
			clitic = person_number_to_reflexive_pronoun[persnum]
		else
			clitic = "se"
		end
		if base.forms[slot] then
			if slot == "infinitive" or slot == "gerund" or slot:find("^imp_") then
				if do_joined then
					add_forms_with_clitic(base, slot, {clitic})
				end
			elseif do_reflexive and slot:find("^pp_") or slot == "infinitive_linked" then
				-- do nothing with reflexive past participles or with infinitive linked (handled at the end)
			elseif slot:find("^neg_imp_") then
				error("Internal error: Should not have forms set for negative imperative at this stage")
			elseif not do_joined then
				-- Add clitic as separate word before all other forms. Check whether form already has brackets
				-- (as will be the case if the form has a fixed clitic).
				for _, form in ipairs(base.forms[slot]) do
					if base.args.noautolinkverb then
						form.form = clitic .. " " .. form.form
					else
						local clitic_pref = "[[" .. clitic .. "]] "
						if form.form:find("%[%[") then
							form.form = clitic_pref .. form.form
						else
							form.form = clitic_pref .. "[[" .. form.form .. "]]"
						end
					end
				end
			end
		end
	end
end


local function copy_subjunctives_to_imperatives(base)
	-- Copy subjunctives to imperatives, unless there's an override for the given slot (as with the imp_1p of [[ir]]).
	for _, persnum in ipairs({"3s", "1p", "3p"}) do
		local from = "pres_sub_" .. persnum
		local to = "imp_" .. persnum
		insert_forms(base, to, iut.map_forms(base.forms[from], function(form) return form end))
	end
end


local function handle_infinitive_linked(base)
	-- Compute linked versions of potential lemma slots, for use in {{es-verb}}.
	-- We substitute the original lemma (before removing links) for forms that
	-- are the same as the lemma, if the original lemma has links.
	for _, slot in ipairs({"infinitive"}) do
		insert_forms(base, slot .. "_linked", iut.map_forms(base.forms[slot], function(form)
			if form == base.lemma and rfind(base.linked_lemma, "%[%[") then
				return base.linked_lemma
			else
				return form
			end
		end))
	end
end


local function generate_negative_imperatives(base)
	-- Copy subjunctives to negative imperatives, preceded by "no".
	for _, persnum in ipairs({"2s", "3s", "1p", "2p", "3p"}) do
		local from = "pres_sub_" .. persnum
		local to = "neg_imp_" .. persnum
		insert_forms(base, to, iut.map_forms(base.forms[from], function(form)
			if base.args.noautolinkverb then
				return "no " .. form
			elseif form:find("%[%[") then
				-- already linked, e.g. when reflexive
				return "[[no]] " .. form
			else
				return "[[no]] [[" .. form .. "]]"
			end
		end))
	end
end


local function copy_imperatives_to_reflexive_combined_forms(base)
	local copy_table = {
		{"imp_2s", "imp_2s_comb_te"},
		{"imp_3s", "imp_3s_comb_se"},
		{"imp_1p", "imp_1p_comb_nos"},
		{"imp_2p", "imp_2p_comb_os"},
		{"imp_3p", "imp_3p_comb_se"},
	}

	-- Copy imperatives (with the clitic reflexive pronoun already added) to the appropriate "combined" reflexive
	-- forms.
	for _, entry in ipairs(copy_table) do
		local from, to = unpack(entry)
		-- Need to call map_forms() to clone the form objects because insert_forms() doesn't clone them, and may
		-- side-effect them when inserting footnotes.
		insert_forms(base, to, iut.map_forms(base.forms[from], function(form) return form end))
	end
end


local function add_missing_links_to_forms(base)
	-- Any forms without links should get them now. Redundant ones will be stripped later.
	for slot, forms in pairs(base.forms) do
		for _, form in ipairs(forms) do
			if not form.form:find("%[%[") then
				form.form = "[[" .. form.form .. "]]"
			end
		end
	end
end


local function conjugate_verb(base)
	add_present_indic(base)
	add_present_subj(base)
	add_imper(base)
	add_non_present(base)
	-- This should happen before add_combined_forms() so overrides of basic forms end up part of the combined forms.
	process_slot_overrides(base, "do basic") -- do basic slot overrides
	-- This should happen after process_slot_overrides() in case a derived slot is based on an override (as with the
	-- imp_3s of [[dar]], [[estar]]).
	copy_subjunctives_to_imperatives(base)
	-- This should happen after process_slot_overrides() because overrides may have accents in them that need to be
	-- removed. (This happens e.g. for most present indicative forms of [[ver]], which have accents in them for the
	-- prefixed derived verbs, but the accents shouldn't be present in the base verb.)
	remove_monosyllabic_accents(base)
	if not base.nocomb then
		-- This should happen before add_reflexive_pronouns() because the combined forms of reflexive verbs don't have
		-- the reflexive attached.
		add_combined_forms(base)
	end
	-- We need to add joined reflexives, then joined and non-joined clitics, then non-joined reflexives, so we get
	-- [[házmelo]] but [[no]] [[me]] [[lo]] [[haga]].
	if base.refl then
		-- This should happen after remove_monosyllabic_accents() so the * marking the preservation of monosyllabic
		-- accents doesn't end up in the middle of a word.
		add_reflexive_or_fixed_clitic_to_forms(base, "do reflexive", "do joined")
		process_slot_overrides(base, "do basic", "do reflexive") -- do reflexive-only basic slot overrides
	end
	if base.clitic then
		-- This should happen after reflexives are added.
		add_reflexive_or_fixed_clitic_to_forms(base, false, "do joined")
		add_reflexive_or_fixed_clitic_to_forms(base, false, false)
	end
	if base.refl then
		add_reflexive_or_fixed_clitic_to_forms(base, "do reflexive", false)
	end
	-- This should happen after add_reflexive_or_fixed_clitic_to_forms() so negative imperatives get the reflexive pronoun
	-- and clitic in them.
	generate_negative_imperatives(base)
	if not base.nocomb then
		if base.refl then
			-- This should happen after process_slot_overrides() for reflexive-only basic slots so the overridden
			-- forms (e.g. [[idos]]/[[iros]] for [[ir]]) get appropriately copied.
			copy_imperatives_to_reflexive_combined_forms(base)
		end
		process_slot_overrides(base, false) -- do combined slot overrides
	end
	-- This should happen before add_missing_links_to_forms() so that the comparison `form == base.lemma`
	-- in handle_infinitive_linked() works correctly and compares unlinked forms to unlinked forms.
	handle_infinitive_linked(base)
	if not base.args.noautolinkverb then
		add_missing_links_to_forms(base)
	end
end


local function parse_indicator_spec(angle_bracket_spec, lemma)
	local base = {forms = {}, irreg_forms = {}, irregrow_forms = {}}
	local function parse_err(msg)
		error(msg .. ": " .. angle_bracket_spec)
	end

	local function parse_qualifiers(separated_group)
		local qualifiers
		for j = 2, #separated_group - 1, 2 do
			if separated_group[j + 1] ~= "" then
				parse_err("Extraneous text after bracketed qualifiers: '" .. table.concat(separated_group) .. "'")
			end
			if not qualifiers then
				qualifiers = {}
			end
			table.insert(qualifiers, separated_group[j])
		end
		return qualifiers
	end

	local function fetch_specs(comma_separated_group, allow_blank)
		local colon_separated_groups = iut.split_alternating_runs(comma_separated_group, ":")
		if allow_blank and #colon_separated_groups == 1 and #colon_separated_groups[1] == 1 and
			colon_separated_groups[1][1] == "" then
			return nil
		end
		local specs = {}
		for _, colon_separated_group in ipairs(colon_separated_groups) do
			local form = colon_separated_group[1]
			if form == "" then
				parse_err("Blank form not allowed here, but saw '" ..
					table.concat(comma_separated_group) .. "'")
			end
			local new_spec = {form = form, footnotes = parse_qualifiers(colon_separated_group)}
			for _, existing_spec in ipairs(specs) do
				if m_table.deepEquals(existing_spec, new_spec) then
					parse_err("Duplicate spec '" .. table.concat(colon_separated_group) .. "'")
				end
			end
			table.insert(specs, new_spec)
		end
		return specs
	end

	if lemma == "" then
		lemma = data.pagename
	end
	base.lemma = m_links.remove_links(lemma)
	base.verb = com.analyze_verb(lemma)

	local inside = angle_bracket_spec:match("^<(.*)>$")
	assert(inside)

	local segments = iut.parse_balanced_segment_run(inside, "[", "]")
	local dot_separated_groups = iut.split_alternating_runs(segments, "%s*%.%s*")
	for i, dot_separated_group in ipairs(dot_separated_groups) do
		local first_element = dot_separated_group[1]
		if first_element == "only3s" or first_element == "only3sp" or first_element == "rre" then
			if #dot_separated_group > 1 then
				parse_err("No footnotes allowed with '" .. first_element .. "' spec")
			end
			base[first_element] = true
		elseif first_element:find("^[a-z]row:") then
			local saw_irreg = false
			for irregrow_form, irregrow_persnums in pairs(irregrow_forms) do
				local first_element_minus_prefix = rmatch(first_element, "^" .. irregrow_form .. ":(.*)$")
				if first_element_minus_prefix then
					dot_separated_group[1] = first_element_minus_prefix
					local comma_separated_groups = iut.split_alternating_runs(dot_separated_group, "%s*,%s*")
					if #comma_separated_groups != #irregrow_persnums then
						parse_err("For " .. irregrow_form .. ", expected " .. #irregrow_persnums .. " forms but saw "
							.. #comma_separated_groups .. " in '" .. table.concat(dot_separated_groups) .. "'")
					end
					base.irreg_forms[irregrow_form] = {}
					for i, irregrow_persnum in ipairs(irregrow_persnums) do
						base.irreg_forms[irregrow_form][irregrow_persnum] = fetch_specs(comma_separated_group[i])
					end
					saw_irreg = true
					break
				end
			end
			if not saw_irreg then
				local irregrow_keys = {}
				for irregrow_form, _ in pairs(irregrow_forms) do
					table.insert(irregrow_keys, irregrow_form .. ":")
				end
				table.sort(irregrow_keys)
				parse_err("Irregular row spec should begin with one of " .. m_table.serialCommaJoin(irregrow_keys)
					.. ", but saw '" .. table.concat(dot_separated_groups) .. "'")
			end
		else
			local saw_irreg = false
			for _, irreg_form in ipairs(com.irreg_forms) do
				local first_element_minus_prefix = rmatch(first_element, "^" .. irreg_form .. ":(.*)$")
				if first_element_minus_prefix then
					dot_separated_group[1] = first_element_minus_prefix
					base.irreg_forms[irreg_form] = fetch_specs(dot_separated_group)
					saw_irreg = true
					break
				end
			end
			if not saw_irreg then
				local comma_separated_groups = iut.split_alternating_runs(dot_separated_group, "%s*[,\\/]%s*", "preserve splitchar")
				local presind = 1
				local first_separator = #comma_separated_groups > 1 and
					com.strip_spaces(comma_separated_groups[2][1])
				if base.verb.is_reflexive then
					if #comma_separated_groups > 1 and first_separator ~= "," then
						presind = 3
						-- Fetch root-stressed infinitive, if given.
						local specs = fetch_specs(comma_separated_groups[1], "allow blank")
						if first_separator == "\\" then
							-- For verbs like [[scegliersi]] and [[proporsi]], allow either 'é\scélgo' or '\é\scélgo'
							-- and similarly either 'ó+\propóngo' or '\ó+\propóngo'.
							if specs == nil then
								if #comma_separated_groups > 3 and com.strip_spaces(comma_separated_groups[4][1]) == "\\" then
									base.root_stressed_inf = fetch_specs(comma_separated_groups[3])
									presind = 5
								else
									base.root_stressed_inf = {{form = "+"}}
								end
							else
								base.root_stressed_inf = specs
							end
						elseif specs ~= nil then
							parse_err("With reflexive verb, can't specify anything before initial slash, but saw '"
								.. table.concat(comma_separated_groups[1]))
						end
					end
					base.aux = {{form = "essere"}}
				else -- non-reflexive
					if #comma_separated_groups == 1 or first_separator == "," then
						parse_err("With non-reflexive verb, use a spec like AUX/PRES, AUX\\PRES, AUX/PRES,PAST,PP or similar")
					end
					presind = 3
					-- Fetch auxiliary or auxiliaries.
					local colon_separated_groups = iut.split_alternating_runs(comma_separated_groups[1], ":")
					for _, colon_separated_group in ipairs(colon_separated_groups) do
						local aux = colon_separated_group[1]
						if aux == "a" then
							aux = "avere"
						elseif aux == "e" then
							aux = "essere"
						elseif aux == "-" then
							if #colon_separated_group > 1 then
								parse_err("No footnotes allowed with '-' spec for auxiliary")
							end
							aux = nil
						else
							parse_err("Unrecognized auxiliary '" .. aux ..
								"', should be 'a' (for [[avere]]), 'e' (for [[essere]]), or '-' if no past participle")
						end
						if aux then
							if base.aux then
								for _, existing_aux in ipairs(base.aux) do
									if existing_aux.form == aux then
										parse_err("Auxiliary '" .. aux .. "' specified twice")
									end
								end
							else
								base.aux = {}
							end
							table.insert(base.aux, {form = aux, footnotes = parse_qualifiers(colon_separated_group)})
						end
					end

					-- Fetch root-stressed infinitive, if given.
					if first_separator == "\\" then
						if #comma_separated_groups > 3 and com.strip_spaces(comma_separated_groups[4][1]) == "\\" then
							base.root_stressed_inf = fetch_specs(comma_separated_groups[3])
							presind = 5
						else
							base.root_stressed_inf = {{form = "+"}}
						end
					end
				end

				-- Parse present
				base.pres = fetch_specs(comma_separated_groups[presind])

				-- Parse past historic
				if #comma_separated_groups > presind then
					if com.strip_spaces(comma_separated_groups[presind + 1][1]) ~= "," then
						parse_err("Use a comma not slash to separate present from past historic")
					end
					base.past = fetch_specs(comma_separated_groups[presind + 2])
				end

				-- Parse past participle
				if #comma_separated_groups > presind + 2 then
					if com.strip_spaces(comma_separated_groups[presind + 3][1]) ~= "," then
						parse_err("Use a comma not slash to separate past historic from past participle")
					end
					base.pp = fetch_specs(comma_separated_groups[presind + 4])
				end

				if #comma_separated_groups > presind + 4 then
					parse_err("Extraneous text after past participle")
				end
			end
		end
	end
	return base
end


-- Normalize all lemmas, substituting the pagename for blank lemmas and adding links to multiword lemmas.
local function normalize_all_lemmas(alternant_multiword_spec)

	-- (1) Add links to all before and after text.
	if not alternant_multiword_spec.args.noautolinktext then
		alternant_multiword_spec.post_text = com.add_links(alternant_multiword_spec.post_text)
		for _, alternant_or_word_spec in ipairs(alternant_multiword_spec.alternant_or_word_specs) do
			alternant_or_word_spec.before_text = com.add_links(alternant_or_word_spec.before_text)
			if alternant_or_word_spec.alternants then
				for _, multiword_spec in ipairs(alternant_or_word_spec.alternants) do
					multiword_spec.post_text = com.add_links(multiword_spec.post_text)
					for _, word_spec in ipairs(multiword_spec.word_specs) do
						word_spec.before_text = com.add_links(word_spec.before_text)
					end
				end
			end
		end
	end

	-- (2) Remove any links from the lemma, but remember the original form
	--     so we can use it below in the 'lemma_linked' form.
	iut.map_word_specs(alternant_multiword_spec, function(base)
		if base.lemma == "" then
			base.lemma = alternant_multiword_spec.args.pagename or
				alternant_multiword_spec.args.head and alternant_multiword_spec.args.head[1]
			if not base.lemma then
				local PAGENAME = mw.title.getCurrentTitle().text
				base.lemma = PAGENAME
			end
		end

		base.user_specified_lemma = base.lemma

		base.lemma = m_links.remove_links(base.lemma)
		local refl_verb, clitic = rmatch(base.lemma, "^(.-)(l[aeo]s?)$")
		if not refl_verb then
			refl_verb, clitic = base.lemma, nil
		end
		local verb, refl = rmatch(refl_verb, "^(.-)(se)$")
		if not verb then
			verb, refl = refl_verb, nil
		end
		base.user_specified_verb = verb
		base.refl = refl
		base.clitic = clitic

		if base.refl and base.clitic then
			-- We have to parse the verb suffix to see how to construct the base verb; e.g.
			-- abrírsela -> abrir but oírsela -> oír. We parse the verb suffix again in all cases
			-- in detect_indicator_spec(), after splitting off the prefix of irrregular verbs.
			local actual_verb
			local inf_stem, suffix = rmatch(base.user_specified_verb, "^(.*)([aáeéií]r)$")
			if not inf_stem then
				error("Unrecognized infinitive: " .. base.user_specified_verb)
			end
			if suffix == "ír" and inf_stem:find("[aeo]$") then
				-- accent on suffix should remain
				base.verb = base.user_specified_verb
			else
				base.verb = inf_stem .. com.remove_accent_from_syllable(suffix)
			end
		else
			base.verb = base.user_specified_verb
		end

		local linked_lemma
		if alternant_multiword_spec.args.noautolinkverb or base.user_specified_lemma:find("%[%[") then
			linked_lemma = base.user_specified_lemma
		elseif base.refl or base.clitic then
			-- Reconstruct the linked lemma with separate links around base verb, reflexive pronoun and clitic.
			linked_lemma = base.user_specified_verb == base.verb and "[[" .. base.user_specified_verb .. "]]" or
				"[[" .. base.verb .. "|" .. base.user_specified_verb .. "]]"
			linked_lemma = linked_lemma .. (refl and "[[" .. refl .. "]]" or "") ..
				(clitic and "[[" .. clitic .. "]]" or "")
		else
			-- Add links to the lemma so the user doesn't specifically need to, since we preserve
			-- links in multiword lemmas and include links in non-lemma forms rather than allowing
			-- the entire form to be a link.
			linked_lemma = com.add_links(base.user_specified_lemma)
		end
		base.linked_lemma = linked_lemma
	end)
end


local function construct_stems(base)
	local stems = base.stems
	stems.pres_unstressed = stems.pres_unstressed or base.inf_stem
	stems.pres_stressed = stems.pres_stressed or
		-- If no_pres_stressed given, pres_stressed stem should be empty so no forms are generated.
		base.no_pres_stressed and {} or
		base.vowel_alt or
		base.inf_stem
	stems.pres1_and_sub = stems.pres1_and_sub or
		-- If no_pres_stressed given, the entire subjunctive is missing.
		base.no_pres_stressed and {} or
		-- If no_pres1_and_sub given, pres1 and entire subjunctive are missing.
		base.no_pres1_and_sub and {} or
		nil
	stems.pres1 = stems.pres1 or stems.pres1_and_sub or stems.pres_stressed
	stems.impf = stems.impf or base.inf_stem
	stems.pret = stems.pret or base.inf_stem
	stems.pret_conj = stems.pret_conj or base.conj
	stems.fut = stems.fut or base.inf_stem .. base.conj
	stems.cond = stems.cond or stems.fut
	stems.pres_sub_stressed = stems.pres_sub_stressed or stems.pres1
	stems.pres_sub_unstressed = stems.pres_sub_unstressed or stems.pres1_and_sub or stems.pres_unstressed
	stems.impf_sub_ra = stems.impf_sub_ra or stems.pret
	stems.impf_sub_se = stems.impf_sub_se or stems.pret
	stems.fut_sub = stems.fut_sub or stems.pret
	stems.pp = stems.pp or base.conj == "ar" and
		combine_stem_ending(base, "pp_ms", base.inf_stem, "ad", "is combining ending") or
		-- use combine_stem_ending esp. so we get reído, caído, etc.
		combine_stem_ending(base, "pp_ms", base.inf_stem, "id", "is combining ending")
end


local function detect_indicator_spec(base)
	base.forms = {}
	base.stems = {}

	if base.only3s and base.only3sp then
		error("'only3s' and 'only3sp' cannot both be specified")
	end

	base.basic_overrides = {}
	base.basic_reflexive_only_overrides = {}
	base.combined_overrides = {}
	base.non_prefixed_verb = base.non_prefixed_verb or base.verb
	local inf_stem, suffix = rmatch(base.non_prefixed_verb, "^(.*)([aeií]r)$")
	if not inf_stem then
		error("Unrecognized infinitive: " .. base.verb)
	end
	base.inf_stem = inf_stem
	base.conj = suffix














	if base.stems.vowel_alt then -- irregular verb with specified vowel alternation
		if base.vowel_alt then
			error(base.verb .. " is a recognized irregular verb, and should not have vowel alternations specified with it")
		end
		base.vowel_alt = iut.convert_to_general_list_form(base.stems.vowel_alt)
	end

	-- Convert vowel alternation indicators into stems.
	if base.vowel_alt then
		for _, altform in ipairs(base.vowel_alt) do
			altform.alt = altform.form -- save original indicator
			local alt = altform.alt
			if base.conj == "ir" then
				local raising = (
					alt == "ie-i" or alt == "ye-i" or alt == "ue-u" or alt == "i" or alt == "í" or alt == "ú"
				)
				if base.stems.raising_conj == nil then
					base.stems.raising_conj = raising
				elseif base.stems.raising_conj ~= raising then
					error("Can't currently support a mixture of raising (e.g. 'ie-i') and non-raising (e.g. 'ie') vowel alternations in -ir verbs")
				end
			end
			if alt == "+" then
				altform.form = base.inf_stem
			else
				local normalized_alt = alt
				if alt == "ie-i" or alt == "ye-i" or alt == "ue-u" then
					if base.conj ~= "ir" then
						error("Vowel alternation '" .. alt .. "' only supported with -ir verbs")
					end
					-- ie-i is like i except for the vowel raising before i+V, similarly for ye-i, ue-u,
					-- so convert appropriately.
					normalized_alt = alt == "ie-i" and "ie" or alt == "ye-i" and "ye" or "ue"
				end
				local ret = com.apply_vowel_alternation(base.inf_stem, normalized_alt)
				if ret.err then
					error("To use '" .. alt .. "', present stem '" .. base.inf_stem .. "' " .. ret.err)
				end
				altform.form = ret.ret
			end
		end
	end
end


local function detect_all_indicator_specs(alternant_multiword_spec, from_headword)
	-- Propagate some settings up or down.
	iut.map_word_specs(alternant_multiword_spec, function(base)
		if base.is_pronominal then
			alternant_multiword_spec.is_pronominal = true
		end
		-- FIXME, old Spanish stuff
		if base.refl then
			alternant_multiword_spec.refl = true
		end
		if base.clitic then
			alternant_multiword_spec.clitic = true
		end
		base.from_headword = from_headword
		base.args = alternant_multiword_spec.args
		-- If fixed clitic, don't include combined forms.
		base.nocomb = alternant_multiword_spec.args.nocomb or base.clitic
	end)

	if not from_headword and not alternant_multiword_spec.args.nocomb then
		-- If we have a combined table, we run into issues if we have multiple
		-- verbs and some are reflexive and some aren't, because we use a
		-- different table for reflexive verbs. So throw an error.
		if alternant_multiword_spec.refl then
			iut.map_word_specs(alternant_multiword_spec, function(base)
				if not base.refl then
					error("If some alternants are reflexive, all must be")
				end
			end)
		end
	end

	iut.map_word_specs(alternant_multiword_spec, function(base)
		detect_indicator_spec(base)
		construct_stems(base)
	end)
end


local function add_categories_and_annotation(alternant_multiword_spec, base, multiword_lemma, from_headword)
	local function insert_ann(anntype, value)
		m_table.insertIfNot(alternant_multiword_spec.annotation[anntype], value)
	end

	local function insert_cat(cat, also_when_multiword)
		-- Don't place multiword terms in categories like 'Italian verbs ending in -ar' to avoid spamming the
		-- categories with such terms.
		if also_when_multiword or not multiword_lemma then
			m_table.insertIfNot(alternant_multiword_spec.categories, "Italian " .. cat)
		end
	end

	if check_for_red_links and not from_headword and not multiword_lemma then
		for _, slot_and_accel in ipairs(all_verb_slots) do
			local slot = slot_and_accel[1]
			local forms = base.forms[slot]
			local must_break = false
			if forms then
				for _, form in ipairs(forms) do
					if not form.form:find("%[%[") then
						local title = mw.title.new(form.form)
						if title and not title.exists then
							insert_cat("verbs with red links in their inflection tables")
							must_break = true
						break
						end
					end
				end
			end
			if must_break then
				break
			end
		end
	end

	insert_cat("verbs ending in -" .. base.conj)

	if base.irreg_verb then
		insert_ann("irreg", "irregular")
		insert_cat("irregular verbs")
	else
		insert_ann("irreg", "regular")
	end

	if base.only3s then
		insert_ann("defective", "impersonal")
		insert_cat("impersonal verbs")
	elseif base.only3sp then
		insert_ann("defective", "third-person only")
		insert_cat("third-person-only verbs")
	elseif base.no_pres_stressed or base.no_pres1_and_sub then
		insert_ann("defective", "defective")
		insert_cat("defective verbs")
	else
		insert_ann("defective", "regular")
	end

	if base.clitic then
		insert_cat("verbs with lexical clitics")
	end

	if base.refl then
		insert_cat("reflexive verbs")
	end

	if not base.vowel_alt then
		insert_ann("vowel_alt", "non-alternating")
	else
		local inf_stem = base.inf_stem:gsub("[gq]u$", "x")
		for _, alt in ipairs(base.vowel_alt) do
			if alt.alt == "+" then
				insert_ann("vowel_alt", "non-alternating")
			else
				local desc
				if alt.alt == "ue" and rfind(inf_stem, "u" .. C .. "*$") then
					desc = "u-ue alternation" -- jugar
				elseif alt.alt == "ie" and rfind(inf_stem, "i" .. C .. "*$") then
					desc = "i-ie alternation" -- adquirir
				elseif alt.alt == "í" and rfind(inf_stem, "e" .. C .. "*$") then
					desc = "e-í alternation" -- reír, freír, etc.
				else
					desc = vowel_alternant_to_desc[alt.alt] .. " alternation"
				end
				insert_ann("vowel_alt", desc)
				insert_cat("verbs with " .. desc)
			end
		end
	end

	local cons_alt = base.stems.cons_alt
	if cons_alt == nil then
		if base.conj == "ar" then
			if base.inf_stem:find("z$") then
				cons_alt = "c-z"
			elseif base.inf_stem:find("ç$") then
				cons_alt = "c-ç"
			elseif base.inf_stem:find("c$") then
				cons_alt = "c-qu"
			elseif base.inf_stem:find("g$") then
				cons_alt = "g-gu"
			elseif base.inf_stem:find("gu$") then
				cons_alt = "gu-gü"
			end
		else
			if base.no_pres_stressed or base.no_pres1_and_sub then
				cons_alt = nil -- no c-zc alternation in balbucir or arrecir
			elseif rfind(base.inf_stem, V .. "c$") then
				cons_alt = "c-zc"
			elseif base.inf_stem:find("sc$") then
				cons_alt = "hard-soft"
			elseif base.inf_stem:find("c$") then
				cons_alt = "c-z"
			elseif base.inf_stem:find("qu$") then
				cons_alt = "c-qu"
			elseif base.inf_stem:find("g$") then
				cons_alt = "g-j"
			elseif base.inf_stem:find("gu$") then
				cons_alt = "g-gu"
			elseif base.inf_stem:find("gü$") then
				cons_alt = "gu-gü"
			end
		end
	end

	if cons_alt then
		local desc = cons_alt .. " alternation"
		insert_ann("cons_alt", desc)
		insert_cat("verbs with " .. desc)
	else
		insert_ann("cons_alt", "non-alternating")
	end
end


-- Compute the categories to add the verb to, as well as the annotation to display in the
-- conjugation title bar. We combine the code to do these functions as both categories and
-- title bar contain similar information.
local function compute_categories_and_annotation(alternant_multiword_spec, from_headword)
	alternant_multiword_spec.categories = {}
	local ann = {}
	alternant_multiword_spec.annotation = ann
	ann.irreg = {}
	ann.defective = {}
	ann.vowel_alt = {}
	ann.cons_alt = {}

	local multiword_lemma = false
	for _, form in ipairs(alternant_multiword_spec.forms.infinitive) do
		if form.form:find(" ") then
			multiword_lemma = true
			break
		end
	end

	iut.map_word_specs(alternant_multiword_spec, function(base)
		add_categories_and_annotation(alternant_multiword_spec, base, multiword_lemma, from_headword)
	end)
	local ann_parts = {}
	local irreg = table.concat(ann.irreg, " or ")
	if irreg ~= "" and irreg ~= "regular" then
		table.insert(ann_parts, irreg)
	end
	local defective = table.concat(ann.defective, " or ")
	if defective ~= "" and defective ~= "regular" then
		table.insert(ann_parts, defective)
	end
	local vowel_alt = table.concat(ann.vowel_alt, " or ")
	if vowel_alt ~= "" and vowel_alt ~= "non-alternating" then
		table.insert(ann_parts, vowel_alt)
	end
	local cons_alt = table.concat(ann.cons_alt, " or ")
	if cons_alt ~= "" and cons_alt ~= "non-alternating" then
		table.insert(ann_parts, cons_alt)
	end
	alternant_multiword_spec.annotation = table.concat(ann_parts, "; ")
end


local function show_forms(alternant_multiword_spec)
	local lemmas = iut.map_forms(alternant_multiword_spec.forms.infinitive,
		remove_reflexive_indicators)
	alternant_multiword_spec.lemmas = lemmas -- save for later use in make_table()

	-- Initialize the footnotes with those for the future subjunctive and maybe the pres subjunctive
	-- voseo usage. In the latter case, we only do it if there is a distinct pres subjunctive voseo form.
	local function create_footnote_obj()
		local obj = iut.create_footnote_obj()
		iut.get_footnote_text({footnotes = {fut_sub_note}}, obj)
		-- Compute whether the tú and voseo variants are different, for each voseo variant.
		-- We use this later in make_table().
		for _, slot in ipairs({"pres_2s", "pres_sub_2s", "imp_2s"}) do
			alternant_multiword_spec["separate_" .. slot .. "v"] = false
			iut.map_word_specs(alternant_multiword_spec, function(base)
				if not m_table.deepEquals(base.forms[slot], base.forms[slot .. "v"]) then
					alternant_multiword_spec["separate_" .. slot .. "v"] = true
				end
			end)
		end
		if alternant_multiword_spec.separate_pres_sub_2sv then
			iut.get_footnote_text({footnotes = {pres_sub_voseo_note}}, obj)
		end
		return obj
	end

	local props = {
		lang = lang,
		lemmas = lemmas,
		create_footnote_obj = create_footnote_obj,
	}
	props.slot_list = verb_slots_basic
	iut.show_forms(alternant_multiword_spec.forms, props)
	alternant_multiword_spec.footnote_basic = alternant_multiword_spec.forms.footnote
	props.create_footnote_obj = nil
	props.slot_list = verb_slots_combined
	iut.show_forms(alternant_multiword_spec.forms, props)
	alternant_multiword_spec.footnote_combined = alternant_multiword_spec.forms.footnote
end


local notes_template = [=[
<div style="width:100%;text-align:left;background:#d9ebff">
<div style="display:inline-block;text-align:left;padding-left:1em;padding-right:1em">
{footnote}
</div></div>
]=]

local pres_2sv_template = '<sup><sup>tú</sup></sup><br />{pres_2sv}<sup><sup>vos</sup></sup>'
local pres_sub_2sv_template = '<sup><sup>tú</sup></sup><br />{pres_sub_2sv}<sup><sup>vos<sup style="color:red">2</sup></sup></sup>'
local imp_2sv_template = '<sup><sup>tú</sup></sup><br />{imp_2sv}<sup><sup>vos</sup></sup>'

local basic_table = [=[
{description}<div class="NavFrame">
<div class="NavHead" align=center>&nbsp; &nbsp; Conjugation of {title} (See [[Appendix:Italian verbs]])</div>
<div class="NavContent">
{\op}| style="background:#F9F9F9;text-align:center;width:100%"
|-
! colspan="3" style="background:#e2e4c0" | <span title="infinitivo">infinitive</span>
| colspan="5" | {infinitive}

|-
! colspan="3" style="background:#e2e4c0" | <span title="gerundio">gerund</span>
| colspan="5" | {gerund}

|-
! rowspan="3" colspan="2" style="background:#e2e4c0" | <span title="participio (pasado)">past participle</span>
| colspan="2" style="background:#e2e4c0" |
! colspan="2" style="background:#e2e4c0" | <span title="masculino">masculine</span>
! colspan="2" style="background:#e2e4c0" | <span title="femenino">feminine</span>
|-
! colspan="2" style="background:#e2e4c0" | singular
| colspan="2" | {pp_ms}
| colspan="2" | {pp_fs}
|-
! colspan="2" style="background:#e2e4c0" | plural
| colspan="2" | {pp_mp}
| colspan="2" | {pp_fp}

|-
! colspan="2" rowspan="2" style="background:#DEDEDE" |
! colspan="3" style="background:#DEDEDE" | singular
! colspan="3" style="background:#DEDEDE" | plural

|-
! style="background:#DEDEDE" | 1st person
! style="background:#DEDEDE" | 2nd person
! style="background:#DEDEDE" | 3rd person
! style="background:#DEDEDE" | 1st person
! style="background:#DEDEDE" | 2nd person
! style="background:#DEDEDE" | 3rd person

|-
! rowspan="6" style="background:#c0cfe4" | <span title="indicativo">indicative</span>

! style="background:#ECECEC;width:12.5%" |
! style="background:#ECECEC;width:12.5%" | yo
! style="background:#ECECEC;width:12.5%" | tú<br />vos
! style="background:#ECECEC;width:12.5%" | él/ella/ello<br />usted
! style="background:#ECECEC;width:12.5%" | nosotros<br />nosotras
! style="background:#ECECEC;width:12.5%" | vosotros<br />vosotras
! style="background:#ECECEC;width:12.5%" | ellos/ellas<br />ustedes

|-
! style="height:3em;background:#ECECEC" | <span title="presente de indicativo">present</span>
| {pres_1s}
| {pres_2s}{pres_2sv_text}
| {pres_3s}
| {pres_1p}
| {pres_2p}
| {pres_3p}

|-
! style="height:3em;background:#ECECEC" | <span title="pretérito imperfecto (copréterito)">imperfect</span>
| {impf_1s}
| {impf_2s}
| {impf_3s}
| {impf_1p}
| {impf_2p}
| {impf_3p}

|-
! style="height:3em;background:#ECECEC" | <span title="pretérito perfecto simple (pretérito indefinido)">preterite</span>
| {pret_1s}
| {pret_2s}
| {pret_3s}
| {pret_1p}
| {pret_2p}
| {pret_3p}

|-
! style="height:3em;background:#ECECEC" | <span title="futuro simple (futuro imperfecto)">future</span>
| {fut_1s}
| {fut_2s}
| {fut_3s}
| {fut_1p}
| {fut_2p}
| {fut_3p}

|-
! style="height:3em;background:#ECECEC" | <span title="condicional simple (pospretérito de modo indicativo)">conditional</span>
| {cond_1s}
| {cond_2s}
| {cond_3s}
| {cond_1p}
| {cond_2p}
| {cond_3p}

|-
! style="background:#DEDEDE;height:.75em" colspan="8" |
|-
! rowspan="5" style="background:#c0e4c0" | <span title="subjuntivo">subjunctive</span>
! style="background:#ECECEC" |
! style="background:#ECECEC" | yo
! style="background:#ECECEC" | tú<br />vos
! style="background:#ECECEC" | él/ella/ello<br />usted
! style="background:#ECECEC" | nosotros<br />nosotras
! style="background:#ECECEC" | vosotros<br />vosotras
! style="background:#ECECEC" | ellos/ellas<br />ustedes

|-
! style="height:3em;background:#ECECEC" | <span title="presente de subjuntivo">present</span>
| {pres_sub_1s}
| {pres_sub_2s}{pres_sub_2sv_text}
| {pres_sub_3s}
| {pres_sub_1p}
| {pres_sub_2p}
| {pres_sub_3p}

|-
! style="height:3em;background:#ECECEC" | <span title="pretérito imperfecto de subjuntivo">imperfect</span><br />(ra)
| {impf_sub_ra_1s}
| {impf_sub_ra_2s}
| {impf_sub_ra_3s}
| {impf_sub_ra_1p}
| {impf_sub_ra_2p}
| {impf_sub_ra_3p}

|-
! style="height:3em;background:#ECECEC" | <span title="pretérito imperfecto de subjuntivo">imperfect</span><br />(se)
| {impf_sub_se_1s}
| {impf_sub_se_2s}
| {impf_sub_se_3s}
| {impf_sub_se_1p}
| {impf_sub_se_2p}
| {impf_sub_se_3p}

|-
! style="height:3em;background:#ECECEC" | <span title="futuro simple de subjuntivo (futuro de subjuntivo)">future</span><sup style="color:red">1</sup>
| {fut_sub_1s}
| {fut_sub_2s}
| {fut_sub_3s}
| {fut_sub_1p}
| {fut_sub_2p}
| {fut_sub_3p}

|-
! style="background:#DEDEDE;height:.75em" colspan="8" |
|-
! rowspan="6" style="background:#e4d4c0" | <span title="imperativo">imperative</span>
! style="background:#ECECEC" |
! style="background:#ECECEC" | —
! style="background:#ECECEC" | tú<br />vos
! style="background:#ECECEC" | usted
! style="background:#ECECEC" | nosotros<br />nosotras
! style="background:#ECECEC" | vosotros<br />vosotras
! style="background:#ECECEC" | ustedes

|-
! style="height:3em;background:#ECECEC" | <span title="imperativo afirmativo">affirmative</span>
|
| {imp_2s}{imp_2sv_text}
| {imp_3s}
| {imp_1p}
| {imp_2p}
| {imp_3p}

|-
! style="height:3em;background:#ECECEC" | <span title="imperativo negativo">negative</span>
|
| {neg_imp_2s}
| {neg_imp_3s}
| {neg_imp_1p}
| {neg_imp_2p}
| {neg_imp_3p}
|{\cl}{notes_clause}</div></div>
]=]


local combined_form_table = [=[
{description}<div class="NavFrame">
<div class="NavHead" align=center>&nbsp; &nbsp; Selected combined forms of {title}</div>
<div class="NavContent">
These forms are generated automatically and may not actually be used. Pronoun usage varies by region.
{\op}| class="inflection-table" style="background:#F9F9F9;text-align:center;width:100%"

|-
! colspan="2" rowspan="2" style="background:#DEDEDE" |
! colspan="3" style="background:#DEDEDE" | singular
! colspan="3" style="background:#DEDEDE" | plural

|-
! style="background:#DEDEDE" | 1st person
! style="background:#DEDEDE" | 2nd person
! style="background:#DEDEDE" | 3rd person
! style="background:#DEDEDE" | 1st person
! style="background:#DEDEDE" | 2nd person
! style="background:#DEDEDE" | 3rd person

|-
! rowspan="3" style="background:#c0cfe4" | with infinitive {infinitive}

|-
! style="height:3em;background:#ECECEC" | dative
| {infinitive_comb_me}
| {infinitive_comb_te}
| {infinitive_comb_le}, {infinitive_comb_se}
| {infinitive_comb_nos}
| {infinitive_comb_os}
| {infinitive_comb_les}, {infinitive_comb_se}

|-
! style="height:3em;background:#ECECEC" | accusative
| {infinitive_comb_me}
| {infinitive_comb_te}
| {infinitive_comb_lo}, {infinitive_comb_la}, {infinitive_comb_se}
| {infinitive_comb_nos}
| {infinitive_comb_os}
| {infinitive_comb_los}, {infinitive_comb_las}, {infinitive_comb_se}

|-
! style="background:#DEDEDE;height:.35em" colspan="8" |
|-
! rowspan="3" style="background:#d0cfa4" | with gerund {gerund}

|-
! style="height:3em;background:#ECECEC" | dative
| {gerund_comb_me}
| {gerund_comb_te}
| {gerund_comb_le}, {gerund_comb_se}
| {gerund_comb_nos}
| {gerund_comb_os}
| {gerund_comb_les}, {gerund_comb_se}

|-
! style="height:3em;background:#ECECEC" | accusative
| {gerund_comb_me}
| {gerund_comb_te}
| {gerund_comb_lo}, {gerund_comb_la}, {gerund_comb_se}
| {gerund_comb_nos}
| {gerund_comb_os}
| {gerund_comb_los}, {gerund_comb_las}, {gerund_comb_se}

|-
! style="background:#DEDEDE;height:.35em" colspan="8" |
|-
! rowspan="3" style="background:#f2caa4" | with informal second-person singular imperative {imp_2s}

|-
! style="height:3em;background:#ECECEC" | dative
| {imp_2s_comb_me}
| {imp_2s_comb_te}
| {imp_2s_comb_le}
| {imp_2s_comb_nos}
| ''not used''
| {imp_2s_comb_les}

|-
! style="height:3em;background:#ECECEC" | accusative
| {imp_2s_comb_me}
| {imp_2s_comb_te}
| {imp_2s_comb_lo}, {imp_2s_comb_la}
| {imp_2s_comb_nos}
| ''not used''
| {imp_2s_comb_los}, {imp_2s_comb_las}

|-
! style="background:#DEDEDE;height:.35em" colspan="8" |
|-
! rowspan="3" style="background:#f2caa4" | with formal second-person singular imperative {imp_3s}

|-
! style="height:3em;background:#ECECEC" | dative
| {imp_3s_comb_me}
| ''not used''
| {imp_3s_comb_le}, {imp_3s_comb_se}
| {imp_3s_comb_nos}
| ''not used''
| {imp_3s_comb_les}

|-
! style="height:3em;background:#ECECEC" | accusative
| {imp_3s_comb_me}
| ''not used''
| {imp_3s_comb_lo}, {imp_3s_comb_la}, {imp_3s_comb_se}
| {imp_3s_comb_nos}
| ''not used''
| {imp_3s_comb_los}, {imp_3s_comb_las}

|-
! style="background:#DEDEDE;height:.35em" colspan="8" |
|-
! rowspan="3" style="background:#f2caa4" | with first-person plural imperative {imp_1p}

|-
! style="height:3em;background:#ECECEC" | dative
| ''not used''
| {imp_1p_comb_te}
| {imp_1p_comb_le}
| {imp_1p_comb_nos}
| {imp_1p_comb_os}
| {imp_1p_comb_les}

|-
! style="height:3em;background:#ECECEC" | accusative
| ''not used''
| {imp_1p_comb_te}
| {imp_1p_comb_lo}, {imp_1p_comb_la}
| {imp_1p_comb_nos}
| {imp_1p_comb_os}
| {imp_1p_comb_los}, {imp_1p_comb_las}

|-
! style="background:#DEDEDE;height:.35em" colspan="8" |
|-
! rowspan="3" style="background:#f2caa4" | with informal second-person plural imperative {imp_2p}

|-
! style="height:3em;background:#ECECEC" | dative
| {imp_2p_comb_me}
| ''not used''
| {imp_2p_comb_le}
| {imp_2p_comb_nos}
| {imp_2p_comb_os}
| {imp_2p_comb_les}

|-
! style="height:3em;background:#ECECEC" | accusative
| {imp_2p_comb_me}
| ''not used''
| {imp_2p_comb_lo}, {imp_2p_comb_la}
| {imp_2p_comb_nos}
| {imp_2p_comb_os}
| {imp_2p_comb_los}, {imp_2p_comb_las}

|-
! style="background:#DEDEDE;height:.35em" colspan="8" |
|-
! rowspan="3" style="background:#f2caa4" | with formal second-person plural imperative {imp_3p}

|-
! style="height:3em;background:#ECECEC" | dative
| {imp_3p_comb_me}
| ''not used''
| {imp_3p_comb_le}
| {imp_3p_comb_nos}
| ''not used''
| {imp_3p_comb_les}, {imp_3p_comb_se}

|-
! style="height:3em;background:#ECECEC" | accusative
| {imp_3p_comb_me}
| ''not used''
| {imp_3p_comb_lo}, {imp_3p_comb_la}
| {imp_3p_comb_nos}
| ''not used''
| {imp_3p_comb_los}, {imp_3p_comb_las}, {imp_3p_comb_se}
|{\cl}{notes_clause}</div></div>
]=]


local combined_form_reflexive_table = [=[
{description}<div class="NavFrame">
<div class="NavHead" align=center>&nbsp; &nbsp; Selected combined forms of {title}</div>
<div class="NavContent">
{| class="inflection-table" style="background:#F9F9F9;text-align:center;width:100%"

|-
! colspan="2" rowspan="2" style="background:#DEDEDE" |
! colspan="3" style="background:#DEDEDE" | singular
! colspan="3" style="background:#DEDEDE" | plural

|-
! style="background:#DEDEDE" | 1st person
! style="background:#DEDEDE" | 2nd person
! style="background:#DEDEDE" | 3rd person
! style="background:#DEDEDE" | 1st person
! style="background:#DEDEDE" | 2nd person
! style="background:#DEDEDE" | 3rd person

|-
! rowspan="2" style="background:#c0cfe4" | Infinitives

|-
! style="height:3em;background:#ECECEC" | accusative
| {infinitive_comb_me}
| {infinitive_comb_te}
| {infinitive_comb_se}
| {infinitive_comb_nos}
| {infinitive_comb_os}
| {infinitive_comb_se}

|-
! style="background:#DEDEDE;height:.35em" colspan="8" |
|-
! rowspan="2" style="background:#d0cfa4" | gerunds

|-
! style="height:3em;background:#ECECEC" | accusative
| {gerund_comb_me}
| {gerund_comb_te}
| {gerund_comb_se}
| {gerund_comb_nos}
| {gerund_comb_os}
| {gerund_comb_se}

|-
! style="background:#DEDEDE;height:.35em" colspan="8" |
|-
! rowspan="2" style="background:#f2caa4" | with positive imperatives

|-
! style="height:3em;background:#ECECEC" | accusative
| ''not used''
| {imp_2s_comb_te}
| {imp_3s_comb_se}
| {imp_1p_comb_nos}
| {imp_2p_comb_os}
| {imp_3p_comb_se}
|{\cl}{notes_clause}</div></div>
]=]


local function make_table(alternant_multiword_spec)
	local forms = alternant_multiword_spec.forms

	forms.title = link_term(alternant_multiword_spec.lemmas[1].form, "term")
	if alternant_multiword_spec.annotation ~= "" then
		forms.title = forms.title .. " (" .. alternant_multiword_spec.annotation .. ")"
	end
	forms.description = ""

	-- Format the basic table.
	forms.footnote = alternant_multiword_spec.footnote_basic
	forms.notes_clause = forms.footnote ~= "" and m_string_utilities.format(notes_template, forms) or ""
	-- The separate_* values are computed in show_forms().
	forms.pres_2sv_text = alternant_multiword_spec.separate_pres_2sv and m_string_utilities.format(pres_2sv_template, forms) or ""
	forms.pres_sub_2sv_text = alternant_multiword_spec.separate_pres_sub_2sv and m_string_utilities.format(pres_sub_2sv_template, forms) or ""
	forms.imp_2sv_text = alternant_multiword_spec.separate_imp_2sv and m_string_utilities.format(imp_2sv_template, forms) or ""
	local formatted_basic_table = m_string_utilities.format(basic_table, forms)

	-- Format the combined table.
	local formatted_combined_table
	if alternant_multiword_spec.args.nocomb or alternant_multiword_spec.clitic then
		formatted_combined_table = ""
	else
		forms.footnote = alternant_multiword_spec.footnote_combined
		forms.notes_clause = forms.footnote ~= "" and m_string_utilities.format(notes_template, forms) or ""
		local combined_table = alternant_multiword_spec.refl and combined_form_reflexive_table or combined_form_table
		formatted_combined_table = m_string_utilities.format(combined_table, forms)
	end

	-- Paste them together.
	return formatted_basic_table .. formatted_combined_table
end


-- Externally callable function to parse and conjugate a verb given user-specified arguments.
-- Return value is WORD_SPEC, an object where the conjugated forms are in `WORD_SPEC.forms`
-- for each slot. If there are no values for a slot, the slot key will be missing. The value
-- for a given slot is a list of objects {form=FORM, footnotes=FOOTNOTES}.
function export.do_generate_forms(parent_args, from_headword, def)
	local params = {
		[1] = {required = true, default = def or "mettere<a\é,mìsi,mésso>"},
		["nocomb"] = {type = "boolean"},
		["noautolinktext"] = {type = "boolean"},
		["noautolinkverb"] = {type = "boolean"},
		params["pagename"] = {} -- for testing
	}

	if from_headword then
		params["head"] = {list = true}
		params["id"] = {}
	end

	local args = require("Module:parameters").process(parent_args, params)

	local iut = require("Module:inflection utilities")

	local arg1 = args[1]
	local need_surrounding_angle_brackets = true
	-- Check whether we need to add <...> around the argument. If the
	-- argument has no < in it, we definitely do. Otherwise, we need to
	-- parse the balanced [...] and <...> and add <...> only if there isn't
	-- a top-level <...>. We check for [...] because there might be angle
	-- brackets inside of them (HTML tags in qualifiers or <<name:...>> and
	-- such in references).
	if arg1:find("<") then
		local segments = iut.parse_multi_delimiter_balanced_segment_run(arg1,
			{{"<", ">"}, {"[", "]"}})
		for i = 2, #segments, 2 do
			if segments[i]:find("^<.*>$") then
				need_surrounding_angle_brackets = false
				break
			end
		end
	end
	if need_surrounding_angle_brackets then
		arg1 = "<" .. arg1 .. ">"
	end

	local parse_props = {
		parse_indicator_spec = parse_indicator_spec,
		lang = lang,
		allow_default_indicator = true,
		allow_blank_lemma = true,
	}
	local escaped_arg1 = escape_reflexive_indicators(arg1)
	local alternant_multiword_spec = iut.parse_inflected_text(escaped_arg1, parse_props)
	alternant_multiword_spec.pos = pos or "verbs"
	alternant_multiword_spec.args = args
	normalize_all_lemmas(alternant_multiword_spec)
	detect_all_indicator_specs(alternant_multiword_spec, from_headword)
	local inflect_props = {
		slot_list = all_verb_slots,
		lang = lang,
		inflect_word_spec = conjugate_verb,
		-- We add links around the generated verbal forms rather than allow the entire multiword
		-- expression to be a link, so ensure that user-specified links get included as well.
		include_user_specified_links = true,
	}
	iut.inflect_multiword_or_alternant_multiword_spec(alternant_multiword_spec, inflect_props)

	-- Remove redundant brackets around entire forms.
	for slot, forms in pairs(alternant_multiword_spec.forms) do
		for _, form in ipairs(forms) do
			form.form = com.strip_redundant_links(form.form)
		end
	end

	compute_categories_and_annotation(alternant_multiword_spec, from_headword)
	return alternant_multiword_spec
end


-- Entry point for {{es-conj}}. Template-callable function to parse and conjugate a verb given
-- user-specified arguments and generate a displayable table of the conjugated forms.
function export.show(frame)
	local parent_args = frame:getParent().args
	local alternant_multiword_spec = export.do_generate_forms(parent_args)
	show_forms(alternant_multiword_spec)
	return make_table(alternant_multiword_spec) ..
		require("Module:utilities").format_categories(alternant_multiword_spec.categories, lang, nil, nil, force_cat)
end


-- Concatenate all forms of all slots into a single string of the form
-- "SLOT=FORM,FORM,...|SLOT=FORM,FORM,...|...". Embedded pipe symbols (as might occur
-- in embedded links) are converted to <!>. If INCLUDE_PROPS is given, also include
-- additional properties (currently, none). This is for use by bots.
local function concat_forms(alternant_multiword_spec, include_props)
	local ins_text = {}
	for _, slot_and_accel in ipairs(all_verb_slots) do
		local slot = slot_and_accel[1]
		local formtext = iut.concat_forms_in_slot(alternant_multiword_spec.forms[slot])
		if formtext then
			table.insert(ins_text, slot .. "=" .. formtext)
		end
	end
	return table.concat(ins_text, "|")
end


-- Template-callable function to parse and conjugate a verb given user-specified arguments and return
-- the forms as a string "SLOT=FORM,FORM,...|SLOT=FORM,FORM,...|...". Embedded pipe symbols (as might
-- occur in embedded links) are converted to <!>. If |include_props=1 is given, also include
-- additional properties (currently, none). This is for use by bots.
function export.generate_forms(frame)
	local include_props = frame.args["include_props"]
	local parent_args = frame:getParent().args
	local alternant_multiword_spec = export.do_generate_forms(parent_args)
	return concat_forms(alternant_multiword_spec, include_props)
end


return export
