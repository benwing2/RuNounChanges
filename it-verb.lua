local export = {}


--[=[

Authorship: Ben Wing <benwing2>

]=]

--[=[

TERMINOLOGY:

-- "slot" = A particular combination of tense/mood/person/number/etc.
	 Example slot names for verbs are "pres1p" (present indicative first-person plural), "impsub12s" (imperfect
	 subjunctive first/second-person singular form) and "pp" (past participle).
	 Each slot is filled with zero or more forms.

-- "form" = The conjugated Italian form representing the value of a given slot.

-- "lemma" = The dictionary form of a given Italian term. For Italian, always the infinitive.
]=]

--[=[

RULES FOR CONJUGATION:

1. Present indicative:
-- Individual form overrides always take precedence.
-- Otherwise, if presrow: if given, this specifies all six forms (1s, 2s, 3s, 1p, 2p, 3p).
-- Otherwise:
   1. The 1s form is generated from the explicitly specified pres1s principal part.
   2. The 3p form is generated from the explicitly specified pres1s principal part by replacing -o with -ano (for -are verbs)
      or with -ono (for -ere/-ire verbs).
   3. The 2s and 3s forms are generated as follows:
      a. If an explicit pres3s principal part is given using PRES1S#PRES3S, the 2s/3s stem is generated by removing final -a/-e.
	  b. Otherwise, if an explicit stem was given using stem:, this serves as the 2s/3s stem.
	  c. Otherwise, if the infinitive is root-stressed, the 2s/3s stem comes from the infinitive. This is used e.g.
		 with [[togliere]] (tòlgo, tògli, tòglie, togliàmo, togliéte, tòlgono), where the stem of the 1s and 3p forms
		 is different from the stem of the 2s and 3s forms.
	  d. Otherwise, the pres1s stem is used.
	  From this stem, the 2s form is generated by adding -i (possibly with some adjustments; two unstressed i's
	  together are compressed to one, and -h- is inserted after the stem if the verb is an -are verb and the stem ends
	  with -c or -g), and the 3s form is generated by adding -a (for -are verbs) or -e (for -ere/-ire verbs).
   4. The 1p and 2p forms are generated from the infinitive stem (or explicit stem given by stem:) by adding -iàmo
      (1p form) and -àte/-éte/-ìte (2p form, -are/-ere/-ire verbs). We don't use the pres1s form because it might have
	  a different stem (e.g. +isc verbs).

2. Present subjunctive:
-- Individual form overrides always take precedence.
-- Otherwise, if subrow: if given, this specifies all four forms (123s, 1p, 2p, 3p).
-- Otherwise:
   1. If sub: is given, this specifies the 123s form; otherwise the 123s form is generated from the pres1s form by
   changing -o to -a (for -ere/-ire verbs), or to -i (for -are verbs). E.g. for [[venire]], vèngo -> vènga;
   for [[potere]], pòsso -> pòssa. sub: needs to be given for e.g. [[essere]] (pres1s sóno, sub1s sìa),
   [[sapere]] (pres1s sò* but sub1s sàppia), [[fare]] (pres1s fàccio:fò*[archaic or dialectal] but sub1s just fàccia),
   [[andare]] (similar to [[fare]]), [[dovere]].
   2. The 3p form is generated from the 123s form by adding -no.
   3. The 1p form is copied from the pres1p form.
   4. The 2p form is generated from the 1p form by replacing -mo with -te.

3. Imperative:
-- If noimp given, the imperative is suppressed.
-- Otherwise, individual form overrides take precedence.
-- Otherwise, if improw: if given, this specifies 2s, 2p.
-- Otherwise:
   1. If imp: given, this specifies the 2s form; otherwise the 2s form is generated by copying the pres2s form
      (for -ere/-ire verbs) or by copying the pres3s form (for -are verbs). We use the present indicative 2s/3s
	  forms to preserve vowel and other alternations in the root-stressed forms (for all -are verbs, for
	  [[venire]] and [[tenere]], for +isc verbs, etc.).
   2. The 2p form is generated by copying the pres2p form.
   3. The 3s, 1p, 3p forms are copied from the corresponding present subjunctive forms.
]=]

--[=[

EXAMPLES OF CONJUGATION:

{{it-conj|mettere<a\é,mìsi,mésso>}}

{{it-conj|arrivare<e:a[transitive]/ì>}}

{{it-conj|trovare<a/ò>}}

{{it-conj|sembrare<e/é>}}

{{it-conj|temprare<e/é:#è>}}

{{it-conj|essere<e\è\-,-,stàto.
  presrow:sóno,sèi,è,siàmo,siète,sóno.
  imperfrow:èro,èri,èra,eravàmo,eravàte,èrano.
  phisrow:fùi,fósti,fù*,fùmmo,fóste,fùrono.
  fut:sarò.
  sub:sìa.
  impsub:fóssi.
  improw:sìi:siàte.
  presp:essènte[rare]
>}}

; Including archaic and literary forms:
{{it-conj|essere<e\è\-,-,stàto:essùto[archaic]:sùto[archaic].
  presrow:sóno,sèi,è,siàmo:sémo[archaic],siète:sète[archaic],sóno:èmmo[archaic].
  imperfrow:èro:èra[literary],èri,èra,eravàmo:èramo[archaic],eravàte,èrano.
  phisrow:fùi,fósti:fùsti[archaic],fù*,fùmmo,fóste:fùste[archaic],fùrono:fùro[archaic]:fóre[archaic]:fòro[archaic].
  futrow:sarò,sarài,sarà:fìa[archaic]:fìe[archaic],sarémo,saréte,sarànno:fìano[archaic]:fìeno[archaic].
  condrow:sarèi:sarìa[archaic]:fòra[archaic],sarésti,sarèbbe:sarìa[archaic]:fòra[archaic],sarémmo,saréste,sarèbbero:sarìano[archaic]:fòro[archaic].
  subrow:sìa,siàmo,siàte,sìano:sìeno[literary].
  impsub:fóssi:fùssi[archaic].
  improw:sìi:siàte.
  ger:essèndo:sèndo[archaic].
  presp:essènte[rare]:ènte[archaic]
>}}

{{it-conj|fare<a/-,féci,fàtto.
  stem:fàce.
  presrow:fàccio:fò*[archaic or dialectal],fài,fà*,facciàmo,fàte,fànno.
  sub:fàccia.
  imp:fà*:fài:fà'
>}}

{{it-conj|potere<a:e[as an auxiliary, with main verbs taking ''essere'']/-,potéi:potètti[less common].
  presrow:pòsso,puòi,può*,possiàmo,potéte,pòssono.
  fut:potrò.
  noimp
>}}

{{it-conj|dire<a/+,dìssi,détto.
  stem:dìce.
  pres2p:dìte.
  imp:dì':*dì*
>}}

{{it-conj|dare<a/dò*:*dò*,dièdi:dètti,dàto.
  presrow:dò*:*dò*,dài,*dà*,diàmo,dàte,dànno.
  sub:dìa.
  fut:darò.
  impsub:déssi.
  imp:dài:da':*dà*
>}}

{{it-conj|dovere<a:e[as an auxiliary, with main verbs taking ''essere'']/dèvo:dévo:dèbbo:débbo#dève:déve.
  fut:dovrò.
  sub:dèbba:débba:dèva[rare]:déva[rare].
  noimp
>}}

; Including archaic and poetic forms:
{{it-conj|dovere<a:e[as an auxiliary, with main verbs taking ''essere'']/-.
  presrow:
    dèvo:dévo:dèbbo:débbo:dèggio[archaic or poetic]:déggio[archaic or poetic],
    dèvi:dévi:dèi[archaic, poetic or popular Tuscan]:déi[archaic, poetic or popular Tuscan],
    dève:déve:dèe[archaic, poetic or popular Tuscan]:dée[archaic, poetic or popular Tuscan]:dèbbe[archaic]:débbe[archaic],
    dobbiàmo,
    dovéte,
	dèvono:dévono:dèbbono:débbono:dènno[archaic or poetic]:dénno[archaic or poetic].
  fut:dovrò.
  sub:dèbba:débba:dèva[rare]:déva[rare]:dèggia[archaic or poetic]:déggia[archaic or poetic]:dèbbia[obsolete]:débbia[obsolete].
  noimp
>}}

{{it-conj|andare<e/-.
  presrow:vàdo:vò*[less common],vài,và*,andiàmo,andàte,vànno.
  fut:andrò.
  sub:vàda.
  imp:vài:và':và*
>}}

{{it-conj|valere<e:a[transitive]/vàlgo#à,vàlsi,vàlso.fut:varrò>}}

{{it-conj|vedere<a/védo:véggo[literary]:véggio[poetic]#é,vìdi,vìsto:vedùto[less popular].
  fut:vedrò
>}}

{{it-conj|venire<e/vèngo:vègno[archaic or poetic]#viène,vénni,venùto.
  fut:verrò
>}}

{{it-conj|sapere<a:e[as an auxiliary, with main verbs taking ''essere'']/-,sèppi.
  presrow:sò*,sài,sà*,sappiàmo,sapéte,sànno.
  fut:saprò.
  sub:sàppia.
  improw:sàppi:sappiàte
>}}

{{it-conj|piacere<e/piàccio#piàce,piàcqui.pres1p:piacciàmo>}}

{{it-conj|comparire<e/compàio:+isc[less common]#à:+isc[less common],compàrvi:comparìi[less common]:compàrsi[in the legal sense],compàrso:comparìto[rare]>}}

{{it-conj|togliere<a\ò\tòlgo,tòlsi,tòlto.fut:+:torrò[literary].presp:+>}}

{{it-conj|condurre<a\+,condùssi,condótto.stem:condùce>}}

{{it-conj|proporre<a\ó+\propóngo,propósi,propósto:propòsto.stem:propóne>}}

{{it-conj|trarre<a\tràggo,tràssi,tràtto.stem:tràe>}}


; Third-person only verbs:

{{it-conj|bufare<e/ù.only3s>}}

{{it-verb|accadere<e/à+,accàdde.fut:accadrà.only3sp>}}

{{it-verb|volerci<e/vuòle,vòlle.fut:vorrà.sub:vòglia.only3s>}}

; Defective verbs:

{{it-verb|redire<a/rièdo,-,redìto.imperf:-.fut:-.impsub:->}}

{{it-verb|serpere<-\è,+,->}}

; Multiword expressions:

{{it-verb|tenere<a/tèngo#tiène,ténni.fut:terrò> [[d']][[occhio]]}}

{{it-conj|trascinare<a/ì> e rilasciare<a/à>}}

]=]

--[=[

FIXME:

1. Support third-person only verbs.
2. Support reflexive verbs.
3. Support pronominal verbs.
4. Support calling from [[Module:it-headword]].
5. Implement categories.
6. Implement replace_reflexive_indicators().
7. Disallow + for present.
]=]

--[=[

FIXME (OLD FOR SPANISH):

1. Implement no_pres_stressed for aterir, garantir. (NOTE: Per RAE, garantir used in all forms in Argentina/Uruguay.) [DONE]
2. Support concluyo. [DONE]
3. Fixes for veo -> ve vs. preveo -> prevé. [DONE]
4. Various more irregular verbs, e.g. predecir, redecir, bendecir, maldecir. [DONE]
5. Raising of e -> i, o -> u before -iendo, -ió, etc. occurs only in -ir verbs. [DONE]
6. Raising of e -> i, o -> u happens before subjunctive -amos, -áis in -ir verbs. [DONE]
7. Implement reflexive verbs. [DONE]
8. Implement categories. [DONE]
9. Implement show_forms. [DONE]
10. Reconcile stems.vowel_alt from irregular verbs with vowel_alt from indicators. May require
    moving the irregular-verb handling code in construct_stems() into detect_indicator_spec(). [DONE]
11. Implement make_table. [DONE]
12. Vowel alternation should show u-ue (jugar), i-ie (adquirir), e-í (reír) alternations specially. [DONE]
13. Handle linking of multiword forms as is done in [[Module:es-headword]]. [DONE]
14. Implement comparison against previous module. [DONE]
15. Implement categorization of irregularities for individual tenses.
16. Support nocomb=1. [DONE]
17. (Possibly) display irregular forms in a different color, as with the old module.
18. (Possibly) display a "rule" description indicating the types of alternations.
19. Implement replace_reflexive_indicators().
20. Implement verbs with attached clitics e.g. [[pasarlo]], [[corrérsela]]. [DONE]
21. When footnote + tú/vos notation, add a space before tú/vos.
22. Fix [[erguir]] so ie-i vowel alternation produces ye- at beginning of word, similarly for errar. Also allow
    multiple vowel alternation specs in irregular verbs, for errar. Finally, ie should show as e-ye for errar
    and as e-ye-i for erguir. [DONE]
23. Figure out why red links in combined forms show up as black not red.
24. Consider including alternative superseded forms of verbs like [[ciar]] (e.g. pret_3s = cio, ció with footnote).
25. Allow conjugation of suffixes e.g. -ir, -ecer; need to fix in [[Module:inflection utilities]]. [DONE]
26. Allow specification of stems esp. so that footnotes can be hung off them; use + for the default.
27. Don't remove monosyllabic accents when conjugating suffixes. [DONE]
28. If multiword expression with no <>, add <> after first word, as with [[Module:es-headword]]. [DONE]
29. (Possibly) link the parts of a reflexive or cliticized infinitive, as done in [[Module:es-headword]]. [DONE]
30. Final fixes to allow [[Module:es-headword]] to use this module. [DONE]
--]=]

local lang = require("Module:languages").getByCode("it")
local m_string_utilities = require("Module:string utilities")
local m_links = require("Module:links")
local m_table = require("Module:table")
local iut = require("Module:User:Benwing2/inflection utilities")

local force_cat = false -- set to true for debugging
local check_for_red_links = false -- set to false for debugging

local u = mw.ustring.char
local rfind = mw.ustring.find
local rsubn = mw.ustring.gsub
local rmatch = mw.ustring.match
local rsplit = mw.text.split
local ulower = mw.ustring.lower
local uupper = mw.ustring.upper
local usub = mw.ustring.sub
local ulen = mw.ustring.len
local unfd = mw.ustring.toNFD
local unfc = mw.ustring.toNFC

-- version of rsubn() that discards all but the first return value
local function rsub(term, foo, bar)
	local retval = rsubn(term, foo, bar)
	return retval
end

local GR = u(0x0300)
local V = "[aeiou]"
local NV = "[^aeiou]"
local AV = "[àèéìòóù]"
local MAV = "[aeiouàèéìòóù]" -- maybe-accented vowel
local NMAV = "[^aeiouàèéìòóù]" -- not maybe-accented vowel

local PRESERVE_ACCENT = u(0xFFF0)

local function link_term(term, face)
	return m_links.full_link({ lang = lang, term = term }, face)
end

-- Used to create the accelerator entries in all_verb_slots.
local person_number_tag_prefix = {
	["1s"] = "1|s|",
	["2s"] = "2|s|",
	["3s"] = "3|s|",
	["12s"] = "1//2|s|",
	["123s"] = "1//2//3|s|",
	["1p"] = "1|p|",
	["2p"] = "2|p|",
	["3p"] = "3|p|",
	[""] = "", -- used for non-finite forms such as the past participle
}

person_number_to_reflexive_pronoun = {
	["1s"] = "mi",
	["2s"] = "ti",
	["3s"] = "si",
	["1p"] = "ci",
	["2p"] = "vi",
	["3p"] = "si",
}

local reflexive_masc_forms = {
	["su"] = {"mi", "tu", "su", "nuestro", "vuestro", "su"},
	["sus"] = {"mis", "tus", "sus", "nuestros", "vuestros", "sus"},
	["sí"] = {"mí", "ti", "sí", "nosotros", "vosotros", "sí"},
}

local reflexive_fem_forms = {
	["si"] = {"mi", "tu", "su", "nuestra", "vuestra", "su"},
	["sus"] = {"mis", "tus", "sus", "nuestras", "vuestras", "sus"},
	["sí"] = {"mí", "ti", "sí", "nosotras", "vosotras", "sí"},
}

local reflexive_forms = {
	["si"] = {"mi", "ti", "si", "ci", "vi", "si"},
	["suyo"] = {"mío", "tuyo", "suyo", "nuestro", "vuestro", "suyo"},
	["suya"] = {"mía", "tuya", "suya", "nuestra", "vuestra", "suya"},
	["suyos"] = {"míos", "tuyos", "suyos", "nuestros", "vuestros", "suyos"},
	["suyas"] = {"mías", "tuyas", "suyas", "nuestras", "vuestras", "suyas"},
}


local function remove_accents(form)
	return rsub(form, AV, function(v) return usub(unfd(v), 1, 1) end)
end


-- Add links around words. If multiword_only, do it only in multiword forms.
local function add_links(form, multiword_only)
	if form == "" or form == " " then
		return form
	end
	if not form:find("%[%[") then
		if rfind(form, "[%s%p]") then --optimization to avoid loading [[Module:headword]] on single-word forms
			local m_headword = require("Module:headword")
			if m_headword.head_is_multiword(form) then
				form = m_headword.add_multiword_links(form)
			end
		end
		if not multiword_only and not form:find("%[%[") then
			form = "[[" .. form .. "]]"
		end
	end
	return form
end


-- Convert links around accented words to two-part links without extra accents.
local function convert_accented_links(text)
	return rsub(text, "%[%[([^%[%]|]+)%]%]",
		function(linktext)
			if rfind(linktext, "^.*" .. MAV .. ".*" .. AV .. "$") then
				-- final accented vowel with preceding vowel; keep accent
				return linktext
			elseif rfind(linktext, PRESERVE_ACCENT) then
				return rsub(linktext, PRESERVE_ACCENT, "")
			else
				local unaccented = remove_accents(linktext)
				if unaccented == linktext then
					return linktext
				else
					return unaccented .. "|" .. linktext
				end
			end
		end)
end


local function strip_spaces(text)
	return text:gsub("^%s*(.-)%s*", "%1")
end


local function check_not_null(base, form, spec, principal_part_desc)
	if not form then
		error("Spec '" .. spec .. "' cannot be used because default " .. principal_part_desc .. " cannot be derived from '"
			.. base.lemma .. "'")
	end
end


local function skip_slot(base, slot, allow_overrides)
	if not allow_overrides and (base.basic_overrides[slot] or base.combined_overrides[slot] or
		base.refl and base.basic_reflexive_only_overrides[slot]) then
		-- Skip any slots for which there are overrides.
		return true
	end

	if not slot:find("[123]") then
		-- Don't skip non-personal slots.
		return false
	end

	if base.nofinite then
		return true
	end

	if base.only3s and (not slot:find("3s") or slot:find("^imp[123]") or slot:find("^negimp")) then
		-- diluviar, atardecer, neviscar
		return true
	end

	if base.only3sp and (not slot:find("3[sp]") or slot:find("^imp[123]") or slot:find("^negimp")) then
		-- atañer, concernir
		return true
	end

	return false
end


local function escape_reflexive_indicators(arg1)
	if not arg1:find("pron>") then
		return arg1
	end
	local segments = iut.parse_balanced_segment_run(arg1, "<", ">")
	-- Loop over every other segment. The even-numbered segments are angle-bracket specs while
	-- the odd-numbered segments are the text between them.
	for i = 2, #segments - 1, 2 do
		if segments[i] == "<mpron>" then
			segments[i] = "⦃⦃mpron⦄⦄"
		elseif segments[i] == "<fpron>" then
			segments[i] = "⦃⦃fpron⦄⦄"
		elseif segments[i] == "<pron>" then
			segments[i] = "⦃⦃pron⦄⦄"
		end
	end
	return table.concat(segments)
end


local function undo_escape_form(form)
	-- assign to var to throw away second value
	local newform = form:gsub("⦃⦃", "<"):gsub("⦄⦄", ">")
	return newform
end


local function remove_reflexive_indicators(form)
	-- assign to var to throw away second value
	local newform = form:gsub("⦃⦃.-⦄⦄", "")
	return newform
end


local function replace_reflexive_indicators(slot, form)
	if not form:find("⦃") then
		return form
	end
	error("Internal error: replace_reflexive_indicators not implemented yet")
end


-- Add the `stem` to the `ending` for the given `slot` and apply any phonetic modifications.
local function combine_stem_ending(base, slot, stem, ending)
	-- Add h after c/g in -are forms to preserve the sound.
	if base.conj_vowel == "à" and stem:find("[cg]$") and rfind(ending, "^[eèéiì]") then
		stem = stem .. "h"
	end

	-- Two unstressed i's coming together compress to one.
	if ending:find("^i") then
		stem = stem:gsub("i$", "")
	end

	-- Remove accents from stem if ending is accented.
	if rfind(ending, AV) then
		stem = remove_accents(stem)
	end

	return stem .. ending
end


local function add(base, slot, stems, endings, allow_overrides)
	--if skip_slot(base, slot, allow_overrides) then
	--	return
	--end
	local function do_combine_stem_ending(stem, ending)
		return combine_stem_ending(base, slot, stem, ending)
	end
	iut.add_forms(base.forms, slot, stems, endings, do_combine_stem_ending)
end


local function insert_form(base, slot, form)
	--if not skip_slot(base, slot) then
		iut.insert_form(base.forms, slot, form)
	--end
end


local function insert_forms(base, slot, forms)
	--if not skip_slot(base, slot) then
		iut.insert_forms(base.forms, slot, forms)
	--end
end


local function copy_forms(base, slot, forms)
	-- FIXME, is this needed? This is the same as insert_forms() but clones `forms`.
	-- Probably not needed as I don't think we ever side-effect existing forms.
	insert_forms(base, slot, iut.map_forms(forms, iut.identity))
end


local function general_list_form_contains_form(list, form, process_form)
	for _, formobj in ipairs(list) do
		local formobj_form = formobj.form
		if process_form then
			formobj_form = process_form(formobj_form)
		end
		if formobj_form == form then
			return true
		end
	end
	return false
end


local function process_specs(base, destforms, slot, specs, is_finite, special_case)
	specs = specs or {{form = "+"}}
	for _, spec in ipairs(specs) do
		local decorated_form = spec.form
		local prespec, form, syntactic_gemination =
			rmatch(decorated_form, "^([*!#]*)(.-)(%**)$")
		local forms = special_case(base, form)
		forms = iut.convert_to_general_list_form(forms, spec.footnotes)
		if base.all_footnotes then
			forms = iut.convert_to_general_list_form(forms, base.all_footnotes)
		end
		for _, formobj in ipairs(forms) do
			local qualifiers = formobj.footnotes
			local form = formobj.form
			-- If the form is -, insert it directly, unlinked; we handle this specially
			-- below, turning it into special labels like "no past participle".
			if form ~= "-" then
				if prespec:find("!!") then
					qualifiers = iut.combine_footnotes({"[elevated style]"}, qualifiers)
					prespec = prespec:gsub("!!", "")
				end
				if prespec:find("!") then
					qualifiers = iut.combine_footnotes({"[careful style]"}, qualifiers)
					prespec = prespec:gsub("!", "")
				end
				if prespec:find("#") then
					qualifiers = iut.combine_footnotes({"[traditional]"}, qualifiers)
					prespec = prespec:gsub("#", "")
				end
				local preserve_monosyllabic_accent
				if prespec:find("%*") then
					preserve_monosyllabic_accent = true
					prespec = prespec:gsub("%*", "")
				end
				local unaccented_form
				if preserve_monosyllabic_accent and rfind(form, "^" .. NMAV .. "*" .. AV .. "$")  then
					-- final accented vowel without preceding vowel, and "*" before form; add PRESERVE_ACCENT
					form = PRESERVE_ACCENT .. form
				end
				if syntactic_gemination == "*" then
					qualifiers = iut.combine_footnotes(qualifiers, {"[with following syntactic gemination]"})
				elseif syntactic_gemination == "**" then
					qualifiers = iut.combine_footnotes(qualifiers, {"[with optional following syntactic gemination]"})
				elseif syntactic_gemination ~= "" then
					error("Decorated form '" .. decorated_form .. "' has too many asterisks after it, use '*' for syntactic gemination and '**' for optional syntactic gemination")
				end
				--FIXME: Move elsewhere.
				--form = "[[" .. unaccented_form .. "|" .. form .. "]]"
				--if is_finite then
				--	if unaccented_form == "ho" then
				--		form = base.verb.finite_pref_ho .. form
				--	else
				--		form = base.verb.finite_pref .. form
				--	end
				--end
			end
			iut.insert_form(destforms, slot, {form = form, footnotes = qualifiers})
		end
	end
end


local function add_default_verb_forms(base, from_headword)
	local ret = base.verb
	local raw_verb = ret.raw_verb

	if rfind(raw_verb, "r$") then
		if rfind(raw_verb, "[ou]r$") or base.rre then
			ret.verb = raw_verb .. "re"
		else
			ret.verb = raw_verb .. "e"
		end
	else
		ret.verb = raw_verb
	end

	ret.default_stem, ret.default_ending_vowel = rmatch(raw_verb, "^(.-)([aeiour])re?$")
	if not ret.default_stem then
		error("Unrecognized verb '" .. raw_verb .. "', doesn't end in -are, -ere, -ire, -rre, -ar, -er, -ir, -or or -ur")
	end
	base.syncopated = base.rre or not rfind(ret.default_ending_vowel, "^[aei]$")

	local ending_vowel
	if base.explicit_stem_spec then
		local function explicit_stem_special_case(base, form)
			local stem, this_ending_vowel
			if form == "+" then
				stem = ret.default_stem
				this_ending_vowel = ret.default_ending_vowel
				if base.syncopated then
					error("Can't use + with 'stem:' in syncopated verbs; specify an explicit stem")
				end
			else
				base.explicit_non_default_stem_spec = true
				stem, this_ending_vowel = rmatch(form, "^(.*)([aei])$")
				if not stem then
					error("Unrecognized stem '" .. form .. "', should end in -a, -e or -i")
				end
			end
			if ending_vowel and ending_vowel ~= this_ending_vowel then
				error("Can't currently specify explicit stems with two different conjugation vowels (" .. ending_vowel
					.. " and " .. this_ending_vowel .. ")")
			end
			ending_vowel = this_ending_vowel
			return stem
		end
		-- Put the explicit stem in ret.stem (i.e. base.verb.stem).
		process_specs(base, ret, "stem", base.explicit_stem_spec, false, explicit_stem_special_case)
	else
		if base.syncopated then
			if not from_headword then
				error("With syncopated verb '" .. raw_verb .. "', must use 'stem:' to specify an explicit stem")
			else
				ret.default_ending_vowel = "e"
			end
		end
		-- Convert to general list form so we can call iut.map_forms() over it.
		ret.stem = iut.convert_to_general_list_form(ret.default_stem)
		ending_vowel = ret.default_ending_vowel
	end

	base.conj_vowel = ending_vowel == "a" and "à" or ending_vowel == "e" and "é" or "ì"

	if base.syncopated and not base.explicit_stem_spec then
		-- Can't generate defaults for verbs in -rre; currently we only can get here if from_headword.
		return
	end

	ret.unaccented_stem = iut.map_forms(ret.stem, function(stem) return remove_accents(stem) end)
	ret.pres = iut.map_forms(ret.stem, function(stem)
		if base.third then
			return ending_vowel == "a" and stem .. "a" or stem .. "e"
		else
			return stem .. "o"
		end
	end)
	ret.pres3s = iut.map_forms(ret.stem, function(stem) return ending_vowel == "a" and stem .. "a" or stem .. "e" end)
	if ending_vowel == "i" then
		ret.isc_pres = iut.map_forms(ret.unaccented_stem, function(stem) return stem .. "ìsco" end)
		ret.isc_pres3s = iut.map_forms(ret.unaccented_stem, function(stem) return stem .. "ìsci" end)
	end
	ret.phis = iut.flatmap_forms(ret.unaccented_stem, function(stem)
		if ending_vowel == "a" then
			return {stem .. (base.third and "ò" or "ài")}
		elseif ending_vowel == "e" then
			return {stem .. (base.third and "é" or "éi"), stem .. (base.third and "étte" or "étti")}
		else
			return {stem .. (base.third and "ì" or "ìi")}
		end
	end)
	ret.pp = iut.map_forms(ret.unaccented_stem, function(stem)
		if ending_vowel == "a" then
			return stem .. "àto"
		elseif ending_vowel == "e" then
			return rfind(stem, "[cg]$") and stem .. "iùto" or stem .. "ùto"
		else
			return stem .. "ìto"
		end
	end)
end


local function is_single_vowel_spec(spec)
	return rfind(spec, "^" .. AV .. "[+-]?$") or rfind(spec, "^" .. AV .. "%-%-$")
end


-- Given an unaccented stem, pull out the last two vowels as well as the in-between stuff, and return
-- before, v1, between, v2, after as 5 return values. `unaccented` is the full verb and `unaccented_desc`
-- a description of where the verb came from; used only in error messages.
local function analyze_stem_for_last_two_vowels(unaccented_stem, unaccented, unaccented_desc)
	local before, v1, between, v2, after = rmatch(unaccented_stem, "^(.*)(" .. V .. ")(" .. NV .. "*)(" .. V .. ")(" .. NV .. "*)$")
	if not before then
		before, v1 = "", ""
		between, v2, after = rmatch(unaccented_stem, "^(.*)(" .. V .. ")(" .. NV .. "*)$")
	end
	if not between then
		error("No vowel in " .. unaccented_desc .. " '" .. unaccented .. "' to match")
	end
	return before, v1, between, v2, after
end


-- Apply a single-vowel spec in `form`, e.g. é+, to `unaccented_stem`. `unaccented` is the full verb and
-- `unaccented_desc` a description of where the verb came from; used only in error messages.
local function apply_vowel_spec(unaccented_stem, unaccented, unaccented_desc, vowel_spec)
	local function vowel_spec_doesnt_match()
		error("Vowel spec '" .. vowel_spec .. "' doesn't match vowel of " .. unaccented_desc .. " '" .. unaccented .. "'")
	end
	local raw_spec_vowel = usub(unfd(vowel_spec), 1, 1)
	local form
	local spec_vowel = rmatch(vowel_spec, "^(.)%-%-$")
	if spec_vowel then -- a spec like ò--
		local before, v1, between1, v2, between2, v3, after = rmatch(unaccented_stem,
			"^(.*)(" .. V .. ")(" .. NV .. "*)(" .. V .. ")(" .. NV .. "*)(" .. V .. ")(" .. NV .. "*)$")
		if not before then
			error(mw.getContentLanguage():ucfirst(unaccented_desc) .. " '" .. unaccented ..
				"' must have at least three vowels to use the vowel spec '" ..  vowel_spec .. "'")
		end
		if raw_spec_vowel ~= v1 then
			vowel_spec_doesnt_match()
		end
		form = before .. spec_vowel .. between1 .. v2 .. between2 .. v3 .. after
	else
		local before, v1, between, v2, after = analyze_stem_for_last_two_vowels(unaccented_stem, unaccented, unaccented_desc)
		if v1 == v2 then
			local first_second
			spec_vowel, first_second = rmatch(vowel_spec, "^(.)([+-])$")
			if not spec_vowel then
				error("Last two stem vowels of " .. unaccented_desc .. " '" .. unaccented ..
					"' are the same; you must specify + (second vowel) or - (first vowel) after the vowel spec '" ..
					vowel_spec .. "'")
			end
			if raw_spec_vowel ~= v1 then
				vowel_spec_doesnt_match()
			end
			if first_second == "-" then
				form = before .. spec_vowel .. between .. v2 .. after
			else
				form = before .. v1 .. between .. spec_vowel .. after
			end
		else
			if rfind(vowel_spec, "[+-]$") then
				error("Last two stem vowels of " .. unaccented_desc .. " '" .. unaccented ..
					"' are different; specify just an accented vowel, without a following + or -: '" .. vowel_spec .. "'")
			end
			if raw_spec_vowel == v1 then
				form = before .. vowel_spec .. between .. v2 .. after
			elseif raw_spec_vowel == v2 then
				form = before .. v1 .. between .. vowel_spec .. after
			elseif before == "" then
				vowel_spec_doesnt_match()
			else
				error("Vowel spec '" .. vowel_spec .. "' doesn't match either of the last two vowels of " .. unaccented_desc ..
					" '" .. unaccented .. "'")
			end
		end
	end
	return form
end


local function do_ending_stressed_inf(base)
	if rfind(base.verb.verb, "rre$") then
		error("Use \\ not / with -rre verbs")
	end
	-- Add acute accent to -ere, grave accent to -are/-ire.
	local accented = rsub(base.verb.verb, "ere$", "ére")
	accented = unfc(rsub(accented, "([ai])re$", "%1" .. GR .. "re"))
	-- If there is a clitic suffix like -la or -sene, truncate final -e.
	if base.verb.linked_suf ~= "" then
		accented = rsub(accented, "e$", "")
	end
	local linked = "[[" .. base.verb.verb .. "|" .. accented .. "]]" .. base.verb.linked_suf
	iut.insert_form(base.forms, "inf_linked", {form = linked})
end


local function do_root_stressed_inf(base, specs)
	local function root_stressed_inf_special_case(base, form, do_stem, from_defaulted_pres)
		if form == "-" then
			error("Spec '-' not allowed as root-stressed infinitive spec")
		end
		if form == "+" then
			local rre_vowel = rmatch(base.verb.verb, "([aiu])rre$")
			if rre_vowel then
				-- do_root_stressed_inf is used for verbs in -ere and -rre. If the root-stressed vowel isn't explicitly
				-- given and the verb ends in -arre, -irre or -urre, derive it from the infinitive since there's only
				-- one possibility. If the verb ends in -erre or -orre, this won't work because we have both scérre
				-- (= [[scegliere]]) and disvèrre (= [[disvellere]]), as well as pórre and tòrre (= [[togliere]]).
				local before, v1, between, v2, after = analyze_stem_for_last_two_vowels(
					rsub(base.verb.verb, "re$", ""), base.verb.verb, "root-stressed infinitive")
				local vowel_spec = unfc(rre_vowel .. GR)
				if v1 == v2 then
					vowel_spec = vowel_spec .. "+"
				end
				form = vowel_spec
			else
				-- Use the single-vowel spec(s) in the present tense principal part.
				local temp = {}
				process_specs(base, temp, "temp", base.principal_part_specs.pres, false, function(base, form)
					return root_stressed_inf_special_case(base, form, do_stem, "from defaulted pres") end)
				return temp.temp
			end
		end
		local verb_stem, verb_suffix = rmatch(base.verb.verb, "^(.-)([er]re)$")
		if not verb_stem then
			error("Verb '" .. base.verb.verb .. "' must end in -ere or -rre to use \\ notation")
		end
		-- If there is a clitic suffix like -la or -sene, truncate final -(r)e.
		if base.verb.linked_suf ~= "" then
			verb_suffix = verb_suffix == "ere" and "er" or "r"
		end
		if not is_single_vowel_spec(form) then
			if from_defaulted_pres then
				error("When defaulting root-stressed infinitive vowel to present, present spec must be a single-vowel spec, but saw '"
					.. form .. "'")
			else
				error("Explicit root-stressed infinitive spec '" .. form .. "' should be a single-vowel spec")
			end
		end

		local expanded = apply_vowel_spec(verb_stem, base.verb.verb, "root-stressed infinitive", form)
		if do_stem then
			return expanded
		else
			return "[[" .. base.verb.verb .. "|" .. expanded .. verb_suffix .. "]]"
		end
	end

	process_specs(base, base.principal_part_forms, "root_stressed_stem", specs, false, function(base, form)
		return root_stressed_inf_special_case(base, form, "do stem") end)
	process_specs(base, base.forms, "inf_linked", specs, false, function(base, form)
		return root_stressed_inf_special_case(base, form, false) end)
end


local function create_lemma_forms(base)
	-- Do the lemma and lemma_linked forms. When do_root_stressed_inf is called, this also sets
	-- base.principal_part_forms.root_stressed_stem, which is needed by add_present_indic(), so we have to
	-- do this before conjugating the present indicative.
	iut.insert_form(base.forms, "inf", {form = base.lemma})
	-- Add linked version of lemma for use in head=.
	if base.principal_part_specs.root_stressed_inf then
		do_root_stressed_inf(base, base.principal_part_specs.root_stressed_inf)
	else
		do_ending_stressed_inf(base)
	end
end


local function pres_special_case(base, form)
	local principal_part_desc = "first-singular present indicative"
	if form == "+" then
		check_not_null(base, base.verb.pres, form, principal_part_desc)
		return base.verb.pres
	elseif form == "+isc" then
		check_not_null(base, base.verb.isc_pres, form, principal_part_desc)
		return base.verb.isc_pres
	elseif form == "-" then
		return form
	elseif is_single_vowel_spec(form) then
		check_not_null(base, base.verb.pres, form, principal_part_desc)
		return iut.map_forms(base.verb.pres, function(defform)
			local pres, final_vowel = rmatch(defform, "^(.*)([oae])$")
			if not pres then
				error("Internal error: Default present '" .. defform .. "' doesn't end in -o, -a or -e")
			end
			return apply_vowel_spec(pres, defform, "default present", form) .. final_vowel
		end)
	elseif not base.third and not rfind(form, "[oò]$") then
		error("Present first-person singular form '" .. form .. "' should end in -o")
	elseif base.third and not rfind(form, "[aàeè]") then
		error("Present third-person singular form '" .. form .. "' should end in -a or -e")
	else
		local unaccented_form = remove_accents(form)
		if not general_list_form_contains_form(base.verb.pres, unaccented_form, remove_accents)
			and not general_list_form_contains_form(base.verb.isc_pres, unaccented_form, remove_accents) then
			base.is_irreg.pres = true
		end
		return form
	end
end


local function pres3s_special_case(base, form)
	local principal_part_desc = "third-singular present indicative"
	if form == "+" then
		check_not_null(base, base.verb.pres3s, form, principal_part_desc)
		return base.verb.pres3s
	elseif form == "+isc" then
		check_not_null(base, base.verb.isc_pres3s, form, principal_part_desc)
		return base.verb.isc_pres3s
	elseif form == "-" then
		return form
	elseif rfind(form, "^" .. AV .. "[+-]?$") then
		check_not_null(base, base.verb.pres3s, form, principal_part_desc)
		return iut.map_forms(base.verb.pres3s, function(defform)
			local pres3s, final_vowel = rmatch(defform, "^(.*)([ae])$")
			if not pres then
				error("Internal error: Default third-person singular present '" .. defform .. "' doesn't end in -a or -e")
			end
			return apply_vowel_spec(pres3s, defform, "default third-person singular present", form) .. final_vowel
		end)
	elseif not rfind(form, "[aàeè]") then
		error("Present third-person singular form '" .. form .. "' should end in -a or -e")
	else
		local unaccented_form = remove_accents(form)
		if not general_list_form_contains_form(base.verb.pres3s, unaccented_form, remove_accents)
			and not general_list_form_contains_form(base.verb.isc_pres3s, unaccented_form, remove_accents) then
			base.is_irreg.pres = true
		end
		return form
	end
end


-- Generate the present indicative. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
local function add_present_indic(base, prefix)
	process_specs(base, base.principal_part_forms, "pres", base.principal_part_specs.pres, "finite", pres_special_case)
	process_specs(base, base.principal_part_forms, "pres3s", base.principal_part_specs.pres3s, "finite", pres3s_special_case)

	local function addit(pers, stems, endings)
		add(base, prefix .. pers, stems, endings)
	end

	addit("1s", base.principal_part_forms.pres, "")
	local pres1s_stem = iut.map_forms(base.principal_part_forms.pres, function(form)
		if not form:find("o$") then
			error("presrow: must be given in order to generate the present indicative because explicit first-person "
				.. "singular present indicative '" .. form .. "' does not end in -o")
		end
		return rsub(form, "o$", "")
	end)
	addit("3p", pres1s_stem, base.conj_vowel == "à" and "ano" or "ono")
	local pres23s_stem
	if base.principal_part_forms.pres3s then
		pres23s_stem = iut.map_forms(base.principal_part_forms.pres3s, function(form)
			if not form:find("[ae]$") then
				error("presrow: must be given in order to generate the present indicative because explicit third-person "
					.. "singular present indicative '" .. form .. "' does not end in -a or -e")
			end
			return rsub(form, "[ae]$", "")
		end)
	else
		pres23s_form = base.explicit_non_default_stem_spec and base.verb.stem or base.root_stressed_stem or pres1s_stem
	end
	addit("2s", pres23s_stem, "i")
	addit("3s", pres23s_stem, base.conj_vowel == "à" and "a" or "e")
	addit("1p", base.verb.unaccented_stem, "iàmo")
	addit("2p", base.verb.unaccented_stem, base.conj_vowel .. "te")
end


local function generate_present_subj_principal_part(base)
	return iut.map_forms(base.forms.pres1s, function(form)
		if not form:find("o$") then
			error("sub: or subrow: must be given in order to generate the singular present subjunctive "
				.. "because first-person singular present indicative '" .. form .. "' does not end in -o")
		end
		return rsub(form, "o$", base.conj_vowel == "à" and "i" or "a")
	end)
end


-- Generate the present subjunctive. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
local function add_present_subj(base, prefix)
	local function addit(pers, stems, endings)
		add(base, prefix .. pers, stems, endings)
	end
	local function insit(pers, forms)
		insert_forms(base, prefix .. pers, forms)
	end

	-- Generate the 123s and 3p forms.
	addit("123s", base.principal_part_forms.sub, "")
	addit("3p", base.principal_part_forms.sub, "no")
	-- Copy present indicative 1p to present subjunctive.
	copy_forms(base, prefix .. "1p", base.forms.pres1p)
	-- Generate present subjunctive 2p from present indicative 1p by replacing -mo with -te.
	insit("2p", iut.map_forms(base.forms.pres1p, function(form)
		if not form:find("mo$") then
			error("subrow: must be given in order to generate the second-person plural present subjunctive "
				.. "because first-person plural present indicative '" .. form .. "' does not end in -mo")
		end
		return rsub(form, "mo$", "te")
	end))
end


local function generate_imperative_principal_part(base)
	if base.conj_vowel == "à" then
		-- Copy present indicative 3s to imperative 2s.
		return base.forms.pres3s
	else
		-- Copy present indicative 2s to imperative 2s.
		return base.forms.pres2s
	end
end


-- Generate the imperative. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
local function add_imperative(base, rowslot)
	-- FIXME, do we want to do this here or in skip_slot() or elsewhere?
	-- Maybe we don't need skip_slot() and instead have erase_slots() or similar.
	if base.noimp then
		return
	end

	local function copy(pers, forms)
		copy_forms(base, rowslot .. pers, forms)
	end

	-- Copy first imperative form (user specified or taken from present indicative 3s for conj vowel à, or from
	-- present indicative 2s for other conj vowels) to imperative 2s.
	copy("2s", base.principal_part_forms.imp)
	-- Copy present indicative 2p to imperative 2p.
	copy("2p", base.forms.pres2p)
	-- Copy present subjunctive 3s, 1p, 2p to imperative.
	copy("3s", base.forms.sub_3s)
	copy("1p", base.forms.sub_1p)
	copy("2p", base.forms.sub_2p)
end


local function add_negative_imperative(base)
	-- FIXME: needs changes for reflexive verbs
	for _, persnum in ipairs({"2s", "3s", "1p", "2p", "3p"}) do
		local from = persnum == "2s" and "inf" or "imp" .. persnum
		local to = "negimp" .. persnum
		insert_forms(base, to, iut.map_forms(base.forms[from], function(form)
			if base.args.noautolinkverb then
				return "non " .. form
			elseif form:find("%[%[") then
				-- already linked, e.g. when reflexive
				return "[[non]] " .. form
			else
				return "[[non]] [[" .. form .. "]]"
			end
		end))
	end
end


local function generate_past_historic_principal_part(base)
	check_not_null(base, base.verb.phis, "+", "first-singular past historic")
	return base.verb.phis
end


local function add_past_historic(base, prefix)
	for _, form in ipairs(base.principal_part_forms.phis) do
		local function add_phis(pref, s1, s2, s3, p1, p2, p3)
			local newform = {form = pref, footnotes = form.footnotes}
			local function addit(pers, endings)
				add(base, prefix .. pers, newform, endings)
			end
			addit("1s", s1)
			addit("2s", s2)
			addit("3s", s3)
			addit("1p", p1)
			addit("2p", p2)
			addit("3p", p3)
		end
		while true do
			local pref = rmatch(form.form, "^(.*)ài$")
			if pref then
				add_phis(pref, "ài", "àsti", "ò", "àmmo", "àste", "àrono")
				break
			end
			pref = rmatch(form.form, "^(.*)éi$")
			if pref then
				add_phis(pref, "éi", "ésti", "é", "émmo", "éste", "érono")
				break
			end
			pref = rmatch(form.form, "^(.*)[èé]tti$")
			if pref then
				add_phis(pref, {{form = "étti"}, {form = "ètti", footnotes = {"[traditional]"}}},
					"ésti", {{form = "étte"}, {form = "ètte", footnotes = {"[traditional]"}}},
					"émmo", "éste", {{form = "éttero"}, {form = "èttero", footnotes = {"[traditional]"}}})
				break
			end
			pref = rmatch(form.form, "^(.*)ìi$")
			if pref then
				add_phis(pref, "ìi", "ìsti", "ì", "ìmmo", "ìste", "ìrono")
				break
			end
			pref = rmatch(form.form, "^(.*)i$")
			if pref then
				add_phis(pref, "i", {}, "e", {}, {}, "ero")
				add_phis(base.verb.stem, {}, base.conj_vowel .. "sti", {}, base.conj_vowel .. "mmo",
					base.conj_vowel .. "ste", {})
				break
			end
			error("phisrow: must be given in order to generate the past historic because explicit first-person "
				.. "singular past historic '" .. form.form .. "' does not end in -i")
		end
	end
end


local function generate_future_principal_part(base, suffix)
	suffix = suffix or "ò"
	if base.conj_vowel == "à" then
		return iut.map_forms(base.verb.unaccented_stem, function(stem)
			if stem:find("[cg]$") then
				return stem .. "her" .. suffix
			elseif stem:find("[cg]i$") then
				return rsub(stem, "i$", "er") .. suffix
			else
				return stem .. "er" .. suffix
			end
		end)
	else
		return base.verb.verb:gsub("e$", suffix)
	end
end


local function generate_conditional_principal_part(base)
	return generate_future_principal_part(base, "éi")
end


local function generate_past_participle_principal_part(base)
	check_not_null(base, base.verb.pp, "+", "first-singular past historic")
	return base.verb.pp
end


local function generate_gerund_principal_part(base)
	return iut.map_forms(base.verb.unaccented_stem, function(stem)
		return stem .. (base.conj_vowel == "à" and "àndo" or "èndo")
	end)
end


local function generate_present_participle_principal_part(base)
	return iut.map_forms(base.verb.unaccented_stem, function(stem)
		return stem .. (base.conj_vowel == "à" and "ànte" or "ènte")
	end)
end


local full_person_number_list = {"1s", "2s", "3s", "1p", "2p", "3p"}
local imp_person_number_list = {"2s", "3s", "1p", "2p", "3p"}

--[=[
Data on how to conjugate individual rows (i.e. tense/aspect combinations, such as present indicative or
conditional).

The order listed here matters. It determines the order of generating row forms. The order must have
'pres' < 'sub' < 'imp' < 'negimp' because the present subjunctive uses generated forms from the present indicative,
while the imperative uses forms from the present subjunctive and present indicative and the negative imperative
uses forms from the lemma (generated before any rows are conjugated) and the imperative.
]=]
local row_conjugation = {
	{"pres", {
		desc = "present",
		tag_suffix = "pres|ind",
		persnums = full_person_number_list,
		-- No generate_default_principal_part; handled specially in add_present_indic because we actually have
		-- two principal parts for the present indicative ("pres" and "pres3s").
		conjugate = add_present_indic,
		no_explicit_principal_part = true, -- because handled specially in PRES#PRES3S,PHIS,PP spec
	}},
	{"sub", {
		desc = "present subjunctive",
		tag_suffix = "pres|sub",
		persnums = {"123s", "1p", "2p", "3p"},
		generate_default_principal_part = generate_present_subj_principal_part,
		conjugate = add_present_subj,
	}},
	{"imp", {
		desc = "imperative",
		tag_suffix = "imp",
		persnums = imp_person_number_list,
		row_override_persnums = {"2s", "2p"},
		generate_default_principal_part = generate_imperative_principal_part,
		conjugate = add_imperative,
	}},
	{"negimp", {
		desc = "negative imperative",
		tag_suffix = "-",
		persnums = imp_person_number_list,
		-- No generate_default_principal_part because all parts are copied from other parts.
		conjugate = add_negative_imperative,
		no_explicit_principal_part = true, -- because all parts are copied from other parts
		no_row_overrides = true, -- not useful; use single overrides if really needed
	}},
	{"phis", {
		desc = "past historic",
		tag_suffix = "phis",
		persnums = full_person_number_list,
		generate_default_principal_part = generate_past_historic_principal_part,
		conjugate = add_past_historic,
		no_explicit_principal_part = true, -- because handled specially in PRES#PRES3S,PHIS,PP spec
	}},
	{"imperf", {
		desc = "imperfect",
		tag_suffix = "impf|ind",
		persnums = full_person_number_list,
		generate_default_principal_part = function(base) return iut.map_forms(base.verb.unaccented_stem,
			function(stem) return stem .. base.conj_vowel .. "vo" end) end,
		principal_part_desc = "first-person imperfect",
		principal_part_ending = "o",
		conjugate = {"o", "i", "a", "àmo", "àte", "ano"},
	}},
	{"impsub", {
		desc = "imperfect subjunctive",
		tag_suffix = "impf|sub",
		persnums = {"12s", "3s", "1p", "2p", "3p"},
		generate_default_principal_part = function(base) return iut.map_forms(base.verb.unaccented_stem,
			function(stem) return stem .. base.conj_vowel .. "ssi" end) end,
		principal_part_desc = "first/second-person imperfect subjunctive",
		principal_part_ending = "ssi",
		conjugate = {"ssi", "sse", "ssimo", "ste", "ssero"},
	}},
	{"fut", {
		desc = "future",
		tag_suffix = "fut",
		persnums = full_person_number_list,
		generate_default_principal_part = generate_future_principal_part,
		principal_part_desc = "first-person future",
		principal_part_ending = "ò",
		conjugate = {"ò", "ài", "à", "émo", "éte", "ànno"},
	}},
	{"cond", {
		desc = "conditional",
		tag_suffix = "cond",
		persnums = full_person_number_list,
		generate_default_principal_part = generate_conditional_principal_part,
		principal_part_desc = "first-person conditional",
		principal_part_ending = "éi",
		conjugate = {"éi", "ésti", {"èbbe", "ébbe"}, "émmo", "éste", {"èbbero", "ébbero"}},
	}},
	{"pp", {
		desc = "past participle",
		tag_suffix = "past|part",
		persnums = {""},
		generate_default_principal_part = generate_past_participle_principal_part,
		conjugate = function(base) return base.principal_part_forms.pp end,
		no_explicit_principal_part = true, -- because handled specially in PRES#PRES3S,PHIS,PP spec
		no_row_overrides = true, -- useless because there's only one form; use the PRES#PRES3S,PHIS,PP spec
		no_single_overrides = true, --useless because there's only one form; use the PRES#PRES3S,PHIS,PP spec
	}},
	{"ger", {
		desc = "gerund",
		tag_suffix = "ger",
		persnums = {""},
		generate_default_principal_part = generate_gerund_principal_part,
		conjugate = function(base) return base.principal_part_forms.ger end,
		no_row_overrides = true, -- useless because there's only one form; use explicit principal part
		no_single_overrides = true, -- useless because there's only one form; use explicit principal part
	}},
	{"presp", {
		desc = "present participle",
		tag_suffix = "pres|part",
		persnums = {""},
		generate_default_principal_part = generate_present_participle_principal_part,
		conjugate = function(base) return base.principal_part_forms.presp end,
		no_row_overrides = true, -- useless because there's only one form; use explicit principal part
		no_single_overrides = true, -- useless because there's only one form; use explicit principal part
		not_defaulted = true, -- not defaulted, user has to request it explicitly
	}},
}

local row_conjugation_map = {}

for _, spec in ipairs(row_conjugation) do
	local rowslot, rowconj = unpack(spec)
	row_conjugation_map[rowslot] = rowconj
end


local all_verb_slots = {
	{"inf", "inf"},
	{"inf_linked", "inf"},
	-- FIXME, needs to be handled specially
	{"aux", "-"},
}

local overridable_participle_slot_set = {}

local overridable_slot_set = m_table.shallowcopy(overridable_participle_slot_set)

-- Populate all_verb_slots and overridable_slot_set.
for _, spec in ipairs(row_conjugation) do
	local rowslot, rowconj = unpack(spec)
	for _, persnum in ipairs(rowconj.persnums) do
		local persnum_tag = person_number_tag_prefix[persnum]
		local slot = rowslot .. persnum
		if rowconj.tag_suffix == "-" then
			table.insert(all_verb_slots, {slot, "-"})
		else
			table.insert(all_verb_slots, {slot, persnum_tag .. rowconj.tag_suffix})
		end
		if not rowconj.no_single_overrides then
			overridable_slot_set[slot] = true
		end
	end
end

local function handle_row_overrides_for_row(base, row_slot)
	if base.row_override_specs[row_slot] then
		for persnum, specs in pairs(base.row_override_specs[row_slot]) do
			local slot = row_slot .. persnum
			local existing_generated_form = base.forms[slot]
			if not existing_generated_form then
				error("Internal error: Explicit row spec for slot " .. slot .. " being processed and no "
					.. "default-generated forms available")
			end
			local function row_override_special_case(base, form)
				if form == "+" then
					return existing_generated_form
				end
				if not general_list_form_contains_form(existing_generated_form, form) then
					base.is_irreg[row_slot] = true
				end
				return form
			end
			base.forms[slot] = nil -- erase existing form before generating override
			process_specs(base, base.forms, slot, specs, "finite", row_override_special_case)
		end
	end
end


local function handle_single_overrides_for_row(base, row_slot)
	local rowspec = row_conjugation_map[row_slot]
	if not rowspec then
		error("Internal error: No row conjugation spec for " .. row_slot)
	end

	for _, persnum in ipairs(rowspec.persnums) do
		local slot = row_slot .. persnum
		if base.single_override_specs[slot] then
			local existing_generated_form = base.forms[slot]
			if not existing_generated_form then
				error("Internal error: Explicit override spec for slot " .. slot .. " being processed and no "
					.. "default-generated forms available")
			end
			local function override_special_case(base, form)
				if form == "+" then
					return existing_generated_form
				end
				if not general_list_form_contains_form(existing_generated_form, form) then
					base.is_irreg[row_slot] = true
				end
				return form
			end
			base.forms[slot] = nil -- erase existing form before generating override
			process_specs(base, base.forms, slot, base.single_override_specs[slot], "finite", override_special_case)
		end
	end
end


local function conjugate_row(base, rowslot)
	local rowconj = row_conjugation_map[rowslot]
	if not rowconj then
		error("Internal error: Unrecognized row slot '" .. rowslot .. "'")
	end

	-- Generate the principal part for this row now if it has an entry for `generate_default_principal_part`.
	if rowconj.generate_default_principal_part then
		local function principal_part_special_case(base, form)
			-- process_specs() calls convert_to_general_list_form() on the output in any case and we need it in this form
			-- in order to call general_list_form_contains_form(), so we may as well convert it now.
			local default_principal_part = iut.convert_to_general_list_form(rowconj.generate_default_principal_part(base))
			if form == "+" then
				return default_principal_part
			end
			if not general_list_form_contains_form(default_principal_part, form) then
				base.is_irreg[rowslot] = true
			end
			return form
		end

		local principal_part_specs = base.principal_part_specs[rowslot] or rowconj.not_defaulted and {{form = "-"}}
			or {{form = "+"}}
		process_specs(base, base.principal_part_forms, rowslot, specs, rowslot ~= "imp", principal_part_special_case)
	end

	if type(rowconj.conjugate) == "table" then
		if #rowconj.conjugate ~= #rowconj.persnums then
			error("Internal error: Expected " .. #rowconj.persnums .. " elements for row slot '" .. rowslot
				.. ", but saw " .. #rowconj.conjugate)
		end
		local stem = iut.map_forms(base.principal_part_forms[rowslot], function(form)
			if not rfind(form, rowconj.principal_part_ending .. "$") then
				error(rowslot .. "row: must be given in order to generate the " .. rowconj.desc .. " because"
					.. "explicit " .. rowconj.principal_part_desc .. " '" .. form .. "' does not end in -"
					.. rowconj.principal_part_ending)
			end
			return rsub(form, rowconj.principal_part_ending .. "$", "")
		end)
		for _, persnum in ipairs(rowconj.persnums) do
			add(base, rowslot .. persnum, stem, rowconj.conjugate[persnum])
		end
	else
		rowconj.conjugate(base, rowslot)
	end

	handle_row_overrides_for_row(base, rowslot)
	handle_single_overrides_for_row(base, rowslot)
end


-- Add the clitic pronouns in `pronouns` to the forms in `base_slot`. If `do_combined_slots` is given,
-- store the results into the appropriate combined slots, e.g. `imp_2s_comb_lo` for second singular imperative + lo.
-- Otherwise, directly modify `base_slot`. The latter case is used for handling reflexive verbs, and in that case
-- `pronouns` should contain only a single pronoun.
local function add_forms_with_clitic(base, base_slot, pronouns, do_combined_slots)
	if not base.forms[base_slot] then
		-- This can happen, e.g. in only3s/only3sp verbs.
		return
	end
	for _, form in ipairs(base.forms[base_slot]) do
		-- Figure out that correct accenting of the verb when a clitic pronoun is attached to it. We may need to
		-- add or remove an accent mark:
		-- (1) No accent mark currently, none needed: infinitive sentar because of sentarlo; imperative singular
		--     ten because of tenlo;
		-- (2) Accent mark currently, still needed: infinitive oír because of oírlo;
		-- (3) No accent mark currently, accent needed: imperative singular siente -> siénte because of siéntelo;
		-- (4) Accent mark currently, not needed: imperative singular está -> estálo, sé -> selo.
		local syllables = com.syllabify(form.form)
		local sylno = com.stressed_syllable(syllables)
		table.insert(syllables, "lo")
		local needs_accent = com.accent_needed(syllables, sylno)
		if needs_accent then
			syllables[sylno] = com.add_accent_to_syllable(syllables[sylno])
		else
			syllables[sylno] = com.remove_accent_from_syllable(syllables[sylno])
		end
		table.remove(syllables) -- remove added clitic pronoun
		local reaccented_verb = table.concat(syllables)
		for _, pronoun in ipairs(pronouns) do
			local cliticized_verb
			-- Some further special cases.
			if base_slot == "imp_1p" and (pronoun == "nos" or pronoun == "os") then
				-- Final -s disappears: sintamos + nos -> sintámonos, sintamos + os -> sintámoos
				cliticized_verb = reaccented_verb:gsub("s$", "") .. pronoun
			elseif base_slot == "imp_2p" and pronoun == "os" then
				-- Final -d disappears, which may cause an accent to be required:
				-- haced + os -> haceos, sentid + os -> sentíos
				if reaccented_verb:find("id$") then
					cliticized_verb = reaccented_verb:gsub("id$", "íos")
				else
					cliticized_verb = reaccented_verb:gsub("d$", "os")
				end
			else
				cliticized_verb = reaccented_verb .. pronoun
			end
			if do_combined_slots then
				insert_form(base, base_slot .. "_comb_" .. pronoun,
					{form = cliticized_verb, footnotes = form.footnotes})
			else
				form.form = cliticized_verb
			end
		end
	end
end


-- Generate the combinations of verb form (infinitive, gerund or various imperatives) + clitic pronoun.
local function add_combined_forms(base)
	for _, base_slot_and_pronouns in ipairs(verb_slot_combined_rows) do
		local base_slot, pronouns = unpack(base_slot_and_pronouns)
		-- Skip non-infinitive/gerund combinations for reflexive verbs. We will copy the appropriate imperative
		-- combinations later.
		if not base.refl or base_slot == "inf" or base_slot == "ger" then
			add_forms_with_clitic(base, base_slot, pronouns, "do combined slots")
		end
	end
end


-- Add a reflexive pronoun or fixed clitic, e.g. [[lo]], as appropriate to the base form that were generated.
-- `do_joined` means to do only the forms where the pronoun is joined to the end of the form; otherwise, do only the
-- forms where it is not joined and precedes the form.
local function add_reflexive_or_fixed_clitic_to_forms(base, do_reflexive, do_joined)
	for _, slotaccel in ipairs(all_verb_slots) do
		local slot, accel = unpack(slotaccel)
		local clitic
		if not do_reflexive then
			clitic = base.clitic
		elseif slot:find("[123]") then
			local persnum = slot:match("^.*([123][sp])$")
			clitic = person_number_to_reflexive_pronoun[persnum]
		else
			clitic = "si"
		end
		if base.forms[slot] then
			if slot == "inf" or slot == "ger" or slot:find("^imp[123]") then
				if do_joined then
					add_forms_with_clitic(base, slot, {clitic})
				end
			elseif do_reflexive and slot == "pp" or slot == "inf_linked" then
				-- do nothing with reflexive past participles or with infinitive linked (handled at the end)
			elseif slot:find("^negimp") then
				error("Internal error: Should not have forms set for negative imperative at this stage")
			elseif not do_joined then
				-- Add clitic as separate word before all other forms. Check whether form already has brackets
				-- (as will be the case if the form has a fixed clitic).
				for _, form in ipairs(base.forms[slot]) do
					if base.args.noautolinkverb then
						form.form = clitic .. " " .. form.form
					else
						local clitic_pref = "[[" .. clitic .. "]] "
						if form.form:find("%[%[") then
							form.form = clitic_pref .. form.form
						else
							form.form = clitic_pref .. "[[" .. form.form .. "]]"
						end
					end
				end
			end
		end
	end
end


local function copy_imperatives_to_reflexive_combined_forms(base)
	local copy_table = {
		{"imp_2s", "imp_2s_comb_te"},
		{"imp_3s", "imp_3s_comb_se"},
		{"imp_1p", "imp_1p_comb_nos"},
		{"imp_2p", "imp_2p_comb_os"},
		{"imp_3p", "imp_3p_comb_se"},
	}

	-- Copy imperatives (with the clitic reflexive pronoun already added) to the appropriate "combined" reflexive
	-- forms.
	for _, entry in ipairs(copy_table) do
		local from, to = unpack(entry)
		-- Need to call map_forms() to clone the form objects because insert_forms() doesn't clone them, and may
		-- side-effect them when inserting footnotes.
		insert_forms(base, to, iut.map_forms(base.forms[from], function(form) return form end))
	end
end


local function add_missing_links_to_forms(base)
	-- Any forms without links should get them now. Redundant ones will be stripped later.
	for slot, forms in pairs(base.forms) do
		for _, form in ipairs(forms) do
			if not form.form:find("%[%[") then
				form.form = "[[" .. form.form .. "]]"
			end
		end
	end
end


local function conjugate_verb(base)
	add_default_verb_forms(base)
	create_lemma_forms(base)
	for _, rowspec in ipairs(row_conjugation) do
		local rowslot, rowconj = unpack(rowspec)
		conjugate_row(base, rowslot)
	end
	-- This should happen before add_combined_forms() so overrides of basic forms end up part of the combined forms.
	-- This should happen after process_slot_overrides() in case a derived slot is based on an override (as with the
	-- imp_3s of [[dar]], [[estar]]).
	-- copy_subjunctives_to_imperatives(base)
	-- We need to add joined reflexives, then joined and non-joined clitics, then non-joined reflexives, so we get
	-- [[házmelo]] but [[no]] [[me]] [[lo]] [[haga]].
	if base.refl then
		add_reflexive_or_fixed_clitic_to_forms(base, "do reflexive", "do joined")
		process_slot_overrides(base, "do basic", "do reflexive") -- do reflexive-only basic slot overrides
	end
	if base.clitic then
		-- This should happen after reflexives are added.
		add_reflexive_or_fixed_clitic_to_forms(base, false, "do joined")
		add_reflexive_or_fixed_clitic_to_forms(base, false, false)
	end
	if base.refl then
		add_reflexive_or_fixed_clitic_to_forms(base, "do reflexive", false)
	end
	-- This should happen after add_reflexive_or_fixed_clitic_to_forms() so negative imperatives get the reflexive pronoun
	-- and clitic in them.
	-- generate_negative_imperatives(base)
	if not base.args.noautolinkverb then
		add_missing_links_to_forms(base)
	end
end


local function analyze_verb(lemma)
	local is_pronominal = false
	local is_reflexive = false
	-- The particles that can go after a verb are:
	-- * la, le
	-- * ne
	-- * ci, vi (sometimes in the form ce, ve)
	-- * si (sometimes in the form se)
	-- Observed combinations:
	--   * ce + la: [[avercela]] "to be angry (at someone)", [[farcela]] "to make it, to succeed",
	--              [[mettercela tutta]] "to put everything (into something)"
	--   * se + la: [[sbrigarsela]] "to deal with", [[bersela]] "to naively believe in",
	--              [[sentirsela]] "to have the courage to face (a difficult situation)",
	--              [[spassarsela]] "to live it up", [[svignarsela]] "to scurry away",
	--              [[squagliarsela]] "to vamoose, to clear off", [[cercarsela]] "to be looking for (trouble etc.)",
	--              [[contarsela]] "to have a distortedly positive self-image; to chat at length",
	--              [[dormirsela]] "to be fast asleep", [[filarsela]] "to slip away, to scram",
	--              [[giostrarsela]] "to get away with; to turn a situation to one's advantage",
	--              [[cavarsela]] "to get away with; to get out of (trouble); to make the best of; to manage (to do); to be good at",
	--              [[meritarsela]] "to get one's comeuppance", [[passarsela]] "to fare (well, badly)",
	--              [[rifarsela]] "to take revenge", [[sbirbarsela]] "to slide by (in life)",
	--              [[farsela]]/[[intendersela]] "to have a secret affair or relationship with",
	--              [[farsela addosso]] "to shit oneself", [[prendersela]] "to take offense at; to blame",
	--              [[prendersela comoda]] "to take one's time", [[sbrigarsela]] "to finish up; to get out of (a difficult situation)",
	--              [[tirarsela]] "to lord it over", [[godersela]] "to enjoy", [[vedersela]] "to see (something) through",
	--              [[vedersela brutta]] "to have a hard time with; to be in a bad situation",
	--              [[aversela]] "to pick on (someone)", [[battersela]] "to run away, to sneak away",
	--              [[darsela a gambe]] "to run away", [[fumarsela]] "to sneak away",
	--              [[giocarsela]] "to behave (a certain way); to strategize; to play"
	--   * se + ne: [[andarsene]] "to take leave", [[approfittarsene]] "to take advantage of",
	--              [[fottersene]]/[[strafottersene]] "to not give a fuck",
	--              [[fregarsene]]/[[strafregarsene]] "to not give a damn",
	--              [[guardarsene]] "to beware; to think twice", [[impiparsene]] "to not give a damn",
	--              [[morirsene]] "to fade away; to die a lingering death", [[ridersene]] "to laugh at; to not give a damn",
	--              [[ritornarsene]] "to return to", [[sbattersene]]/[[strabattersene]] "to not give a damn",
	--              [[infischiarsene]] "to not give a damn", [[stropicciarsene]] "to not give a damn",
	--              [[sbarazzarsene]] "to get rid of, to bump off", [[andarsene in acqua]] "to be diluted; to decay",
	--              [[nutrirsene]] "to feed oneself", [[curarsene]] "to take care of",
	--              [[intendersene]] "to be an expert (in)", [[tornarsene]] "to return, to go back",
	--              [[starsene]] "to stay", [[farsene]] "to matter; to (not) consider; to use",
	--              [[farsene una ragione]] "to resign; to give up; to come to terms with; to settle (a dispute)",
	--              [[riuscirsene]] "to repeat (something annoying)", [[venirsene]] "to arrive slowly; to leave"
	--   * ci + si: [[trovarcisi]] "to find oneself in a happy situation",
	--              [[vedercisi]] "to imagine oneself (in a situation)", [[sentircisi]] "to feel at ease"
	--   * vi + si: [[recarvisi]] "to go there"
	--
	local ret = {}
	local linked_suf, finite_pref, finite_pref_ho
	local clitic_to_finite = {ce = "ce", ve = "ve", se = "me"}
	local verb, clitic, clitic2 = rmatch(lemma, "^(.-)([cvs]e)(l[ae])$")
	if verb then
		linked_suf = "[[" .. clitic .. "]][[" .. clitic2 .. "]]"
		finite_pref = "[[" .. clitic_to_finite[clitic] .. "]] [[" .. clitic2 .. "]] "
		finite_pref_ho = "[[" .. clitic_to_finite[clitic] .. "]] [[l']]"
		is_pronominal = true
		is_reflexive = clitic == "se"
	end
	if not verb then
		verb, clitic = rmatch(lemma, "^(.-)([cvs]e)ne$")
		if verb then
			linked_suf = "[[" .. clitic .. "]][[ne]]"
			finite_pref = "[[" .. clitic_to_finite[clitic] .. "]] [[ne]] "
			finite_pref_ho = "[[" .. clitic_to_finite[clitic] .. "]] [[n']]"
			is_pronominal = true
			is_reflexive = clitic == "se"
		end
	end
	if not verb then
		verb, clitic = rmatch(lemma, "^(.-)([cv]i)si$")
		if verb then
			linked_suf = "[[" .. clitic .. "]][[si]]"
			finite_pref = "[[mi]] [[" .. clitic .. "]] "
			if clitic == "vi" then
				finite_pref_ho = "[[mi]] [[v']]"
			else
				finite_pref_ho = "[[mi]] [[ci]] "
			end
			is_pronominal = true
			is_reflexive = true
		end
	end
	if not verb then
		verb, clitic = rmatch(lemma, "^(.-)([cv]i)$")
		if verb then
			linked_suf = "[[" .. clitic .. "]]"
			finite_pref = "[[" .. clitic .. "]] "
			if clitic == "vi" then
				finite_pref_ho = "[[v']]"
			else
				finite_pref_ho = "[[ci]] "
			end
			is_pronominal = true
		end
	end
	if not verb then
		verb = rmatch(lemma, "^(.-)si$")
		if verb then
			linked_suf = "[[si]]"
			finite_pref = "[[mi]] "
			finite_pref_ho = "[[m']]"
			-- not pronominal
			is_reflexive = true
		end
	end
	if not verb then
		verb = rmatch(lemma, "^(.-)ne$")
		if verb then
			linked_suf = "[[ne]]"
			finite_pref = "[[ne]] "
			finite_pref_ho = "[[n']]"
			is_pronominal = true
		end
	end
	if not verb then
		verb, clitic = rmatch(lemma, "^(.-)(l[ae])$")
		if verb then
			linked_suf = "[[" .. clitic .. "]]"
			finite_pref = "[[" .. clitic .. "]] "
			finite_pref_ho = "[[l']]"
			is_pronominal = true
		end
	end
	if not verb then
		verb = lemma
		linked_suf = ""
		finite_pref = ""
		finite_pref_ho = ""
		-- not pronominal
	end

	ret.raw_verb = verb
	ret.linked_suf = linked_suf
	ret.finite_pref = finite_pref
	ret.finite_pref_ho = finite_pref_ho
	ret.is_pronominal = is_pronominal
	ret.is_reflexive = is_reflexive
	return ret
end


local function parse_indicator_spec(angle_bracket_spec, lemma, pagename)
	-- `forms` contains the final per-slot forms. This is processed further in [[Module:inflection-utilities]].
	--    This is a table indexed by slot (e.g. "pres1s"). Each value in the table is a list of items of the form
	--    {form = FORM, footnotes = FOOTNOTES} where FORM is the actual generated form and FOOTNOTES is either nil
	--    or a list of footnotes (which must be surrounded by brackets, e.g. "[archaic]").
	-- `principal_part_specs` contains forms specified by the user using either the prefixes 'imperf:', 'fut:', 'sub:',
	--    'impsub:' or 'imp:' or in the format e.g. "vèngo:vègno[archaic or poetic]#viène,vénni,venùto" or "é:#è".
	--    The key is the prefix ("imperf", "fut", etc., for the former format) or "pres", "pres3s", "phis" or "pp"
	--    (for the latter format). The value is in the same form as for `forms` and `genforms`, but the FORM contained
	--    in it is the actual user-specified form, which may be e.g. "#è" rather than a verb form, and needs to
	--    be processed to generate the actual form. A spec may be "+" to insert the default-generated form or forms,
	--    or "-" to indicate that this form doesn't exist.
	-- `principal_part_forms` contains the processed versions of the specs contained in `principal_part_specs`. The keys are as
	--    in `principal_part_specs` and the values are the same as for `forms` and `genforms`.
	-- `row_override_specs` contains user-specified forms for a full tense/aspect row using 'presrow:', 'subrow:', etc.
	--    The key is "pres", "sub", etc. (i.e. minus the "row" suffix). The value is another table indexed by the
	--    person/number suffix (e.g. "1s", "2s", etc. for "pres"; "123s", "1p", "2p", etc. for "sub"), whose values
	--    are in the same format as `principal_part_specs`.
	-- `single_override_specs` contains user-specified forms using 'pres1s:', 'sub3p:', etc. The key is the slot ("pres1s",
	--    "sub3p", etc.) and the value is of the same format as `principal_part_specs`.
	-- `is_irreg` is a table indexed by the row suffix ("pres", "sub", etc.) whose value is true or false indicating whether
	--    a given row is irregular.
	local base = {forms = {}, principal_part_specs = {}, principal_part_forms = {}, row_override_specs = {},
		single_override_specs = {}, is_irreg = {}}
	local function parse_err(msg)
		error(msg .. ": " .. angle_bracket_spec)
	end

	local function parse_qualifiers(separated_group)
		local qualifiers
		for j = 2, #separated_group - 1, 2 do
			if separated_group[j + 1] ~= "" then
				parse_err("Extraneous text after bracketed qualifiers: '" .. table.concat(separated_group) .. "'")
			end
			if not qualifiers then
				qualifiers = {}
			end
			table.insert(qualifiers, separated_group[j])
		end
		return qualifiers
	end

	local function fetch_specs(comma_separated_group, allow_blank)
		local colon_separated_groups = iut.split_alternating_runs(comma_separated_group, ":")
		if allow_blank and #colon_separated_groups == 1 and #colon_separated_groups[1] == 1 and
			colon_separated_groups[1][1] == "" then
			return nil
		end
		local specs = {}
		for _, colon_separated_group in ipairs(colon_separated_groups) do
			local form = colon_separated_group[1]
			if form == "" then
				parse_err("Blank form not allowed here, but saw '" ..
					table.concat(comma_separated_group) .. "'")
			end
			local new_spec = {form = form, footnotes = parse_qualifiers(colon_separated_group)}
			for _, existing_spec in ipairs(specs) do
				if m_table.deepEquals(existing_spec, new_spec) then
					parse_err("Duplicate spec '" .. table.concat(colon_separated_group) .. "'")
				end
			end
			table.insert(specs, new_spec)
		end
		return specs
	end

	if lemma == "" then
		lemma = pagename
	end
	base.lemma = m_links.remove_links(lemma)
	base.verb = analyze_verb(lemma)

	local inside = angle_bracket_spec:match("^<(.*)>$")
	assert(inside)

	local segments = iut.parse_balanced_segment_run(inside, "[", "]")
	local dot_separated_groups = iut.split_alternating_runs(segments, "%s*%.%s*")
	for i, dot_separated_group in ipairs(dot_separated_groups) do
		local first_element = dot_separated_group[1]

		if i == 1 then -- first dot-separated group is PRES,PHIS,PP or PRES#PRES3S,PHIS,PP or similar.
			local comma_separated_groups = iut.split_alternating_runs(dot_separated_group, "%s*[,\\/]%s*", "preserve splitchar")
			local presind = 1
			local first_separator = #comma_separated_groups > 1 and
				strip_spaces(comma_separated_groups[2][1])
			if base.verb.is_reflexive then
				if #comma_separated_groups > 1 and first_separator ~= "," then
					presind = 3
					-- Fetch root-stressed infinitive, if given.
					local specs = fetch_specs(comma_separated_groups[1], "allow blank")
					if first_separator == "\\" then
						-- For verbs like [[scegliersi]] and [[proporsi]], allow either 'é\scélgo' or '\é\scélgo'
						-- and similarly either 'ó+\propóngo' or '\ó+\propóngo'.
						if specs == nil then
							if #comma_separated_groups > 3 and strip_spaces(comma_separated_groups[4][1]) == "\\" then
								base.principal_part_specs.root_stressed_inf = fetch_specs(comma_separated_groups[3])
								presind = 5
							else
								base.principal_part_specs.root_stressed_inf = {{form = "+"}}
							end
						else
							base.principal_part_specs.root_stressed_inf = specs
						end
					elseif specs ~= nil then
						parse_err("With reflexive verb, can't specify anything before initial slash, but saw '"
							.. table.concat(comma_separated_groups[1]))
					end
				end
				base.forms.aux = {{form = "essere"}}
			else -- non-reflexive
				if #comma_separated_groups == 1 or first_separator == "," then
					parse_err("With non-reflexive verb, use a spec like AUX/PRES, AUX\\PRES, AUX/PRES,PAST,PP or similar")
				end
				presind = 3
				-- Fetch auxiliary or auxiliaries.
				local colon_separated_groups = iut.split_alternating_runs(comma_separated_groups[1], ":")
				for _, colon_separated_group in ipairs(colon_separated_groups) do
					local aux = colon_separated_group[1]
					if aux == "a" then
						aux = "avere"
					elseif aux == "e" then
						aux = "essere"
					elseif aux == "-" then
						if #colon_separated_group > 1 then
							parse_err("No footnotes allowed with '-' spec for auxiliary")
						end
						aux = nil
					else
						parse_err("Unrecognized auxiliary '" .. aux ..
							"', should be 'a' (for [[avere]]), 'e' (for [[essere]]), or '-' if no past participle")
					end
					if aux then
						if base.forms.aux then
							for _, existing_aux in ipairs(base.forms.aux) do
								if existing_aux.form == aux then
									parse_err("Auxiliary '" .. aux .. "' specified twice")
								end
							end
						else
							base.forms.aux = {}
						end
						table.insert(base.forms.aux, {form = aux, footnotes = parse_qualifiers(colon_separated_group)})
					end
				end

				-- Fetch root-stressed infinitive, if given.
				if first_separator == "\\" then
					if #comma_separated_groups > 3 and strip_spaces(comma_separated_groups[4][1]) == "\\" then
						base.principal_part_specs.root_stressed_inf = fetch_specs(comma_separated_groups[3])
						presind = 5
					else
						base.principal_part_specs.root_stressed_inf = {{form = "+"}}
					end
				end
			end

			-- Parse present
			local hash_separated_groups = iut.split_alternating_runs(comma_separated_groups[presind], "%s*#%s*")
			if #hash_separated_groups > 2 then
				parse_err("At most one hash sign (#) can appear in present tense specs")
			end
			base.principal_part_specs.pres = fetch_specs(hash_separated_groups[1])
			if #hash_separated_groups == 2 then
				base.principal_part_specs.pres3s = fetch_specs(hash_separated_groups[2])
			end

			-- Parse past historic
			if #comma_separated_groups > presind then
				if strip_spaces(comma_separated_groups[presind + 1][1]) ~= "," then
					parse_err("Use a comma not slash to separate present from past historic")
				end
				base.principal_part_specs.phis = fetch_specs(comma_separated_groups[presind + 2])
			end

			-- Parse past participle
			if #comma_separated_groups > presind + 2 then
				if strip_spaces(comma_separated_groups[presind + 3][1]) ~= "," then
					parse_err("Use a comma not slash to separate past historic from past participle")
				end
				base.principal_part_specs.pp = fetch_specs(comma_separated_groups[presind + 4])
			end

			if #comma_separated_groups > presind + 4 then
				parse_err("Extraneous text after past participle")
			end
		elseif first_element == "only3s" or first_element == "only3sp" or first_element == "rre" then
			if #dot_separated_group > 1 then
				parse_err("No footnotes allowed with '" .. first_element .. "' spec")
			end
			base[first_element] = true
		else
			local first_element_prefix, first_element_minus_prefix = rmatch(first_element,
				"^%s*([a-z0-9_]+)%s*:%s*(.-)%s*$")
			if not first_element_prefix then
				parse_err("Dot-separated element should be either 'only3s', 'only3p', 'rre' or be of the form "
					.. "'PREFIX:SPEC', but saw '" .. table.concat(dot_separated_group) .. "'")
			end
			dot_separated_group[1] = first_element_minus_prefix
			if first_element_prefix == "stem" then
				base.explicit_stem_spec = fetch_specs(dot_separated_group)
			elseif row_conjugation_map[first_element_prefix] then
				if row_conjugation_map[first_element_prefix].no_explicit_principal_part then
					parse_err("Can't specify principal part for " .. row_conjugation_map[first_element_prefix].desc
						.. " using '" .. first_element_prefix .. ":'; use the specification PRES#PRES3S.PHIS.PP")
				else
					base.principal_part_specs[first_element_prefix] = fetch_specs(dot_separated_group)
				end
			elseif overridable_slot_set[first_element_prefix] then
				base.single_override_specs[first_element_prefix] = fetch_specs(dot_separated_group)
			elseif first_element_prefix:find("row$") then
				local row_override_slot = rmatch(first_element_prefix, "^(.*)row$")
				if row_conjugation_map[row_override_slot] then
					local rowspec = row_conjugation_map[row_override_slot]
					if rowspec.no_row_overrides then
						-- This happens with e.g. pp and negimp. Doesn't make sense with pp because it's a single form
						-- that can be specified completely using the explicit principal part. Rarely if ever useful
						-- for negimp; use single overrides if absolutely necessary.
						parse_err("Can't specify row override for " .. rowspec.desc .. " using " .. row_override_slot
							.. "row:; use an explicit principal part or single overrides (if allowed)")
					end
					local comma_separated_groups = iut.split_alternating_runs(dot_separated_group, "%s*,%s*")
					local persnums = rowspec.row_override_persnums or rowspec.persnums
					if #comma_separated_groups ~= #persnums then
						parse_err("For " .. row_override_slot .. "row:, expected " .. #persnums
							.. " forms but saw " .. #comma_separated_groups .. " in '"
							.. table.concat(dot_separated_group) .. "'")
					end
					base.row_override_specs[row_override_slot] = {}
					for i, persnum in ipairs(persnums) do
						base.row_override_specs[row_override_slot][persnum] = fetch_specs(comma_separated_group[i])
					end
				else
					local row_override_slots = {}
					for row_override_slot, _ in pairs(row_conjugation_map) do
						table.insert(row_override_slots, row_override_slot .. "row:")
					end
					table.sort(row_override_slots)
					parse_err("Row override spec should begin with one of " .. m_table.serialCommaJoin(row_override_slots)
						.. ", but saw '" .. table.concat(dot_separated_group) .. "'")
				end
			else
				parse_err("Unrecognized prefix '" .. first_element_prefix .. "' in '"
					.. table.concat(dot_separated_group) .. "'")
			end
		end
	end
	return base
end


-- Normalize all lemmas, substituting the pagename for blank lemmas and adding links to multiword lemmas.
local function normalize_all_lemmas(alternant_multiword_spec)

	-- (1) Add links to all before and after text.
	if not alternant_multiword_spec.args.noautolinktext then
		alternant_multiword_spec.post_text = add_links(alternant_multiword_spec.post_text)
		for _, alternant_or_word_spec in ipairs(alternant_multiword_spec.alternant_or_word_specs) do
			alternant_or_word_spec.before_text = add_links(alternant_or_word_spec.before_text)
			if alternant_or_word_spec.alternants then
				for _, multiword_spec in ipairs(alternant_or_word_spec.alternants) do
					multiword_spec.post_text = add_links(multiword_spec.post_text)
					for _, word_spec in ipairs(multiword_spec.word_specs) do
						word_spec.before_text = add_links(word_spec.before_text)
					end
				end
			end
		end
	end

	-- (2) Remove any links from the lemma, but remember the original form
	--     so we can use it below in the 'lemma_linked' form.
	iut.map_word_specs(alternant_multiword_spec, function(base)
		base.user_specified_lemma = base.lemma
		base.lemma = m_links.remove_links(base.lemma)
	end)
end


local function detect_indicator_spec(base)
	if base.only3s and base.only3sp then
		error("'only3s' and 'only3sp' cannot both be specified")
	end
end


local function detect_all_indicator_specs(alternant_multiword_spec, from_headword)
	-- Propagate some settings up or down.
	iut.map_word_specs(alternant_multiword_spec, function(base)
		if base.is_pronominal then
			alternant_multiword_spec.is_pronominal = true
		end
		-- FIXME, old Spanish stuff
		if base.refl then
			alternant_multiword_spec.refl = true
		end
		if base.clitic then
			alternant_multiword_spec.clitic = true
		end
		base.from_headword = from_headword
		base.args = alternant_multiword_spec.args
	end)

	iut.map_word_specs(alternant_multiword_spec, function(base)
		detect_indicator_spec(base)
	end)
end


local function add_categories_and_annotation(alternant_multiword_spec, base, multiword_lemma, from_headword)
	local function insert_ann(anntype, value)
		m_table.insertIfNot(alternant_multiword_spec.annotation[anntype], value)
	end

	local function insert_cat(cat, also_when_multiword)
		-- Don't place multiword terms in categories like 'Italian verbs ending in -are' to avoid spamming the
		-- categories with such terms.
		if also_when_multiword or not multiword_lemma then
			m_table.insertIfNot(alternant_multiword_spec.categories, "Italian " .. cat)
		end
	end

	if check_for_red_links and not from_headword and not multiword_lemma then
		for _, slot_and_accel in ipairs(all_verb_slots) do
			local slot = slot_and_accel[1]
			local forms = base.forms[slot]
			local must_break = false
			if forms then
				for _, form in ipairs(forms) do
					if not form.form:find("%[%[") then
						local title = mw.title.new(form.form)
						if title and not title.exists then
							insert_cat("verbs with red links in their inflection tables")
							must_break = true
						break
						end
					end
				end
			end
			if must_break then
				break
			end
		end
	end

	if base.syncopated then
		insert_ann("conj", "syncopated")
		insert_cat("syncopated verbs")
	elseif base.principal_part_specs.root_stressed_inf then
		insert_ann("conj", "root-stressed -ere")
		insert_cat("root-stressed verbs")
		insert_cat("verbs ending in -ere")
	else
		local ending = base.conj_vowel == "à" and "are" or base.conj_vowel == "é" and "ere" or "ire"
		insert_ann("conj", ending)
		insert_cat("verbs ending in -" .. ending)
	end

	local is_irreg = false
	for _, rowspec in ipairs(row_conjugation) do
		local rowslot, rowconj = unpack(rowspec)
		if base.is_irreg[rowslot] then
			if not is_irreg then
				is_irreg = true
				insert_cat("irregular verbs")
			end
			insert_cat("verbs with irregular " .. rowconj.desc)
		end 
	end
	if is_irreg then
		insert_ann("irreg", "irregular")
	else
		insert_ann("irreg", "regular")
	end

	if base.only3s then
		insert_ann("defective", "impersonal")
		insert_cat("impersonal verbs")
	elseif base.only3sp then
		insert_ann("defective", "third-person only")
		insert_cat("third-person-only verbs")
	else
		insert_ann("defective", "regular")
	end

	if not base.refl then
		for _, auxform in ipairs(base.forms.aux) do
			insert_ann("aux", auxform.form)
			insert_cat("verbs taking " .. auxform.form .. " as auxiliary")
		end
	end

	if base.clitic then
		insert_cat("verbs with lexical clitics")
	end

	if base.refl then
		insert_cat("reflexive verbs")
	end
end


-- Compute the categories to add the verb to, as well as the annotation to display in the
-- conjugation title bar. We combine the code to do these functions as both categories and
-- title bar contain similar information.
local function compute_categories_and_annotation(alternant_multiword_spec, from_headword)
	alternant_multiword_spec.categories = {}
	local ann = {}
	alternant_multiword_spec.annotation = ann
	ann.conj = {}
	ann.irreg = {}
	ann.defective = {}
	ann.aux = {}

	local multiword_lemma = false
	for _, form in ipairs(alternant_multiword_spec.forms.inf) do
		if form.form:find(" ") then
			multiword_lemma = true
			break
		end
	end

	iut.map_word_specs(alternant_multiword_spec, function(base)
		add_categories_and_annotation(alternant_multiword_spec, base, multiword_lemma, from_headword)
	end)
	local ann_parts = {}
	local conj = table.concat(ann.conj, " or ")
	table.insert(ann_parts, conj)
	local irreg = table.concat(ann.irreg, " or ")
	if irreg ~= "" and irreg ~= "regular" then
		table.insert(ann_parts, irreg)
	end
	local defective = table.concat(ann.defective, " or ")
	if defective ~= "" and defective ~= "regular" then
		table.insert(ann_parts, defective)
	end
	alternant_multiword_spec.annotation = table.concat(ann_parts, "; ")
end


local function show_forms(alternant_multiword_spec)
	local lemmas = iut.map_forms(alternant_multiword_spec.forms.inf,
		remove_reflexive_indicators)
	alternant_multiword_spec.lemmas = lemmas -- save for later use in make_table()

	local props = {
		lang = lang,
		lemmas = lemmas,
	}
	props.slot_list = all_verb_slots
	iut.show_forms(alternant_multiword_spec.forms, props)
	alternant_multiword_spec.footnote_basic = alternant_multiword_spec.forms.footnote
end


local notes_template = [=[
<div style="width:100%;text-align:left;background:#d9ebff">
<div style="display:inline-block;text-align:left;padding-left:1em;padding-right:1em">
{footnote}
</div></div>
]=]

local basic_table = [=[
{description}<div class="NavFrame">
<div class="NavHead" align=center>&nbsp; &nbsp; Conjugation of {title} (See [[Appendix:Italian verbs]])</div>
<div class="NavContent">
{\op}| style="background:#F0F0F0;border-collapse:separate;border-spacing:2px;width:100%" class="inflection-table"
|-
! style="background:#e2e4c0" | <span title="infinito">infinitive</span>
| {inf}
|-
! colspan="2" style="background:#e2e4c0" | <span title="verbo ausiliare">auxiliary verb</span>
| {aux}
! colspan="2" style="background:#e2e4c0" | <span title="gerundio">gerund</span>
| colspan="2" | {ger}
|-
! colspan="2" style="background:#e2e4c0" |  <span title="participio presente">present participle</span>
| {presp}
! colspan="2" style="background:#e2e4c0" | <span title="participio passato">past participle</span>
| colspan="2" | {pp}
|-
! rowspan="2" style="background:#C0C0C0" | person
! colspan="3" style="background:#C0C0C0" | singular
! colspan="3" style="background:#C0C0C0" | plural
|-
! style="background:#C0C0C0;width:12.5%" | first
! style="background:#C0C0C0;width:12.5%" | second
! style="background:#C0C0C0;width:12.5%" | third
! style="background:#C0C0C0;width:12.5%" | first
! style="background:#C0C0C0;width:12.5%" | second
! style="background:#C0C0C0;width:12.5%" | third
|-
! style="background:#c0cfe4" | <span title="indicativo">indicative</span>
! style="background:#c0cfe4" | io
! style="background:#c0cfe4" | tu
! style="background:#c0cfe4" | lui/lei, esso/essa
! style="background:#c0cfe4" | noi
! style="background:#c0cfe4" | voi
! style="background:#c0cfe4" | loro, essi/esse
|-
! style="height:3em;background:#c0cfe4" | <span title="presente">present</span>
| {pres1s}
| {pres2s}
| {pres3s}
| {pres1p}
| {pres2p}
| {pres3p}
|-
! style="height:3em;background:#c0cfe4" | <span title="imperfetto">imperfect</span>
| {imperf1s}
| {imperf2s}
| {imperf3s}
| {imperf1p}
| {imperf2p}
| {imperf3p}
|-
! style="height:3em;background:#c0cfe4" | <span title="passato remoto">past historic</span>
| {phis1s}
| {phis2s}
| {phis3s}
| {phis1p}
| {phis2p}
| {phis3p}
|-
! style="height:3em;background:#c0cfe4" | <span title="futuro semplice">future</span>
| {fut1s}
| {fut2s}
| {fut3s}
| {fut1p}
| {fut2p}
| {fut3p}
|-
! style="background:#c0d8e4" | <span title="condizionale">conditional</span>
! style="background:#c0d8e4" | io
! style="background:#c0d8e4" | tu
! style="background:#c0d8e4" | lui/lei, esso/essa
! style="background:#c0d8e4" | noi
! style="background:#c0d8e4" | voi
! style="background:#c0d8e4" | loro, essi/esse
|-
! style="height:3em;background:#c0d8e4" | <span title="condizionale presente">present</span>
| {cond1s}
| {cond2s}
| {cond3s}
| {cond1p}
| {cond2p}
| {cond3p}
|-
! style="background:#c0e4c0" | <span title="congiuntivo">subjunctive</span>
! style="background:#c0e4c0" | che io
! style="background:#c0e4c0" | che tu
! style="background:#c0e4c0" | che lui/che lei, che esso/che essa
! style="background:#c0e4c0" | che noi
! style="background:#c0e4c0" | che voi
! style="background:#c0e4c0" | che loro, che essi/che esse
|-
! style="height:3em;background:#c0e4c0" | <span title="congiuntivo presente">present</span>
| colspan="3" | {sub123s}
| {sub1p}
| {sub2p}
| {sub3p}
|-
! style="height:3em;background:#c0e4c0" | <span title="congiuntivo imperfetto">imperfect</span>
| colspan="2" | {impsub12s}
| {impsub3s}
| {impsub1p}
| {impsub2p}
| {impsub3p}
|-
! rowspan="2" style="height:3em;background:#e4d4c0" | <span title="imperativo">imperative</span>
! style="background:#e4d4c0" | &mdash;
! style="background:#e4d4c0" | tu
! style="background:#e4d4c0" | Lei
! style="background:#e4d4c0" | noi
! style="background:#e4d4c0" | voi
! style="background:#e4d4c0" | Loro
|-
|
| {imp2s}
| {imp3s}
| {imp1p}
| {imp2p}
| {imp3p}
|-
! style="height:3em;background:#e4d4c0" | <span title="imperativo negativo">negative imperative</span>
|
| {negimp2s}
| {negimp3s}
| {negimp1p}
| {negimp2p}
| {negimp3p}
|{\cl}{notes_clause}</div></div>
]=]


local function make_table(alternant_multiword_spec)
	local forms = alternant_multiword_spec.forms

	forms.title = link_term(alternant_multiword_spec.lemmas[1].form, "term")
	if alternant_multiword_spec.annotation ~= "" then
		forms.title = forms.title .. " (" .. alternant_multiword_spec.annotation .. ")"
	end
	forms.description = ""

	-- Format the table.
	forms.footnote = alternant_multiword_spec.footnote_basic
	forms.notes_clause = forms.footnote ~= "" and m_string_utilities.format(notes_template, forms) or ""
	return m_string_utilities.format(basic_table, forms)
end


-- Externally callable function to parse and conjugate a verb given user-specified arguments.
-- Return value is WORD_SPEC, an object where the conjugated forms are in `WORD_SPEC.forms`
-- for each slot. If there are no values for a slot, the slot key will be missing. The value
-- for a given slot is a list of objects {form=FORM, footnotes=FOOTNOTES}.
function export.do_generate_forms(parent_args, from_headword, def)
	local params = {
		[1] = {required = true, default = def or "mettere<a\é,mìsi,mésso>"},
		["nocomb"] = {type = "boolean"},
		["noautolinktext"] = {type = "boolean"},
		["noautolinkverb"] = {type = "boolean"},
		["pagename"] = {} -- for testing
	}

	if from_headword then
		params["head"] = {list = true}
		params["id"] = {}
	end

	local args = require("Module:parameters").process(parent_args, params)

	local iut = require("Module:inflection utilities")

	local arg1 = args[1]
	local need_surrounding_angle_brackets = true
	-- Check whether we need to add <...> around the argument. If the
	-- argument has no < in it, we definitely do. Otherwise, we need to
	-- parse the balanced [...] and <...> and add <...> only if there isn't
	-- a top-level <...>. We check for [...] because there might be angle
	-- brackets inside of them (HTML tags in qualifiers or <<name:...>> and
	-- such in references).
	if arg1:find("<") then
		local segments = iut.parse_multi_delimiter_balanced_segment_run(arg1,
			{{"<", ">"}, {"[", "]"}})
		for i = 2, #segments, 2 do
			if segments[i]:find("^<.*>$") then
				need_surrounding_angle_brackets = false
				break
			end
		end
	end
	if need_surrounding_angle_brackets then
		arg1 = "<" .. arg1 .. ">"
	end

	local function do_parse_indicator_spec(angle_bracket_spec, lemma)
		local pagename = args.pagename or mw.title.getCurrentTitle().text
		return parse_indicator_spec(angle_bracket_spec, lemma, pagename)
	end

	local parse_props = {
		parse_indicator_spec = do_parse_indicator_spec,
		lang = lang,
		allow_default_indicator = true,
		allow_blank_lemma = true,
	}
	local escaped_arg1 = escape_reflexive_indicators(arg1)
	local alternant_multiword_spec = iut.parse_inflected_text(escaped_arg1, parse_props)
	alternant_multiword_spec.pos = pos or "verbs"
	alternant_multiword_spec.args = args
	normalize_all_lemmas(alternant_multiword_spec)
	detect_all_indicator_specs(alternant_multiword_spec, from_headword)
	local inflect_props = {
		slot_list = all_verb_slots,
		lang = lang,
		inflect_word_spec = conjugate_verb,
		-- We add links around the generated verbal forms rather than allow the entire multiword
		-- expression to be a link, so ensure that user-specified links get included as well.
		include_user_specified_links = true,
	}
	iut.inflect_multiword_or_alternant_multiword_spec(alternant_multiword_spec, inflect_props)

	-- Convert accented forms to two-part forms and remove PRESERVE_ACCENT characters.
	for slot, forms in pairs(alternant_multiword_spec.forms) do
		for _, form in ipairs(forms) do
			form.form = convert_accented_links(form.form)
		end
	end

	compute_categories_and_annotation(alternant_multiword_spec, from_headword)
	return alternant_multiword_spec
end


-- Entry point for {{it-conj}}. Template-callable function to parse and conjugate a verb given
-- user-specified arguments and generate a displayable table of the conjugated forms.
function export.show(frame)
	local parent_args = frame:getParent().args
	local alternant_multiword_spec = export.do_generate_forms(parent_args)
	show_forms(alternant_multiword_spec)
	return make_table(alternant_multiword_spec) ..
		require("Module:utilities").format_categories(alternant_multiword_spec.categories, lang, nil, nil, force_cat)
end


-- Concatenate all forms of all slots into a single string of the form
-- "SLOT=FORM,FORM,...|SLOT=FORM,FORM,...|...". Embedded pipe symbols (as might occur
-- in embedded links) are converted to <!>. If INCLUDE_PROPS is given, also include
-- additional properties (currently, none). This is for use by bots.
local function concat_forms(alternant_multiword_spec, include_props)
	local ins_text = {}
	for _, slot_and_accel in ipairs(all_verb_slots) do
		local slot = slot_and_accel[1]
		local formtext = iut.concat_forms_in_slot(alternant_multiword_spec.forms[slot])
		if formtext then
			table.insert(ins_text, slot .. "=" .. formtext)
		end
	end
	return table.concat(ins_text, "|")
end


-- Template-callable function to parse and conjugate a verb given user-specified arguments and return
-- the forms as a string "SLOT=FORM,FORM,...|SLOT=FORM,FORM,...|...". Embedded pipe symbols (as might
-- occur in embedded links) are converted to <!>. If |include_props=1 is given, also include
-- additional properties (currently, none). This is for use by bots.
function export.generate_forms(frame)
	local include_props = frame.args["include_props"]
	local parent_args = frame:getParent().args
	local alternant_multiword_spec = export.do_generate_forms(parent_args)
	return concat_forms(alternant_multiword_spec, include_props)
end


return export
