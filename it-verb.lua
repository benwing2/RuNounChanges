local export = {}


--[=[

Authorship: Ben Wing <benwing2>

]=]

--[=[

TERMINOLOGY:

-- "slot" = A particular combination of tense/mood/person/number/etc.
	 Example slot names for verbs are "pres1p" (present indicative first-person plural), "impsub12s" (imperfect
	 subjunctive first/second-person singular form) and "pp" (past participle).
	 Each slot is filled with zero or more forms.

-- "form" = The conjugated Italian form representing the value of a given slot.

-- "lemma" = The dictionary form of a given Italian term. For Italian, always the infinitive.
]=]

--[=[

RULES FOR CONJUGATION:

1. Present indicative:
-- Individual form overrides always take precedence.
-- Otherwise, if presrow: if given, this specifies all six forms (1s, 2s, 3s, 1p, 2p, 3p).
-- Otherwise:
   1. The 1s form is generated from the explicitly specified pres1s principal part.
   2. The 3p form is generated from the explicitly specified pres1s principal part by replacing -o with -ano (for -are verbs)
      or with -ono (for -ere/-ire verbs).
   3. The 2s and 3s forms are generated as follows:
      a. If an explicit pres3s principal part is given using PRES1S^PRES3S, the 2s/3s stem is generated by removing final -a/-e.
	  b. Otherwise, if an explicit stem was given using stem:, this serves as the 2s/3s stem.
	  c. Otherwise, if the infinitive is root-stressed, the 2s/3s stem comes from the infinitive. This is used e.g.
		 with [[togliere]] (tòlgo, tògli, tòglie, togliàmo, togliéte, tòlgono), where the stem of the 1s and 3p forms
		 is different from the stem of the 2s and 3s forms.
	  d. Otherwise, the pres1s stem is used.
	  From this stem, the 2s form is generated by adding -i (possibly with some adjustments; two unstressed i's
	  together are compressed to one, and -h- is inserted after the stem if the verb is an -are verb and the stem ends
	  with -c or -g), and the 3s form is generated by adding -a (for -are verbs) or -e (for -ere/-ire verbs).
   4. The 1p and 2p forms are generated from the infinitive stem (or explicit stem given by stem:) by adding -iàmo
      (1p form) and -àte/-éte/-ìte (2p form, -are/-ere/-ire verbs). We don't use the pres1s form because it might have
	  a different stem (e.g. +isc verbs).

2. Present subjunctive:
-- Individual form overrides always take precedence.
-- Otherwise, if subrow: if given, this specifies all four forms (123s, 1p, 2p, 3p).
-- Otherwise:
   1. If sub: is given, this specifies the 123s form; otherwise the 123s form is generated from the pres1s form by
   changing -o to -a (for -ere/-ire verbs), or to -i (for -are verbs). E.g. for [[venire]], vèngo -> vènga;
   for [[potere]], pòsso -> pòssa. sub: needs to be given for e.g. [[essere]] (pres1s sóno, sub1s sìa),
   [[sapere]] (pres1s sò* but sub1s sàppia), [[fare]] (pres1s fàccio:fò*[archaic or dialectal] but sub1s just fàccia),
   [[andare]] (similar to [[fare]]), [[dovere]].
   2. The 3p form is generated from the 123s form by adding -no.
   3. The 1p form is copied from the pres1p form.
   4. The 2p form is generated from the 1p form by replacing -mo with -te.

3. Imperative:
-- Individual form overrides always take precedence.
-- Otherwise, if improw: if given, this specifies 2s, 2p.
-- Otherwise:
   1. If imp: given, this specifies the 2s form; otherwise the 2s form is generated by copying the pres2s form
      (for -ere/-ire verbs) or by copying the pres3s form (for -are verbs). We use the present indicative 2s/3s
	  forms to preserve vowel and other alternations in the root-stressed forms (for all -are verbs, for
	  [[venire]] and [[tenere]], for +isc verbs, etc.).
   2. The 2p form is generated by copying the pres2p form.
   3. The 3s, 1p, 3p forms are copied from the corresponding present subjunctive forms.
]=]

--[=[

EXAMPLES OF CONJUGATION:

{{it-conj|mettere<a\é,mìsi,mésso>}}

{{it-conj|arrivare<e:a[transitive]/ì>}}

{{it-conj|trovare<a/ò>}}

{{it-conj|sembrare<e/é>}}

{{it-conj|temprare<e/é:#è>}}

{{it-conj|essere<e\è\-,-,stàto.
  presrow:sóno,sèi,è,siàmo,siète,sóno.
  imperfrow:èro,èri,èra,eravàmo,eravàte,èrano.
  phisrow:fùi,fósti,fù*,fùmmo,fóste,fùrono.
  fut:sarò.
  sub:sìa.
  impsub:fóssi.
  improw:sìi:siàte.
  presp:essènte[rare]
>}}

; Including archaic and literary forms:
{{it-conj|essere<e\è\-,-,stàto:essùto[archaic]:sùto[archaic].
  presrow:sóno,sèi,è,siàmo:sémo[archaic],siète:sète[archaic],sóno:èmmo[archaic].
  imperfrow:èro:èra[literary],èri,èra,eravàmo:èramo[archaic],eravàte,èrano.
  phisrow:fùi,fósti:fùsti[archaic],fù*,fùmmo,fóste:fùste[archaic],fùrono:fùro[archaic]:fóre[archaic]:fòro[archaic].
  futrow:sarò,sarài,sarà:fìa[archaic]:fìe[archaic],sarémo,saréte,sarànno:fìano[archaic]:fìeno[archaic].
  condrow:sarèi:sarìa[archaic]:fòra[archaic],sarésti,sarèbbe:sarìa[archaic]:fòra[archaic],sarémmo,saréste,sarèbbero:sarìano[archaic]:fòro[archaic].
  subrow:sìa,siàmo,siàte,sìano:sìeno[literary].
  impsub:fóssi:fùssi[archaic].
  improw:sìi:siàte.
  ger:essèndo:sèndo[archaic].
  presp:essènte[rare]:ènte[archaic]
>}}

{{it-conj|fare<a/-,féci,fàtto.
  stem:fàce.
  presrow:fàccio:fò*[archaic or dialectal],fài,fà*,facciàmo,fàte,fànno.
  sub:fàccia.
  imp:fà*:fài:fà'
>}}

{{it-conj|potere<a:e[as an auxiliary, with main verbs taking ''essere'']/-,potéi:potètti[less common].
  presrow:pòsso,puòi,può*,possiàmo,potéte,pòssono.
  fut:potrò.
  imp:-
>}}

{{it-conj|dire<a/+,dìssi,détto.
  stem:dìce.
  pres2p:dìte.
  imp:dì':dì*+
>}}

{{it-conj|dare<a/dò*:dò*+,dièdi:dètti,dàto.
  presrow:dò*:dò*+,dài,dà*+,diàmo,dàte,dànno.
  sub:dìa.
  fut:darò.
  impsub:déssi.
  imp:dài:dà':dà*+
>}}

{{it-conj|dovere<a:e[as an auxiliary, with main verbs taking ''essere'']/dèvo:dévo:dèbbo:débbo^dève:déve.
  fut:dovrò.
  sub:dèbba:débba:dèva[rare]:déva[rare].
  imp:-
>}}

; Including archaic and poetic forms:
{{it-conj|dovere<a:e[as an auxiliary, with main verbs taking ''essere'']/-.
  presrow:
    dèvo:dévo:dèbbo:débbo:dèggio[archaic or poetic]:déggio[archaic or poetic],
    dèvi:dévi:dèi[archaic, poetic or popular Tuscan]:déi[archaic, poetic or popular Tuscan],
    dève:déve:dèe[archaic, poetic or popular Tuscan]:dée[archaic, poetic or popular Tuscan]:dèbbe[archaic]:débbe[archaic],
    dobbiàmo,
    dovéte,
	dèvono:dévono:dèbbono:débbono:dènno[archaic or poetic]:dénno[archaic or poetic].
  fut:dovrò.
  sub:dèbba:débba:dèva[rare]:déva[rare]:dèggia[archaic or poetic]:déggia[archaic or poetic]:dèbbia[obsolete]:débbia[obsolete].
  imp:-
>}}

{{it-conj|andare<e/-.
  presrow:vàdo:vò*[less common],vài,và*,andiàmo,andàte,vànno.
  fut:andrò.
  sub:vàda.
  imp:vài:và':và*
>}}

{{it-conj|valere<e:a[transitive]/vàlgo^à,vàlsi,vàlso.fut:varrò>}}

{{it-conj|vedere<a/védo:véggo[literary]:véggio[poetic]^é,vìdi,vìsto:vedùto[less popular].
  fut:vedrò
>}}

{{it-conj|venire<e/vèngo:vègno[archaic or poetic]^viène,vénni,venùto.
  fut:verrò
>}}

{{it-conj|sapere<a:e[as an auxiliary, with main verbs taking ''essere'']/-,sèppi.
  presrow:sò*,sài,sà*,sappiàmo,sapéte,sànno.
  fut:saprò.
  sub:sàppia.
  improw:sàppi:sappiàte
>}}

{{it-conj|piacere<e/piàccio^piàce,piàcqui.pres1p:piacciàmo>}}

{{it-conj|comparire<e/compàio:+isc[less common]^à:+isc[less common],compàrvi:comparìi[less common]:compàrsi[in the legal sense],compàrso:comparìto[rare]>}}

{{it-conj|togliere<a\ò\tòlgo,tòlsi,tòlto.fut:+:torrò[literary]>}}

{{it-conj|condurre<a\+,condùssi,condótto.stem:condùce>}}

{{it-conj|proporre<a\ó+\propóngo,propósi,propósto:propòsto.stem:propóne>}}

{{it-conj|trarre<a\tràggo,tràssi,tràtto.stem:tràe>}}


; Third-person only verbs:

{{it-conj|bufare<e/ù.only3s>}}

{{it-verb|accadere<e/à+,accàdde.fut:accadrà.only3sp>}}

{{it-verb|volerci<e/vuòle,vòlle.fut:vorrà.sub:vòglia.only3s>}}

; Defective verbs:

{{it-verb|redire<a/rièdo,-,redìto.imperf:-.fut:-.impsub:->}}

{{it-verb|serpere<-\è,+,->}}

; Multiword expressions:

{{it-verb|tenere<a/tèngo^tiène,ténni.fut:terrò> [[d']][[occhio]]}}

{{it-conj|trascinare<a/ì> e rilasciare<a/à>}}

]=]

--[=[

FIXME:

1. Fix inf_linked and lemma_linked to work like in [[Module:es-verb]].
2. Finish support for reflexive and pronominal verbs.
3. Finish support for reflexive and pronominal imperatives.
4. Finish support for negative imperatives.
5. Fix handling of third-only verbs; require that irregular forms be specified in the first person.
   Remove existing half-implemented support for specifying principal parts in the third person.
6. Support defective verbs specified using e.g. redire<a/rièdo,-,redìto.imperf:-.fut:-.impsub:->.
   Include categorization; but if row overrides or single overrides of all forms given, don't categorize
   as defective for that row.
7. Fix handling of aux; snarf code from [[Module:de-verb]] to handle aux with multiword expressions.
8. Add automatic support for common irregular verbs: [[essere]], [[avere]], [[andare]], [[fare]], [[dare]],
   [[dire]], [[venire]], [[vedere]], [[tenere]], [[bere]], etc. Should make combinations of these verbs
   with clitics, and multiword expressions with these verbs, easier to handle.
9. Add support for calling from {{it-verb}} in [[Module:it-headword]].
10. Throw an error if forms missing accents are specified (perhaps except with some special signal, to make
    it easier to port the old [[Module:it-conj]]).
11. Consider adding combined clitic tables like in [[Module:es-verb]].
12. Consider adding automatic support for prefixed -fare verbs.
13. Consider displaying irregular forms in a different color, as with the old [[Module:es-conj]], or adding
   a triangle next to them, as with [[Module:ru-verb]].
14. Consider supporting replace_reflexive_indicators().
15. Add post-clitic-addition overrides.
16. PRES/PAST/PP spec should be required to come first to avoid ambiguities.
17. Add variant codes to avoid mismatching variants in the conditional -èbbe/-ébbe, -éttero vs. érono, etc.
18. If explicit fut: given, it should control the conditional as well. (DONE)
19. If present -, sub:- or imp:-, it should suppress the whole row in the absence of row or individual overrides.
20. 'ci ci vuole' should maybe -> 'a noi ci vuole' instead of 'ci vuole'.
21. Instead of * before, use + after so that * before can be used for reconstructed terms.
22. When handling built-in verbs, automatically add + after vowel in cases like comporre.
23. When handling built-in verbs, make sure we correctly handle root-stressed infinitives.
24. When handling built-in verbs, make sure explicit * afterwards is handled as if automatically there when a
    prefix is added, and make sure final accent is handled correct when a prefix is added. In both cases, verify
	both sfare and rifare, sdare and ridare.
--]=]

local lang = require("Module:languages").getByCode("it")
local m_string_utilities = require("Module:string utilities")
local m_links = require("Module:links")
local m_table = require("Module:table")
local iut = require("Module:User:Benwing2/inflection utilities")

local force_cat = false -- set to true for debugging
local check_for_red_links = false -- set to false for debugging

local u = mw.ustring.char
local rfind = mw.ustring.find
local rsubn = mw.ustring.gsub
local rmatch = mw.ustring.match
local rsplit = mw.text.split
local ulower = mw.ustring.lower
local uupper = mw.ustring.upper
local usub = mw.ustring.sub
local ulen = mw.ustring.len
local unfd = mw.ustring.toNFD
local unfc = mw.ustring.toNFC

-- version of rsubn() that discards all but the first return value
local function rsub(term, foo, bar)
	local retval = rsubn(term, foo, bar)
	return retval
end

local GR = u(0x0300)
local V = "[aeiou]"
local NV = "[^aeiou]"
local AV = "[àèéìòóù]"
local MAV = "[aeiouàèéìòóù]" -- maybe-accented vowel
local NMAV = "[^aeiouàèéìòóù]" -- not maybe-accented vowel

local PRESERVE_ACCENT = u(0xFFF0)

local full_person_number_list = {"1s", "2s", "3s", "1p", "2p", "3p"}
local imp_person_number_list = {"2s", "3s", "1p", "2p", "3p"}

local all_verb_slots = {
	-- FIXME, needs to be handled specially
	{"aux", "-"},
}

local builtin_verbs = {
	---------------------------------------------- -are verbs --------------------------------------------
	-- must precede dare; va vs. rivà handled automatically
	{"andare", [=[
		-.
		presrow:vàdo:vò*[less common],vài,và*,andiàmo,andàte,vànno.
		fut:andrò.
		sub:vàda.
		imp:vài:và':và*
]=], "<<andare>> and derivatives (<<riandare>>, <<trasandare>>/<<transandare>>)"},
	-- NOTE: specifying détti autogenerates #dètti
	{"dare", [=[
		-,dièdi:diédi:détti.
		presrow:dò*:dò*+[less common],dài,dà*+,diàmo,dàte,dànno.
		sub:dìa.
		fut:darò.
		impsub:déssi.
		imp:dài:dà':dà*+
]=], "<<dare>> and derivatives (<<addare>>, <<ridare>>, <<sdare>>); but not <<andare>> or derivatives"},
	-- NOTE: specifying stétti autogenerates #stètti
	{"stare", [=[
		-,stétti:stièdi[popular or Tuscan]:stiédi[popular or Tuscan].
		presrow:stò*,stài,stà*,stiàmo,stàte,stànno.
		sub:stìa.
		fut:starò.
		impsub:stéssi.
		imp:stài:stà':stà*
]=], "<<stare>> and derivatives (<<ristare>>, <<soprastare>>, <<sottostare>>); not <<sovrastare>>"},

	---------------------------------------------- -ere verbs --------------------------------------------
	{"combere", "ó,+,-", "verbs in ''-combere'' (<<incombere>>, <<procombere>>, <<soccombere>>)"},
	-- iubere: archaic, defective
	-- giacere, piacere, tacere; Hoepli says piacciàmo only, taciàmo only and either giaccìamo or giaciàmo;
	-- but Treccani says all should be in -acciàmo. DOP says piaciàmo and taciàmo are errors and giaciàmo is
	-- "meno bene".
	{"acere", "àccio^à,àcqui.pres1p:acciàmo",
		"<<giacere>>, <<tacere>>, <<piacere>> and derivatives"},
	-- licere (lecere), recere: archaic or poetic, defective
	-- dicere, benedicere: archaic; handled under dire below
	-- soffolcere (suffolcere, soffolgere, suffulcere): archaic, defective
	-- molcere: poetic, defective
	{"vincere", "ì,vìnsi,vìnto", "<<vincere>> and derivatives"},
	{"cuocere", "cuòcio^ò,còssi,còtto.stem:cuòce:còce", "<<cuocere>> and derivatives"},
	{"nuocere", "nòccio:nuòccio^ò,nòcqui,nociùto:nuociùto[rare].stem:nuòce:nòce.presp:nocènte",
		"<<nuocere>>, <<rinuocere>>"},
	{"torcere", "ò,tòrsi,tòrto", "<<torcere>> and derivatives"},
	{"nascere", "à,nàcqui,nàto", "<<nascere>>, <<rinascere>>, <<prenascere>>"},
	{"pascere", "à", "<<pascere>>, <<ripascere>>"},
	-- acquiescere: rare, defective in past participle
	{"mescere", "é", "<<mescere>>, <<rimescere>>"},
	{"crescere", "é,crébbi", "<<crescere>> and derivatives"},
	-- mansuescere: archaic, rare, infinitive only
	{"noscere", "ó,nóbbi", "<<conoscere>>, archaic <<cognoscere>> and derivatives"},
	-- ducere and derivatives: archaic; handled under -durre below
	-- lucere, tralucere, rilucere: archaic, defective
	-- 'cadere' must precede 'adere'
	{"cadere", "à,càddi.fut:cadrò", "<<cadere>> and derivatives"},
	-- NOTE: (1) per DiPI, [[suadere]] can be pronounced suadére (per Treccani/Hoepli) or suàdere.
	-- (2) [[ridere]] has past historic [[rasi]], with /z/ or traditional /s/, whereas the past historic of the
	-- other verbs has only /z/; but this currently makes no difference as we don't indicate all details of verb
	-- pronunciation. If we change this and start indicating full pronunciation (e.g. as [[Module:fr-verb]] does),
	-- we need to split these verbs.
	{"adere", "à,àsi,àso", "<<radere>> and derivatives; <<suadere>> and derivatives; verbs in ''-vadere'' (<<invadere>>, <<evadere>>, <<pervadere>>); but not <<cadere>> and derivatives"},
	-- reddere: archaic for rendere
	-- cedere: cèssi is archaic
	{"cedere", "è", "<<cedere>> and derivatives"},
	{"chiedere", "è:é,chièsi:chiési.chièsto:chiésto", "<<chiedere>> and derivatives"},
	-- riedere: variant of poetic/archaic defective redire (reddire)
	{"siedere", "è:é", "verbs in ''-siedere'' (<<presiedere>>, <<risiedere>>)"},
	{"ledere", "è,lési,léso", "<<ledere>>"},
	-- credere: crési is archaic
	{"credere", "é", "<<credere>> and derivatives (<<discredere>>, <<miscredere>>, <<ricredere>>, <<scredere>>)"},
	-- pedere: obsolete, regular but lacking past participle
	{"sedere", "sièdo:sèggo[literary]^sièdi.fut:+:siederò[popular]", "<<sedere>> and derivatives"},
	-- divedere: defective
	{{term = "vedere", prefixes = {"pre"}}, "é,vìdi,vìsto:vedùto[less popular].fut:vedrò:vederò.presp:+:veggènte", "<<prevedere>>"},
	{{term = "vedere", prefixes = {"prov", "prov"}}, "é,vìdi,vìsto:vedùto[less popular].presp:+:veggènte", "<<provvedere>> (archaic <<provedere>>) and derivatives"},
	-- the following per Dizionario d'ortografia e di pronunzia
	{{term = "vedere", prefixes = {"rav"}}, "é,vìdi,vedùto.fut:vedrò:vederò.presp:+:veggènte", "<<ravvedere>>"},
	{{term = "vedere", prefixes = {"^tra", "tras", "trans", "stra", "anti"}}, "é,vìdi,vedùto.fut:vedrò.presp:+:veggènte", "<<travedere>> and variants, <<stravedere>>, <<antivedere>>"},
	{"vedere", "é,vìdi,vìsto:vedùto[less popular].fut:vedrò.presp:+:veggènte", "<<vedere>> and some derivatives (e.g. <<avvedere>>, <<intravedere>>, <<rivedere>>); may need overrides, e.g. <<rivedere>> in the meaning \"to revise\" has only <<riveduto>> as past participle"},
	-- stridere: past participle is lacking (per Hoepli), not used (per DOP) or extremely rare (per Treccani)
	{"stridere", "ì,+,-", "<<stridere>>"},
	-- NOTE: [[ridere]] has past historic [[risi]], with /z/ or traditional /s/, whereas the past historic of the
	-- other verbs has only /z/; see comment above about 'adere'.
	{"idere", "ì:ìsi:ìso", "verbs in ''-cidere'' (<<incidere>>, <<coincidere>>, <<uccidere>>, <<decidere>>, etc.; verbs in ''-lidere'' (<<elidere>>, <<collidere>>, <<allidere>>); <<ridere>> and derivatives; <<assidere>>; <<dividere>> and derivatives; but not <<stridere>>"},
	-- Treccani (under [[espandere]] says past historic only spànsi, past participle only spànso. Hoepli says past
	-- historic spandéi or (uncommon) spandètti or spànsi, past participle spànto or archaic spànso or spandùto.
	-- The reality from reverso.net is somewhere in between.
	{"spandere", "à,spànsi:+[uncommon],spànto:spànso", "<<spandere>> and derivatives"},
	-- must precede cendere
	{"scendere", "é:è,scési,scéso", "<<scendere>> and derivatives"},
	{"cendere", "è,cési,céso", "<<accendere>> and derivatives, <<incendere>>"},
	{{term = "fendere", prefixes = {"di", "de", "of"}}, "è,difési,diféso", "<<difendere>> (archaic <<defendere>>), <<offendere>> and derivatives"},
	{"fendere", "è,+,+:fésso", "<<fendere>>, <<rifendere>>, <<sfendere>>; but not <<offendere>>, <<difendere>> or respective derivatives"},
	-- stridere: past participle is rare (per Hoepli), not used (per DOP and Treccani)
	{"splendere", "è,+,-", "<<splendere>> and derivatives"},
	{"^pendere", "è,+,+[rare]", "<<pendere>>; but not any derivatives"},
	{"propendere", "è,+,propéso[rare]", "<<propendere>>"},
	{"pendere", "è,pési,péso", "<<appendere>>, <<dipendere>>, <<spendere>>, <<sospendere>> and other verbs and derivatives in ''-pendere'' other than <<pendere>> and <<propendere>>"},
	{"prendere", "è,prési,préso", "<<prendere>> and derivatives"},
	{"rendere", "è,rési:+[literary],réso", "<<rendere>>, <<arrendere>> and <<rirendere>>"},
	{"tendere", "è,tési,téso", "<<tendere>>, <<stendere>> and derivatives of each"},
	{"vendere", "é", "<<vendere>> and derivatives"},
	{"scindere", "ì,scìssi,scìsso", "<<scindere>> and derivatives"},
	{"scondere", "ó,scósi,scósto", "<<nascondere>>, <<ascondere>> and derivatives of each"},
	{"fondere", "ó,fùsi,fùso", "<<fondere>> and derivatives"},
	{"spondere", "ó,spósi,spósto", "<<rispondere>> (archaic <<respondere>>) and derivatives"},
	-- Hoepli says tònso but I suspect it's a mistake; Olivetti says tónso
	{"tondere", "ó,+,+:tónso", "<<tondere>>"},
	{"tundere", "ù,tùsi,tùso", "<<contundere>> and <<ottundere>>"},
	{"godere", "ò,+,+.fut:godrò:goderò[uncommon]", "<<godere>> and derivatives"},
	{"plodere", "ò,plòsi,plòso", "<<esplodere>>, <<implodere>> and derivatives"},
	{"rodere", "ó,rósi,róso", "<<rodere>> and derivatives"},
	{"ardere", "à,àrsi,àrso", "<<ardere>> and derivatives"},
	{"perdere", "è,pèrsi:perdètti:perdéi[less common],pèrso:perdùto", "<<perdere>> and derivatives"},
	{"mordere", "ò,mòrsi,mòrso", "<<mordere>> and derivatives"},
	-- gaudere: literary or archaic, defective
	{"prudere", "ù,+[rare],-", "<<prudere>>"},
	{"udere", "ù,ùsi,ùso", "<<chiudere>> and derivatives; verbs in ''-cludere'' (<<concludere>>, <<includere>>, <<escludere>>, etc.); verbs in ''-ludere'' (<<eludere>>, <<deludere>>, <<alludere>>, etc.); verbs in ''-trudere'' (<<intrudere>>, <<protrudere>>, <<estrudere>>, etc.); but not <<prudere>> or <<gaudere>>"},
	-- piagere, plagere: archaic, defective
	-- traggere and derivatives: archaic; handled under trarre below
	{"eggere", "è,èssi,ètto", "<<leggere>> and derivatives; <<reggere>> and derivatives; <<proteggere>> and derivatives"},
	{{term = "figgere", prefixes = {"^", "con", "ri", "scal", "tra"}}, "ì,fìssi,fìtto", "<<figgere>> and some derivatives (<<configgere>>, <<rifiggere>>, <<scalfiggere>>, <<trafiggere>> and derivatives), with past participle in ''-fitto''"},
	{"figgere", "ì,ìssi,ìsso", "most derivatives of <<figgere>> (<<affiggere>>, <<crocifiggere>> and variants, <<defiggere>>, <<infiggere>>, <<prefiggere>>, <<suffiggere>>, and derivatives), with past participle in ''-fisso''"},
	{"fliggere", "ì,flìssi,flìtto", "verbs in ''-fliggere'' (<<affliggere>>, <<confliggere>>, <<infliggere>>)"},
	{"friggere", "ì,frìssi,frìtto", "<<friggere>> and derivatives"},
	{"struggere", "ì,strùssi,strùtto", "<<struggere>> and derivatives"},
	{"redigere", "ì,redàssi,redàtto", "<<redigere>>"},
	-- indigere: archaic, defective
	-- negligere: uncommon, defective
	{"diligere", "ì,dilèssi,dilètto", "<<diligere>> and derivatives"},
	{"rigere", "ì,rèssi,rètto", "<<erigere>>, <<dirigere>> and derivatives"},
	{"sigere", "ì,+[uncommon],sàtto", "<<esigere>> and <<transigere>>"},
	{"vigere", "ì,vigéi,-.only3sp", "<<vigere>>"},
	-- algere: archaic poetic, defective
	-- soffolgere: archaic, defective; variant of soffolcere, see above
	-- molgere: rare, literary, defective
	{"volgere", "ò,vòlsi,vòlto", "<<volgere>> and derivatives"},
	{"indulgere", "ù,indùlsi,indùlto", "<<indulgere>>"},
	{"fulgere", "ù,fùlsi,-", "<<fulgere>> and derivatives; lacking past participle"},
	-- angere: archaic or poetic, defective
	{{term = "angere", prefixes = {"pi", "pl"}}, "à,ànsi,ànto", "<<piangere>> (archaic <<plangere>>) and derivatives"},
	-- piagnere: archaic, defective, no past historic or past participle
	-- clangere: literary, rare, defective, no past historic or past participle
	{"frangere", "à,frànsi,frànto", "<<frangere>> and derivatives"},
	-- tangere: literary, defective
	-- etc.
	{"spengere", "è:é,spènsi:spénsi,spènto:spénto", "<<spengere>> (Tuscan variant of <<spegnere>>)"},
	{"mingere", "ì,mìnsi,-", "<<mingere>> and derivatives"},
	{"stringere", "ì,strìnsi,strétto", "<<stringere>> and derivatives"},
	{"ingere", "ì,ìnsi,ìnto", "<<cingere>> and derivatives; <<fingere>> and derivatives; <<pingere>> and derivatives; <<spingere>> and derivatives; <<tingere>> and derivatives; but not <<mingere>> (lacking the past participle), and not <<stringere>> and derivatives (with past participle <<stretto>> etc.)"},
	{"fungere", "ù,fùnsi,fùnto[rare]", "<<fungere>> and derivatives"},
	{"ungere", "ù,ùnsi,ùnto", "<<ungere>>; <<giungere>> and derivatives; <<mungere>> and derivatives; <<pungere>> and derivatives; but not <<fungere>> and derivatives (past participle is formed the same way but rare)"},
	-- arrogere: archaic, defective
	-- allargere: send to RFV
	{{term = "ergere", prefixes = {"^", "ad", "ri"}}, "è,èrsi,èrto:#érto", "<<ergere>>, <<adergere>>, <<riergere>>; but not any other verbs in ''-ergere''"},
	{{term = "ergere", prefixes = {"m", "sp", "t"}}, "è,èrsi,èrso", "<<mergere>> and derivatives; <<spergere>> and derivatives; <<tergere>> and derivatives"},
	{"^vergere", "è,vergéi,-", "<<vergere>>; but not any derivatives"},
	{"convergere", "è,convèrsi:+[rare],convèrso[rare]", "<<convergere>>"},
	{"divergere", "è,divèrsi[rare],-", "<<divergere>>"},
	{{term = "orgere", prefixes = {"sc", "p"}}, "ò:ó,òrsi:órsi,òrto:órto", "<<scorgere>>; <<porgere>> and derivatives"},
	{"sorgere", "ó:ò,sórsi:sòrsi,sórto:sòrto", "<<sorgere>>"},
	{"urgere", "ù,-,-", "<<urgere>>"},
	{"surgere", "ù,sùrsi,sùrto", "<<surgere>> and derivatives"},
	-- turgere: poetic, defective
	{"scegliere", "é\\scélgo,scélsi,scélto", "<<scegliere>> and derivatives"},
	-- svegliere: archaic form of svellere, defective
	{{term = "ogliere", prefixes = {"c", "sci", "t"}}, "ò\\òlgo,òlsi,òlto", "<<cogliere>> and derivatives; <<sciogliere>> and derivatives; <<togliere>> and derivatives"},
	{"adempiere", "é,adempiéi.pres2p:adempìte", "<<adempiere>>; see also <<adempire>> of the same meaning"},
	{"empiere", "émpio,empìi,empiéi[less common],empiùto.stem:émpi", "<<empiere>>, <<riempiere>>; but not <<adempiere>>, which borrows fewer forms from <<adempire>>; see also <<empire>>, <<riempire>> of the same meaning"},
	{"compiere", [=[
	ó:ò,compiéi,compìi[more common],+.pres2p:compiéte,compìte[more common].
	imperf:compiévo,compìvo[more common].
	impsub:compiéssi,compìssi[more common].
	fut:compierò:compirò[more common]
]=], "<<compiere>>, <<ricompiere>>; see also <<compire>>, <<ricompire>>"},
	-- calere: rare/literary, defective
	{"valere", "vàlgo^à,vàlsi,vàlso.fut:varrò", "<<valere>> and derivatives"},
	{"eccellere", "è,eccèlsi,eccèlso[rare]", "<<eccellere>>"},
	{"pellere", "è,pùlsi,pùlso", "verbs in ''-pellere'' (<<espellere>>, <<impellere>>, <<propellere>>, <<repellere>>, etc."},
	{"avellere", "è,vùlsi,vùlso", "<<avellere>>"},
	{"svellere", "è:svèlgo,svèlsi,svèlto", "<<svellere>>, <<disvellere>>"},
	{"vellere", "è:vèlgo,vèlsi:vùlsi[uncommon or archaic],vèlto:vùlso[uncommon or archaic]",
		"<<vellere>> and certain derivatives, especially <<divellere>>; note that <<evellere>> and <<convellere>> need special handling as they are defective"},
	-- evellere, convellere: literary or archaic, defective
	-- tollere: archaic, unclear conjugation
	{{term = "tollere", prefixes = {"at", "es"}}, "è,-,-", "<<attollere>>, <<estollere>>"},
	-- colere: archaic, defective
	{"dolere", "dòlgo^duòle,dòlsi,+.fut:dorrò", "<<dolere>> and derivatives"},
	{"solere", "sòglio^suòle,soléi[rare],sòlito.pres1p:sogliàmo.fut:-.imp:-.presp:-", "<<solere>>"},
	{"volere", "-,vòlli.presrow:vòglio,vuòi,vuòle,vogliàmo,voléte,vògliono.fut:vorrò",
		"<<volere>> and derivatives"},
	{"gemere", "è", "<<gemere>> and derivatives"},
	{"fremere", "è", "<<fremere>>"},
	-- premere, spremere: regular; past historic prèssi and past participle prèsso archaic
	{"premere", "è", "<<premere>>, <<spremere>> and derivatives"},
	{"temere", "è:#é", "<<temere>> and derivatives"},
	{"redimere", "ì,redènsi,redènto", "<<redimere>>"},
	{"perplimere", "ì,+,perplèsso:perplimùto[rare]", "<<perplimere>>"},
	{"dirimere", "ì,+[rare],-", "<<dirimere>>"},
	{"primere", "ì,prèssi,prèsso", "verbs in ''-primere'' (<<comprimere>>, <<deprimere>>, <<esprimere>>, <<imprimere>>, etc."},
	{"esimere", "ì,+,-", "<<esimere>>"},
	-- presummere: obsolete, unclear conjugation
	-- promere: archaic, defective
	{"sumere", "ù,sùnsi,sùnto", "verbs in ''-sumere'' (<<assumere>>, <<consumere>>, <<presumere>>, <<resumere>>, etc.)"},
	{"rimanere", "rimàngo^à,rimàsi,rimàsto.fut:rimarrò", "<<rimanere>>"},
	{"permanere", "permàngo^à,permàsi,-.fut:permarrò", "<<permanere>>"},
	{"tenere", "tèngo^tiène,ténni.fut:terrò", "<<tenere>> and derivatives"},
	{"spegnere", "é:#è\\spéngo:#spèngo,spénsi:#spènsi,spénto:#spènto", "<<spegnere>> and derivatives"},
	-- accignere, scignere, pignere and derivatives, strignere and derivatives, ugnere: all obsolete, unclear conjugation
	{"cernere", "è,+,cernìto[uncommon]", "<<cernere>> and derivatives"},
	{"sapere", [=[
		-,sèppi.
		presrow:sò*,sài,sà*,sappiàmo,sapéte,sànno.
		fut:saprò.
		sub:sàppia.
		improw:sàppi:sappiàte
]=], "<<sapere>> and derivatives"},
	{"rompere", "ó,rùppi,rótto", "<<rompere>> and derivatives"},
	-- scerpere: archaic/obsolete, unclear conjugation
	{"serpere", "è,-,-", "<<serpere>>"},
	{"^parere", "pàio^à,pàrvi,pàrso.pres1p:paiàmo.fut:parrò", "<<parere>>"},
	-- sparere, trasparere: archaic/obsolete, unclear conjugation
	-- sofferere: archaic/obsolete, unclear conjugation
	-- cherere, chierere: archaic/obsolete, unclear conjugation
	{"correre", "ó,córsi,córso", "<<correre>> and derivatives"},
	-- comburere: literary, defective
	-- furere: archaic rare, unclear conjugation
	{{term = "essere", prefixes = {"^", "ri"}}, [=[
		è\-,-,stàto.
		presrow:sóno,sèi,è,siàmo,siète,sóno.
		imperfrow:èro,èri,èra,eravàmo,eravàte,èrano.
		phisrow:fùi,fósti,fù*,fùmmo,fóste,fùrono.
		fut:sarò.
		sub:sìa.
		impsub:fóssi.
		improw:sìi:siàte.
		presp:essènte[rare]
]=], "<<essere>>, <<riessere>>"},
	{"tessere", "è,tesséi,+", "<<tessere>> and derivatives"},
	{"mietere", "è:é,mietéi,+", "<<mietere>>"},
	{"ripetere", "è", "<<ripetere>>"},
	{"competere", "è,competéi,-", "<<competere>> and derivatives"},
	{"potere", [=[
		-,potéi:potètti[less common].
		presrow:pòsso,puòi,può*,possiàmo,potéte,pòssono.
		fut:potrò.
		imp:-
]=], "<<potere>> and derivatives"},
	{"cotere", "ò,còssi,còsso", "verbs in ''-cotere'' (popular or poetic variant of verbs in ''-cuotere'', such as <<percuotere>> and <<scuotere>>)"},
	{"cuotere", "ò,còssi,còsso.stem:cuòte[now preferred]:còte[also found]", "verbs in ''-cuotere'' (<<percuotere>>, <<scuotere>>, etc.)"},
	{"^vertere", "è,vertéi,-.only3sp", "<<vertere>> (but not any derivatives)"},
	-- divertere, convertere, etc.: archaic, unclear conjugation
	-- avertere: archaic
	{"controvertere", "è,-,-.stem:controvèrti.fut:-.imp:-.presp:-", "<<controvertere>>"},
	{{term = "vertere", prefixes = {"estro", "intro"}}, "è,-,vèrso:vertìto", "<<estrovertere>> and <<introvertere>>"},
	{"sistere", "ì,+,sistìto", "verbs in ''-sistere'' (<<consistere>>, <<esistere>>, <<insistere>>, <<resistere>>, etc.)"},
	{"battere", "à", "<<battere>> and derivatives"},
	{"flettere", "è,flettéi:flèssi[less common],flèsso", "<<flettere>> and derivatives; <<riflettere>> needs an override to handle differences in the past participle"},
	{"mettere", "é,mìsi,mìso", "<<mettere>> and derivatives"},
	{"nettere", "é:#è,+,nésso:#nèsso", "verbs in ''-nettere'' (<<annettere>>, <<connettere>> and derivatives)"},
	{"fottere", "ó,fottéi", "<<fottere>> and derivatives"},
	-- Hoepli says [[incutere]] has past historic ''incutéi'' or ''incùssi''; DOP says "[[incussi]] (non [[incutei]])";
	-- Treccani agrees with DOP, saying [[incutere]] is conjugated like [[discutere]]
	{"cutere", "ù,cùssi,cùsso", "verbs in ''-cutere'' (<<discutere>>, <<escutere>>, <<incutere>>)"},
	{"stinguere", "ì,stìnsi,stìnto", "verbs in ''-stinguere'' (<<estinguere>>, <<distinguere>> and derivatives)"},
	-- delinquere, relinquere: defective, rare or poetic
	{"riavere", [=[
		-,rièbbi.
		presrow:riò,riài,rià,riabbiàmo,riavéte,riànno.
		fut:riavrò.
		sub:riàbbia.
		imp:riàbbi.
		presp:riavènte,riabbiènte
]=], "<<riavere>>"},
	{"^avere", [=[
		-,èbbi.
		presrow:hò*,hài,hà*,abbiàmo,avéte,hànno.
		fut:avrò.
		sub:àbbia.
		imp:àbbi.
		presp:avènte,abbiènte
]=], "<<avere>> (but not derivative <<riavere>>)"},
	-- bevere: archaic; handled under bere below
	{"ricevere", "é", "<<ricevere>> and derivatives"},
	{"scrivere", "ì,scrìssi,scrìtto", "<<scrivere>> and derivatives"},
	{{term = "vivere", prefixes = {"con", "soprav"}}, "ì:vìssi:vissùto.fut:vivrò:+", "<<convivere>>, <<sopravvivere>>"},
	{"vivere", "ì:vìssi:vissùto.fut:vivrò", "<<vivere>>, <<rivivere>>"},
	{"sciolvere", "ò,+:sciòlsi,sciòlto", "<<sciolvere>>, <<asciolvere>>"},
	{"^solvere", "ò,+,solùto", "<<solvere>>; but not any derivatives"},
	{"solvere", "ò,sòlsi:+[rare],sòlto", "verbs in ''-solvere'' (<<assolvere>>, <<dissolvere>>, <<risolvere>>, etc.); but not <<solvere>>"},
	{{term = "volvere", prefixes = {"de", "e"}}, "ò,+:vòlsi[less common],volùto", "<<devolvere>>, <<evolvere>>"},
	-- volvere, svolvere, etc. archaic
	{"involvere", "ò,-,involùto", "<<involvere>>"}, -- DOP says pp also invòlto
	{"dovere", [=[
		dèvo:dévo:dèbbo:débbo^dève:déve.
		fut:dovrò.
		sub:dèbba:débba:dèva[rare]:déva[rare].
		imp:-
]=]},
	{"piovere", "ò,piòvvi,+.only3sp", "<<piovere>> and derivatives"},
	-- movere and derivatives: archaic
	{"muovere", "ò\\muòvo^muòve,mòssi,mòsso.stem:mòve:muòve.presp:movènte"},
	{"fervere", "è,+[rare],-"},

	---------------------------------------------- -ire verbs --------------------------------------------
	-- NOTE: Does not include verbs whose only irregularity is a present participle in -iènte, e.g. [[ambire]],
	-- [[ubbidire]], [[impedire]], [[regredire]]/[[progredire]]/[[trasgredire]], [[spedire]], [[blandire]],
	-- [[adempire]], and many others.

	-- ire: archaic, defective
	--
	{{term = "sorbire", prefixes = {"as", "ad", "de"}}, "+isc:ò.presp:+", "<<assorbire>>, <<adsorbire>>, rare <<desorbire>>; but not <<sorbire>>"},
	-- folcire: rare, literary, defective: fólce, folcìsse
	{"escire", "è.presp:+", "<<escire>> and derivatives (archaic/popular for <<uscire>>)"},
	{"uscire", "èsco.presp:+", "<<uscire>> and derivatives"},
	{"cucire", "cùcio^ù.presp:+", "<<cucire>> and derivatives"},
	{"sdrucire", "+isc:sdrùcio[rare]^+isc:ù[rare].pres3p:sdrucìscono:sdrùciono[rare]:sdrùcono[rare].presp:+", "<<sdrucire>> and derivatives"},
	-- redire, reddire: poetic, highly defective
	{"applaudire", "à:+isc[rare].presp:+", "<<applaudire>> and derivatives"},
	{"udire", "òdo.fut:+:udrèi.presp:+:udiènte", "<<udire>> and derivatives"}, -- must precede dire
	{"fuggire", "ù.presp:+", "<<fuggire>> and derivatives"},
	-- gire: archaic, defective
	{"salire", "sàlgo^à.presp:+:saliènte", "<<salire>> and derivatives"},
	-- boglire: archaic, unclear conjugation
	{"sbollire", "ó:+isc.presp:+", "<<sbollire>>"},
	{"bollire", "ó.presp:+", "<<bollire>> and derivatives, except <<sbollire>>"},
	{"dormire", "ò.presp:+:dormiènte", "<<dormire>> and derivatives"},
	{{term = "venire", prefixes = {"s"}}, "vèngo^viène,vénni,venùto.fut:verrò:venirò.presp:veniènte", "<<svenire>> and derivatives"},
	{"venire", "vèngo^viène,vénni,venùto.fut:verrò.presp:veniènte", "<<venire>> and derivatives; but not <<svenire>> or derivatives"},
	{"empire", "émpio,+:empiéi[less common],+:empiùto[less common].ger:empièndo.presp:empiènte",
		"<<empire>> and <<riempire>>; not <<adempire>>, which has a more regular conjugation"},
	-- {"apparire/riapparire", ...},
	-- {"comparire/scomparire", ...},
	-- {"disparire", ...},
	-- {"trasparire", ...},
	{"offrire", "ò,+:offèrsi[less common],offèrto.presp:offerènte:+[rare]", "<<offrire>>, <<soffrire>> and derivatives"},
	{"morire", "muòio:mòio[popular]^muòre:ò[popular],+,mòrto.fut:+:morrò.presp:+", "<<morrire>> and derivatives (<<smorire>> has no past participle and needs an override)"},
	{"aprire", "à,+:apèrsi[less common],apèrto.presp:+", "<<aprire>> and derivatives"},
	{"coprire", "ò,+:copèrsi[less common],copèrto.presp:+", "<<coprire>> and derivatives"},
	-- scovrire: archaic, unclear conjugation
	{"borrire", "+isc:ò.presp:+", "<<aborrire>>, <<abborrire>>"},
	{"nutrire", "ù:+isc[less common].presp:nutriènte", "<<nutrire>> and derivatives"},
	-- putrire: literary, rare
	{"^mentire", "é:#è:+isc.presp:-", "<<mentire>>; but not derivative <<smentire>>, nor <<sementire>> or <<intormentire>>"},
	{"sentire", "è.presp:+[rare]", "<<sentire>> and derivatives"},
	{"invertire", "è:+isc[less common]", "<<invertire>> and derivatives"},
	{"introvertire", "+isc,-,+", "<<introvertire>>"},
	{"pervertire", "è:+isc[rare]", "<<pervertire>>"},
	{"vertire", "è", "verbs in ''-vertire'' other than <<invertire>>, <<introvertire>> and <<pervertire>>, e.g. <<avvertire>>, <<convertire>>, <<divertire>>, <<sovvertire>>"},
	-- {"partire/ripartire/dipartire", ...},
	-- {"sortire", ...},
	-- {"accestire", ...},
	-- {"vestire/rivestire/investire/travestire/svestire", ...},
	-- {"inghiottire", ...},
	-- {"putire", ...},
	-- {"languire", ...},
	-- {"seguire/eseguire/conseguire/proseguire/perseguire/inseguire/susseguire/asseguire", ...},
	-- {"servire", ...},

	------------------------------------------- syncopated verbs -----------------------------------------
	-- affare: 3rd person only, no pp, affà
	-- assuefare, confare, contraffare, disassuefare, dissuefare, mansuefare, putrefare, rarefare, rifare, sopraffare,
	--   strafare, stupefare, torrefare, tumefare: like fare, written assuefò/assuefà, confò/confà, etc. will be
	--   handled automatically as the accent removal is late and dependent on the number of syllables in the word.
	-- malfare: infinitive only
	-- sfare: like fare
	{"disfare", [=[
		-,disféci,disfàtto.
		stem:disfàce.
		presrow:disfàccio:dìsfo:disfò[less common],dìsfi:disfài[less common],dìsfa:disfà[less common],disfacciàmo:disfiàmo[common but proscribed],disfàte,dìsfano:disfànno[less common].
		sub:dìsfi:disfàccia[less common].
		fut:disfarò:disferò[informal].
		imp:fà*:fài:fà'
]=], "<<disfare>>, <<soddisfare>> (<<sodisfare>>)"},
	{"liquefare", [=[
		-,liqueféci,liquefàtto.
		stem:liquefàce.
		presrow:liquefàccio:liquefò[less common]:lìquefo[proscribed],liquefài,liquefà:lìquefa[proscribed],liquefacciàmo,liquefàte,liquefànno:lìquefano[proscribed].
		sub:liquefàccia.
		imp:liquefà:liquefài:liquefà'
]=], "<<liquefare>>"},
	{"fare", [=[
		-,féci,fàtto.
		stem:fàce.
		presrow:fàccio:fò*[less common],fài,fà*,facciàmo,fàte,fànno.
		sub:fàccia.
		imp:fà*:fài:fà'
]=], "<<fare>> and derivatives; but not <<disfare>>, <<soddisfare>> or <<liquefare>>"},
	{"trarre", "tràggo,tràssi,tràtto.stem:tràe"},
	-- archaic variant of trarre, with some different present tense (hence conditional/imperative) forms
	{"traggere", "tràggo^tràgge,tràssi,tràtto.pres1p:traggiàmo.fut:trarrò.stem:tràe"},
	{"bere", "é,bévvi:bevétti:bevéi[rare].fut:berrò.stem:béve",
		"<<bere>>, <<strabere>>, <<ribere>>; but not <<ebere||to weaken>> or <<iubere||to command, to order>>"},
	{"bevere", "é,bévvi:bevétti:bevéi[rare]", "<<bevere>> and derivatives (archaic variant of <<bere>>)"},
	-- benedire (strabenedire, ribenedire), maledire (stramaledire, rimaledire)
	{{term = "dire", prefixes = {"bene", "male"}}, "+,dìssi:dìi[popular],détto.stem:dìce.pres2p:dìte.imperf:+:dìvo[popular]", "<<benedire>>, <<maledire>> and derivatives"},
	-- dire, ridire
	{{term = "dire", prefixes = {"^", "ri"}}, "+,dìssi,détto.stem:dìce.pres2p:dìte.imp:dì':dì*+", "<<dire>>, <<ridire>>; not any other derivatives"},
	-- addire, contraddire, ricontraddire, indire, interdire, predire, etc.
	{"dire", "+,dìssi,détto.stem:dìce.pres2p:dìte", "derivatives of <<dire>> other than <<benedire>>, <<maledire>> and <<ridire>>"},
	-- dicere: archaic; not included due to multiple variants
	{"porre", "ó\\póngo,pósi,pósto:pòsto.stem:póne"},
	-- archaic variant of porre
	{"ponere", "ó\\póngo,pósi,pósto:pòsto"},
	-- condurre, etc.
	{"durre", "+,dùssi,dótto.stem:dùce"},
	-- archaic variant of -durre
	{"ducere", "+,dùssi,dótto"},
}

-- Used to create the accelerator entries in all_verb_slots.
local person_number_tag_prefix = {
	["1s"] = "1|s|",
	["2s"] = "2|s|",
	["3s"] = "3|s|",
	["1p"] = "1|p|",
	["2p"] = "2|p|",
	["3p"] = "3|p|",
	[""] = "", -- used for non-finite forms such as the past participle
}

substitutable_reflexive_pronoun = {
	["si"] = {
		["1s"] = "[[mi]]",
		["2s"] = "[[ti]]",
		["3s"] = "[[si]]",
		["1p"] = "[[ci]]",
		["2p"] = "[[vi]]",
		["3p"] = "[[si]]",
		["nf"] = "[[si]]",
	},
	["se"] = {
		["1s"] = "[[me]]",
		["2s"] = "[[te]]",
		["3s"] = "[[se]]",
		["1p"] = "[[ce]]",
		["2p"] = "[[ve]]",
		["3p"] = "[[se]]",
		["nf"] = "[[se]]",
	},
	["si_no_ci"] = {
		["1s"] = "[[mi]]",
		["2s"] = "[[ti]]",
		["3s"] = "[[si]]",
		["1p"] = "",
		["2p"] = "[[vi]]",
		["3p"] = "[[si]]",
		["nf"] = "[[si]]",
	},
	["si_no_vi"] = {
		["1s"] = "[[mi]]",
		["2s"] = "[[ti]]",
		["3s"] = "[[si]]",
		["1p"] = "[[ci]]",
		["2p"] = "",
		["3p"] = "[[si]]",
		["nf"] = "[[si]]",
	},
	["space_no_ci"] = {
		["1s"] = " ",
		["2s"] = " ",
		["3s"] = " ",
		["1p"] = "",
		["2p"] = " ",
		["3p"] = " ",
		["nf"] = " ",
	},
	["space_no_vi"] = {
		["1s"] = " ",
		["2s"] = " ",
		["3s"] = " ",
		["1p"] = " ",
		["2p"] = "",
		["3p"] = " ",
		["nf"] = " ",
	},
}

-- FIXME, the following broken and not yet used
local reflexive_forms = {
	["si"] = {"mi", "ti", "si", "ci", "vi", "si"},
	["suo"] = {"mìo", "tùo", "sùo", "nòstro", "vòstro", "sùo"},
	["sua"] = {"mìa", "tùa", "sùa", "nòstra", "vòstra", "sùa"},
	["suoi"] = {"mièi", "tuòi", "suòi", "nòstri", "vòstri", "suòi"},
	["sue"] = {"mìe", "tùe", "sùe", "nòstre", "vòstre", "sùe"},
}


local function remove_accents(form)
	return rsub(form, AV, function(v) return usub(unfd(v), 1, 1) end)
end


-- Add links around words. If multiword_only, do it only in multiword forms.
local function add_links(form, multiword_only)
	if form == "" or form == " " then
		return form
	end
	if not form:find("%[%[") then
		if rfind(form, "[%s%p]") then --optimization to avoid loading [[Module:headword]] on single-word forms
			local m_headword = require("Module:headword")
			if m_headword.head_is_multiword(form) then
				form = m_headword.add_multiword_links(form)
			end
		end
		if not multiword_only and not form:find("%[%[") then
			form = "[[" .. form .. "]]"
		end
	end
	return form
end


-- Convert links around accented words to two-part links without extra accents.
local function convert_accented_links(text)
	return rsub(text, "%[%[([^%[%]|]+)%]%]",
		function(linktext)
			if rfind(linktext, "^.*" .. MAV .. ".*" .. AV .. "$") then
				-- final accented vowel with preceding vowel; keep accent
			elseif rfind(linktext, PRESERVE_ACCENT) then
				linktext = rsub(linktext, PRESERVE_ACCENT, "")
			else
				local unaccented = remove_accents(linktext)
				if unaccented == linktext then
					-- keep linktext
				else
					linktext = unaccented .. "|" .. linktext
				end
			end
			return "[[" .. linktext .. "]]"
		end)
end


local function strip_spaces(text)
	return rsub(text, "^%s*(.-)%s*$", "%1")
end


-- Like iut.split_alternating_runs() but strips spaces from both ends of the odd-numbered elements (only in
-- odd-numbered runs if preserve_splitchar is given). Effectively we leave alone the footnotes and splitchars
-- themselves, but otherwise strip extraneous spaces. Spaces in the middle of an element are also left alone.
local function split_alternating_runs_and_strip_spaces(segment_runs, splitchar, preserve_splitchar)
	local split_runs = iut.split_alternating_runs(segment_runs, splitchar, preserve_splitchar)
	local function strip_run(run)
	end
	for i, run in ipairs(split_runs) do
		if not preserve_splitchar or i % 2 == 1 then
			for j, element in ipairs(run) do
				if j % 2 == 1 then
					run[j] = strip_spaces(element)
				end
			end
		end
	end
	return split_runs
end


local function check_not_null(base, form, spec, principal_part_desc)
	if not form then
		error(("Spec '%s' cannot be used because default %s cannot be derived from '%s'"):format(
			spec, principal_part_desc, base.lemma))
	end
end


local function skip_slot(base, slot)
	if base.props.only3s or base.props.only3sp then
		-- Impersonal or third-person-only verb.
		if slot:find("[12]") and not slot:find("3") then
			-- Skip slots for 1/2 person that don't also reference 3rd person (hence we don't skip sub123s).
			return true
		end
		if slot:find("^imp[123]") or slot:find("^negimp") then
			-- Skip all imperative slots, including third-person ones. Beware of impsub slots.
			return true
		end
	end
	if base.props.only3s and slot:find("3p") then
		-- Skip third plural slots for impersonal verbs.
		return true
	end
	return false
end


local function erase_suppressed_slots(base)
	for _, slot_spec in ipairs(all_verb_slots) do
		local slot, accel = unpack(slot_spec)
		if skip_slot(base, slot) then
			base.forms[slot] = nil
		end
	end
end


local function substitute_reflexive_pronoun(text, persnum)
	return rsub(text, "<(.-)>", function(refl)
		return substitutable_reflexive_pronoun[refl][persnum]
	end)
end


local function escape_reflexive_indicators(arg1)
	-- FIXME, broken and not yet used
	if not arg1:find("pron>") then
		return arg1
	end
	local segments = iut.parse_balanced_segment_run(arg1, "<", ">")
	-- Loop over every other segment. The even-numbered segments are angle-bracket specs while
	-- the odd-numbered segments are the text between them.
	for i = 2, #segments - 1, 2 do
		if segments[i] == "<pron>" then
			segments[i] = "⦃⦃pron⦄⦄"
		end
	end
	return table.concat(segments)
end


local function undo_escape_form(form)
	-- FIXME, broken and not yet used
	return rsub(rsub(form, "⦃⦃", "<"), "⦄⦄", ">")
end


local function remove_reflexive_indicators(form)
	-- FIXME, broken and not yet used
	return rsub(form, "⦃⦃.-⦄⦄", "")
end


local function replace_reflexive_indicators(slot, form)
	-- FIXME, broken and not yet used
	if not form:find("⦃") then
		return form
	end
	error("Internal error: replace_reflexive_indicators not implemented yet")
end


-- Add the `stem` to the `ending` for the given `slot` and apply any phonetic modifications.
local function combine_stem_ending(base, slot, stem, ending)
	-- Add h after c/g in -are forms to preserve the sound.
	if base.conj_vowel == "à" and stem:find("[cg]$") and rfind(ending, "^[eèéiì]") then
		stem = stem .. "h"
	end

	-- Two unstressed i's coming together compress to one.
	if ending:find("^i") then
		stem = rsub(stem, "i$", "")
	end

	-- Remove accents from stem if ending is accented.
	if rfind(ending, AV) then
		stem = remove_accents(stem)
	end

	return stem .. ending
end


local function add(base, slot, stems, endings, allow_overrides)
	--if skip_slot(base, slot, allow_overrides) then
	--	return
	--end
	local function do_combine_stem_ending(stem, ending)
		return combine_stem_ending(base, slot, stem, ending)
	end
	iut.add_forms(base.forms, slot, stems, endings, do_combine_stem_ending)
end


local function insert_form(base, slot, form)
	--if not skip_slot(base, slot) then
		iut.insert_form(base.forms, slot, form)
	--end
end


local function insert_forms(base, slot, forms)
	--if not skip_slot(base, slot) then
		iut.insert_forms(base.forms, slot, forms)
	--end
end


local function copy_forms(base, slot, forms)
	-- FIXME, is this needed? This is the same as insert_forms() but clones `forms`.
	-- Probably not needed as I don't think we ever side-effect existing forms.
	insert_forms(base, slot, iut.map_forms(forms, iut.identity))
end


local function general_list_form_contains_form(list, form, process_form)
	if not list then
		-- general_list_form_contains_form() is used to determine whether the defaults in `list` contain a given form; if not, that
		-- row is irregular. If there are no defaults, any form is irregular.
		return false
	end
	for _, formobj in ipairs(list) do
		local formobj_form = formobj.form
		if process_form then
			formobj_form = process_form(formobj_form)
		end
		if formobj_form == form then
			return true
		end
	end
	return false
end


local function process_specs(base, destforms, slot, specs, special_case)
	specs = specs or {{form = "+"}}
	for _, spec in ipairs(specs) do
		local decorated_form = spec.form
		-- Skip "-"; effectively, no forms get inserted into destforms[slot].
		if decorated_form ~= "-" then
			local prespec, form, syntactic_gemination =
				rmatch(decorated_form, "^([*!#]*)(.-)(%**)$")
			local forms = special_case(base, form)
			-- If `special_case` return nil, no forms get inserted into destforms[slot]. This happens e.g. when
			-- fut:- is given and no explicit conditional principal part is given. In that case,
			-- generate_default_conditional_principal_part() fetches the future principal parts, which don't exist,
			-- so it returns nil, and the surrounding principal_part_special_case() also returns nil. The effect is
			-- that the conditional principal part ends up nil and no conditional parts get inserted.
			if forms then
				forms = iut.convert_to_general_list_form(forms, spec.footnotes)
				if base.all_footnotes then
					forms = iut.convert_to_general_list_form(forms, base.all_footnotes)
				end
				for _, formobj in ipairs(forms) do
					local qualifiers = formobj.footnotes
					local form = formobj.form
					if prespec:find("!!") then
						qualifiers = iut.combine_footnotes({"[elevated style]"}, qualifiers)
						prespec = rsub(prespec, "!!", "")
					end
					if prespec:find("!") then
						qualifiers = iut.combine_footnotes({"[careful style]"}, qualifiers)
						prespec = rsub(prespec, "!", "")
					end
					if prespec:find("#") then
						qualifiers = iut.combine_footnotes({"[traditional]"}, qualifiers)
						prespec = rsub(prespec, "#", "")
					end
					local preserve_monosyllabic_accent
					if prespec:find("%*") then
						preserve_monosyllabic_accent = true
						prespec = rsub(prespec, "%*", "")
					end
					local unaccented_form
					if preserve_monosyllabic_accent and rfind(form, "^" .. NMAV .. "*" .. AV .. "$")  then
						-- final accented vowel without preceding vowel, and "*" before form; add PRESERVE_ACCENT
						form = PRESERVE_ACCENT .. form
					end
					if syntactic_gemination == "*" then
						qualifiers = iut.combine_footnotes(qualifiers, {"[with following syntactic gemination]"})
					elseif syntactic_gemination == "**" then
						qualifiers = iut.combine_footnotes(qualifiers, {"[with optional following syntactic gemination]"})
					elseif syntactic_gemination ~= "" then
						error("Decorated form '" .. decorated_form .. "' has too many asterisks after it, use '*' for syntactic gemination and '**' for optional syntactic gemination")
					end
					iut.insert_form(destforms, slot, {form = form, footnotes = qualifiers})
				end
			end
		end
	end
end


local function set_up_base_verb(base)
	local ret = base.verb
	local raw_verb = ret.raw_verb

	if rfind(raw_verb, "r$") then
		if rfind(raw_verb, "[ou]r$") or base.props.rre then
			ret.verb = raw_verb .. "re"
		else
			ret.verb = raw_verb .. "e"
		end
	else
		ret.verb = raw_verb
	end
end


local function add_default_verb_forms(base, from_headword)
	local ret = base.verb

	ret.default_stem, ret.default_ending_vowel = rmatch(base.verb.verb, "^(.-)([aeir])re$")
	if not ret.default_stem then
		error("Unrecognized verb '" .. base.verb.verb .. "', doesn't end in -are, -ere, -ire or -rre")
	end
	base.props.syncopated = base.props.rre or ret.default_ending_vowel == "r"

	local ending_vowel
	if base.principal_part_specs.explicit_stem_spec then
		local function explicit_stem_special_case(base, form)
			local stem, this_ending_vowel
			if form == "+" then
				stem = ret.default_stem
				this_ending_vowel = ret.default_ending_vowel
				if base.props.syncopated then
					error("Can't use + with 'stem:' in syncopated verbs; specify an explicit stem")
				end
			else
				base.explicit_non_default_stem_spec = true
				stem, this_ending_vowel = rmatch(form, "^(.*)([aei])$")
				if not stem then
					error("Unrecognized stem '" .. form .. "', should end in -a, -e or -i")
				end
			end
			if ending_vowel and ending_vowel ~= this_ending_vowel then
				error("Can't currently specify explicit stems with two different conjugation vowels (" .. ending_vowel
					.. " and " .. this_ending_vowel .. ")")
			end
			ending_vowel = this_ending_vowel
			return stem
		end
		-- Put the explicit stem in ret.stem (i.e. base.verb.stem).
		process_specs(base, ret, "stem", base.principal_part_specs.explicit_stem_spec, explicit_stem_special_case)
	else
		if base.props.syncopated then
			if not from_headword then
				error("With syncopated verb '" .. ret.verb .. "', must use 'stem:' to specify an explicit stem")
			else
				ret.default_ending_vowel = "e"
			end
		end
		-- Convert to general list form so we can call iut.map_forms() over it.
		ret.stem = iut.convert_to_general_list_form(ret.default_stem)
		ending_vowel = ret.default_ending_vowel
	end

	base.conj_vowel = ending_vowel == "a" and "à" or ending_vowel == "e" and "é" or "ì"

	if base.props.syncopated and not base.principal_part_specs.explicit_stem_spec then
		-- Can't generate defaults for verbs in -rre; currently we only can get here if from_headword.
		return
	end

	ret.unaccented_stem = iut.map_forms(ret.stem, function(stem) return remove_accents(stem) end)
	ret.pres = iut.map_forms(ret.stem, function(stem)
		if base.third then
			return ending_vowel == "a" and stem .. "a" or stem .. "e"
		else
			return stem .. "o"
		end
	end)
	ret.pres3s = iut.map_forms(ret.stem, function(stem) return ending_vowel == "a" and stem .. "a" or stem .. "e" end)
	if ending_vowel == "i" then
		ret.isc_pres = iut.map_forms(ret.unaccented_stem, function(stem) return stem .. "ìsco" end)
		ret.isc_pres3s = iut.map_forms(ret.unaccented_stem, function(stem) return stem .. "ìsci" end)
	end
	ret.phis = iut.flatmap_forms(ret.unaccented_stem, function(stem)
		if ending_vowel == "a" then
			return {stem .. (base.third and "ò" or "ài")}
		elseif ending_vowel == "e" then
			return {stem .. (base.third and "é" or "éi"), stem .. (base.third and "étte" or "étti")}
		else
			return {stem .. (base.third and "ì" or "ìi")}
		end
	end)
	ret.pp = iut.map_forms(ret.unaccented_stem, function(stem)
		if ending_vowel == "a" then
			return stem .. "àto"
		elseif ending_vowel == "e" then
			return rfind(stem, "[cg]$") and stem .. "iùto" or stem .. "ùto"
		else
			return stem .. "ìto"
		end
	end)
end


local function is_single_vowel_spec(spec)
	return rfind(spec, "^" .. AV .. "[+-]?$") or rfind(spec, "^" .. AV .. "%-%-$")
end


-- Given an unaccented stem, pull out the last two vowels as well as the in-between stuff, and return
-- before, v1, between, v2, after as 5 return values. `unaccented` is the full verb and `unaccented_desc`
-- a description of where the verb came from; used only in error messages.
local function analyze_stem_for_last_two_vowels(unaccented_stem, unaccented, unaccented_desc)
	local before, v1, between, v2, after = rmatch(unaccented_stem, "^(.*)(" .. V .. ")(" .. NV .. "*)(" .. V .. ")(" .. NV .. "*)$")
	if not before then
		before, v1 = "", ""
		between, v2, after = rmatch(unaccented_stem, "^(.*)(" .. V .. ")(" .. NV .. "*)$")
	end
	if not between then
		error("No vowel in " .. unaccented_desc .. " '" .. unaccented .. "' to match")
	end
	return before, v1, between, v2, after
end


-- Apply a single-vowel spec in `form`, e.g. é+, to `unaccented_stem`. `unaccented` is the full verb and
-- `unaccented_desc` a description of where the verb came from; used only in error messages.
local function apply_vowel_spec(unaccented_stem, unaccented, unaccented_desc, vowel_spec)
	local function vowel_spec_doesnt_match()
		error("Vowel spec '" .. vowel_spec .. "' doesn't match vowel of " .. unaccented_desc .. " '" .. unaccented .. "'")
	end
	local raw_spec_vowel = usub(unfd(vowel_spec), 1, 1)
	local form
	local spec_vowel = rmatch(vowel_spec, "^(.)%-%-$")
	if spec_vowel then -- a spec like ò--
		local before, v1, between1, v2, between2, v3, after = rmatch(unaccented_stem,
			"^(.*)(" .. V .. ")(" .. NV .. "*)(" .. V .. ")(" .. NV .. "*)(" .. V .. ")(" .. NV .. "*)$")
		if not before then
			error(mw.getContentLanguage():ucfirst(unaccented_desc) .. " '" .. unaccented ..
				"' must have at least three vowels to use the vowel spec '" ..  vowel_spec .. "'")
		end
		if raw_spec_vowel ~= v1 then
			vowel_spec_doesnt_match()
		end
		form = before .. spec_vowel .. between1 .. v2 .. between2 .. v3 .. after
	else
		local before, v1, between, v2, after = analyze_stem_for_last_two_vowels(unaccented_stem, unaccented, unaccented_desc)
		if v1 == v2 then
			local first_second
			spec_vowel, first_second = rmatch(vowel_spec, "^(.)([+-])$")
			if not spec_vowel then
				error("Last two stem vowels of " .. unaccented_desc .. " '" .. unaccented ..
					"' are the same; you must specify + (second vowel) or - (first vowel) after the vowel spec '" ..
					vowel_spec .. "'")
			end
			if raw_spec_vowel ~= v1 then
				vowel_spec_doesnt_match()
			end
			if first_second == "-" then
				form = before .. spec_vowel .. between .. v2 .. after
			else
				form = before .. v1 .. between .. spec_vowel .. after
			end
		else
			if rfind(vowel_spec, "[+-]$") then
				error("Last two stem vowels of " .. unaccented_desc .. " '" .. unaccented ..
					"' are different; specify just an accented vowel, without a following + or -: '" .. vowel_spec .. "'")
			end
			if raw_spec_vowel == v1 then
				form = before .. vowel_spec .. between .. v2 .. after
			elseif raw_spec_vowel == v2 then
				form = before .. v1 .. between .. vowel_spec .. after
			elseif before == "" then
				vowel_spec_doesnt_match()
			else
				error("Vowel spec '" .. vowel_spec .. "' doesn't match either of the last two vowels of " .. unaccented_desc ..
					" '" .. unaccented .. "'")
			end
		end
	end
	return form
end


local function add_finite_reflexive_clitics(base, rowslot)
	for _, persnum in ipairs(full_person_number_list) do
		base.forms[rowslot .. persnum] = iut.map_forms(base.forms[rowslot .. persnum], function(form)
			return substitute_reflexive_pronoun(base.verb.finite_pref, persnum) .. "[[" .. form .. "]]"
		end)
	end
end


local function do_ending_stressed_inf(base)
	if rfind(base.verb.verb, "rre$") then
		error("Use \\ not / with -rre verbs")
	end
	-- Add acute accent to -ere, grave accent to -are/-ire.
	local accented = rsub(base.verb.verb, "ere$", "ére")
	accented = unfc(rsub(accented, "([ai])re$", "%1" .. GR .. "re"))
	iut.insert_form(base.forms, "inf", {form = accented})
end


local function do_root_stressed_inf(base, specs)
	local function root_stressed_inf_special_case(base, spec, form_to_do, from_defaulted_pres)
		if spec == "-" then
			error("Spec '-' not allowed as root-stressed infinitive spec")
		end
		if spec == "+" then
			local rre_vowel = rmatch(base.verb.verb, "([aiu])rre$")
			if rre_vowel then
				-- do_root_stressed_inf is used for verbs in -ere and -rre. If the root-stressed vowel isn't explicitly
				-- given and the verb ends in -arre, -irre or -urre, derive it from the infinitive since there's only
				-- one possibility. If the verb ends in -erre or -orre, this won't work because we have both scérre
				-- (= [[scegliere]]) and disvèrre (= [[disvellere]]), as well as pórre and tòrre (= [[togliere]]).
				local before, v1, between, v2, after = analyze_stem_for_last_two_vowels(
					rsub(base.verb.verb, "re$", ""), base.verb.verb, "root-stressed infinitive")
				local vowel_spec = unfc(rre_vowel .. GR)
				if v1 == v2 then
					vowel_spec = vowel_spec .. "+"
				end
				spec = vowel_spec
			else
				-- Use the single-vowel spec(s) in the present tense principal part.
				local temp = {}
				process_specs(base, temp, "temp", base.principal_part_specs.pres, function(base, form)
					return root_stressed_inf_special_case(base, form, form_to_do, "from defaulted pres") end)
				return temp.temp
			end
		end
		local verb_stem, verb_suffix = rmatch(base.verb.verb, "^(.-)([er]re)$")
		if not verb_stem then
			error("Verb '" .. base.verb.verb .. "' must end in -ere or -rre to use \\ notation")
		end
		if not is_single_vowel_spec(spec) then
			if from_defaulted_pres then
				error("When defaulting root-stressed infinitive vowel to present, present spec must be a single-vowel spec, but saw '"
					.. spec .. "'")
			else
				error("Explicit root-stressed infinitive spec '" .. spec .. "' should be a single-vowel spec")
			end
		end

		local expanded = apply_vowel_spec(verb_stem, base.verb.verb, "root-stressed infinitive", spec)
		if form_to_do == "stem" then
			return expanded
		else
			return expanded .. verb_suffix
		end
	end

	process_specs(base, base.principal_part_forms, "root_stressed_stem", specs, function(base, form)
		return root_stressed_inf_special_case(base, form, "stem") end)
	process_specs(base, base.forms, "inf", specs, function(base, form)
		return root_stressed_inf_special_case(base, form, "inf") end)
end


local function add_infinitive(base, rowslot)
	-- When do_root_stressed_inf is called, this also sets base.principal_part_forms.root_stressed_stem, which is needed
	-- by add_present_indic(), so we have to do this before conjugating the present indicative.
	if base.principal_part_specs.root_stressed_inf then
		do_root_stressed_inf(base, base.principal_part_specs.root_stressed_inf)
	else
		do_ending_stressed_inf(base)
	end
end


local function add_infinitive_reflexive_clitics(base, rowslot)
	base.forms[rowslot] = iut.map_forms(base.forms[rowslot], function(form)
		local unaccented_form = remove_accents(form)
		form = rsub(form, "r?re$", "r")
		return "[[" .. unaccented_form .. "|" .. form .. "]]" .. substitute_reflexive_pronoun(base.verb.linked_suf, "nf")
	end)
end


local function pres_special_case(base, form)
	local principal_part_desc = "first-singular present indicative"
	if form == "+" then
		check_not_null(base, base.verb.pres, form, principal_part_desc)
		return base.verb.pres
	elseif form == "+isc" then
		check_not_null(base, base.verb.isc_pres, form, principal_part_desc)
		return base.verb.isc_pres
	elseif is_single_vowel_spec(form) then
		check_not_null(base, base.verb.pres, form, principal_part_desc)
		return iut.map_forms(base.verb.pres, function(defform)
			local pres, final_vowel = rmatch(defform, "^(.*)([oae])$")
			if not pres then
				error("Internal error: Default present '" .. defform .. "' doesn't end in -o, -a or -e")
			end
			return apply_vowel_spec(pres, defform, "default present", form) .. final_vowel
		end)
	elseif not base.third and not rfind(form, "[oò]$") then
		error("Present first-person singular form '" .. form .. "' should end in -o")
	elseif base.third and not rfind(form, "[aàeè]") then
		error("Present third-person singular form '" .. form .. "' should end in -a or -e")
	else
		local unaccented_form = remove_accents(form)
		if not general_list_form_contains_form(base.verb.pres, unaccented_form, remove_accents)
			and (base.verb.isc_pres and not general_list_form_contains_form(base.verb.isc_pres, unaccented_form, remove_accents)) then
			base.is_irreg.pres = true
		end
		return form
	end
end


local function pres3s_special_case(base, form)
	local principal_part_desc = "third-singular present indicative"
	if form == "+" then
		check_not_null(base, base.verb.pres3s, form, principal_part_desc)
		return base.verb.pres3s
	elseif form == "+isc" then
		check_not_null(base, base.verb.isc_pres3s, form, principal_part_desc)
		return base.verb.isc_pres3s
	elseif is_single_vowel_spec(form) then
		check_not_null(base, base.verb.pres3s, form, principal_part_desc)
		return iut.map_forms(base.verb.pres3s, function(defform)
			local pres3s, final_vowel = rmatch(defform, "^(.*)([ae])$")
			if not pres3s then
				error("Internal error: Default third-person singular present '" .. defform .. "' doesn't end in -a or -e")
			end
			return apply_vowel_spec(pres3s, defform, "default third-person singular present", form) .. final_vowel
		end)
	elseif not rfind(form, "[aàeè]") then
		error("Present third-person singular form '" .. form .. "' should end in -a or -e")
	else
		local unaccented_form = remove_accents(form)
		if not general_list_form_contains_form(base.verb.pres3s, unaccented_form, remove_accents)
			and (base.verb.isc_pres3s and not general_list_form_contains_form(base.verb.isc_pres3s, unaccented_form, remove_accents)) then
			base.is_irreg.pres = true
		end
		return form
	end
end


-- Generate the present indicative. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
local function add_present_indic(base, rowslot)
	process_specs(base, base.principal_part_forms, "pres", base.principal_part_specs.pres, pres_special_case)
	if base.principal_part_specs.pres3s then
		process_specs(base, base.principal_part_forms, "pres3s", base.principal_part_specs.pres3s, pres3s_special_case)
	end

	local function addit(pers, stems, endings)
		add(base, rowslot .. pers, stems, endings)
	end

	addit("1s", base.principal_part_forms.pres, "")
	local pres1s_stem = iut.map_forms(base.principal_part_forms.pres, function(form)
		if not form:find("o$") then
			error("presrow: must be given in order to generate the present indicative because explicit first-person "
				.. "singular present indicative '" .. form .. "' does not end in -o")
		end
		return rsub(form, "o$", "")
	end)
	addit("3p", pres1s_stem, base.conj_vowel == "à" and "ano" or "ono")
	local pres23s_stem
	if base.principal_part_forms.pres3s then
		pres23s_stem = iut.map_forms(base.principal_part_forms.pres3s, function(form)
			if not form:find("[ae]$") then
				error("presrow: must be given in order to generate the present indicative because explicit third-person "
					.. "singular present indicative '" .. form .. "' does not end in -a or -e")
			end
			return rsub(form, "[ae]$", "")
		end)
	else
		pres23s_stem = base.explicit_non_default_stem_spec and base.verb.stem
			or base.principal_part_forms.root_stressed_stem or pres1s_stem
	end
	addit("2s", pres23s_stem, "i")
	addit("3s", pres23s_stem, base.conj_vowel == "à" and "a" or "e")
	addit("1p", base.verb.unaccented_stem, "iàmo")
	addit("2p", base.verb.unaccented_stem, base.conj_vowel .. "te")
end


local function generate_default_present_subj_principal_part(base, do_err)
	return iut.flatmap_forms(base.forms.pres1s, function(form)
		if not form:find("o$") then
			if do_err then
				error("sub: or subrow: must be given in order to generate the singular present subjunctive "
					.. "because first-person singular present indicative '" .. form .. "' does not end in -o")
			else
				return {}
			end
		else
			-- Need to call combine_stem_ending() here to handle verbs in -care/-gare and -ciare/-giare.
			return {combine_stem_ending(base, "sub123s", rsub(form, "o$", ""), base.conj_vowel == "à" and "i" or "a")}
		end
	end)
end


-- Generate the present subjunctive. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
local function add_present_subj(base, rowslot)
	local function addit(pers, stems, endings)
		add(base, rowslot .. pers, stems, endings)
	end
	local function insit(pers, forms)
		insert_forms(base, rowslot .. pers, forms)
	end

	-- Generate the 123s and 3p forms.
	addit("123s", base.principal_part_forms.sub, "")
	addit("3p", base.principal_part_forms.sub, "no")
	-- Copy present indicative 1p to present subjunctive.
	copy_forms(base, rowslot .. "1p", base.forms.pres1p)
	-- Generate present subjunctive 2p from present indicative 1p by replacing -mo with -te.
	insit("2p", iut.map_forms(base.forms.pres1p, function(form)
		if not form:find("mo$") then
			error("subrow: must be given in order to generate the second-person plural present subjunctive "
				.. "because first-person plural present indicative '" .. form .. "' does not end in -mo")
		end
		return rsub(form, "mo$", "te")
	end))
end


local function postprocess_present_subj_after_row_overrides(base, rowslot)
	local function copy(pers, forms)
		copy_forms(base, rowslot .. pers, forms)
	end

	-- Copy 123s to 1s, 2s and 3s. This happens between the row overrides and the single overrides.
	copy("1s", base.forms.sub123s)
	copy("2s", base.forms.sub123s)
	copy("3s", base.forms.sub123s)
end


local function generate_default_imperative_principal_part(base, do_err)
	if base.conj_vowel == "à" then
		-- Copy present indicative 3s to imperative 2s.
		return base.forms.pres3s
	else
		-- Copy present indicative 2s to imperative 2s.
		return base.forms.pres2s
	end
end


-- Generate the imperative. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
local function add_imperative(base, rowslot)
	local function copy(pers, forms)
		copy_forms(base, rowslot .. pers, forms)
	end

	if not base.principal_part_forms.imp then
		-- If imp:- given, suppress the whole imperative.
		return
	end
	-- Copy first imperative form (user specified or taken from present indicative 3s for conj vowel à, or from
	-- present indicative 2s for other conj vowels) to imperative 2s.
	copy("2s", base.principal_part_forms.imp)
	-- Copy present indicative 2p to imperative 2p.
	copy("2p", base.forms.pres2p)
	-- Copy present subjunctive 3s, 1p, 3p to imperative.
	copy("3s", base.forms.sub3s)
	copy("1p", base.forms.sub1p)
	copy("3p", base.forms.sub3p)
end


local function get_unlinked_clitic_suffix(base, persnum)
	return m_links.remove_links(substitute_reflexive_pronoun(base.verb.linked_suf, persnum))
end


local function add_imperative_reflexive_clitics(base, rowslot)
	local s2suf = get_unlinked_clitic_suffix(base, "2s")
	base.forms[rowslot .. "2s"] = iut.flatmap_forms(base.forms[rowslot .. "2s"], function(form)
		form = rsub(form, "'$", "") -- dà', fà', etc.
		if rfind(form, AV .. "$") then -- final stressed vowel; implement syntactic gemination
			if rfind(s2suf, "^gli") then
				return {form .. s2suf}
			else
				return {form .. usub(s2suf, 1, 1) .. s2suf}
			end
		elseif rfind(form, "ài$") then
			return {}
		else
			return {form .. s2suf}
		end
	end)
	for _, persnum in ipairs({"1p", "2p"}) do
		local suf = get_unlinked_clitic_suffix(base, persnum)
		base.forms[rowslot .. persnum] = iut.map_forms(base.forms[rowslot .. persnum], function(form)
			return form .. suf
		end)
	end
	for _, persnum in ipairs({"3s", "3p"}) do
		base.forms[rowslot .. persnum] = iut.map_forms(base.forms[rowslot .. persnum], function(form)
			return substitute_reflexive_pronoun(base.verb.finite_pref, persnum) .. "[[" .. form .. "]]"
		end)
	end
end


local function add_negative_imperative(base)
	if not base.principal_part_forms.imp then
		-- If imp:- given, suppress the whole imperative.
		return
	end
	for _, persnum in ipairs({"2s", "3s", "1p", "2p", "3p"}) do
		local from = persnum == "2s" and "inf" or "imp" .. persnum
		insert_forms(base, "negimp" .. persnum, iut.map_forms(base.forms[from], function(form)
			return "[[non]] [[" .. form .. "]]"
		end))
	end
end


local function add_negative_imperative_reflexive_clitics(base, rowslot)
	for _, persnum in ipairs({"2s", "1p", "2p"}) do
		local suf = get_unlinked_clitic_suffix(base, persnum)
		local pref = substitute_reflexive_pronoun(base.verb.finite_pref, persnum)
		base.forms[rowslot .. persnum] = iut.flatmap_forms(base.forms[rowslot .. persnum], function(form)
			local truncated = persnum == "2s" and rsub(form, "r?re%]%]$", "r") or rsub(form, "%]%]$", "")
			local sufform = truncated .. suf .. "]]"
			local prefform = rsub(form, "^(%[%[non%]%]) (.*)$", "%1 " .. pref .. " %2")
			return {sufform, prefform}
		end)
	end
	for _, persnum in ipairs({"3s", "3p"}) do
		local pref = substitute_reflexive_pronoun(base.verb.finite_pref, persnum)
		base.forms[rowslot .. persnum] = iut.map_forms(base.forms[rowslot .. persnum], function(form)
			return rsub(form, "^(%[%[non%]%]) (.*)$", "%1 " .. pref .. " %2")
		end)
	end
end


local function generate_default_past_historic_principal_part(base, do_err)
	if do_err then
		check_not_null(base, base.verb.phis, "+", "first-singular past historic")
	end
	return base.verb.phis
end


local function add_past_historic(base, rowslot)
	if not base.principal_part_forms.phis then
		-- specified as "-"
		return
	end
	for _, form in ipairs(base.principal_part_forms.phis) do
		local function add_phis(pref, s1, s2, s3, p1, p2, p3)
			local newform = form.footnotes and iut.convert_to_general_list_form(pref, form.footnotes) or pref
			local function addit(pers, endings)
				add(base, rowslot .. pers, newform, endings)
			end
			addit("1s", s1)
			addit("2s", s2)
			addit("3s", s3)
			addit("1p", p1)
			addit("2p", p2)
			addit("3p", p3)
		end
		while true do
			local pref = rmatch(form.form, "^(.*)ài$")
			if pref then
				add_phis(pref, "ài", "àsti", "ò", "àmmo", "àste", "àrono")
				break
			end
			pref = rmatch(form.form, "^(.*)éi$")
			if pref then
				add_phis(pref, "éi", "ésti", "é", "émmo", "éste", "érono")
				break
			end
			pref = rmatch(form.form, "^(.*)[èé]tti$")
			if pref then
				add_phis(pref, {{form = "étti"}, {form = "ètti", footnotes = {"[traditional]"}}},
					"ésti", {{form = "étte"}, {form = "ètte", footnotes = {"[traditional]"}}},
					"émmo", "éste", {{form = "éttero"}, {form = "èttero", footnotes = {"[traditional]"}}})
				break
			end
			pref = rmatch(form.form, "^(.*)ìi$")
			if pref then
				add_phis(pref, "ìi", "ìsti", "ì", "ìmmo", "ìste", "ìrono")
				break
			end
			pref = rmatch(form.form, "^(.*)i$")
			if pref then
				add_phis(pref, "i", {}, "e", {}, {}, "ero")
				add_phis(base.verb.stem, {}, base.conj_vowel .. "sti", {}, base.conj_vowel .. "mmo",
					base.conj_vowel .. "ste", {})
				break
			end
			error("phisrow: must be given in order to generate the past historic because explicit first-person "
				.. "singular past historic '" .. form.form .. "' does not end in -i")
		end
	end
end


local function generate_default_future_principal_part(base, do_err)
	-- FIXME, when we're sure we won't ever be called with a different suffix, inline the suffix.
	local suffix = "ò"
	if base.conj_vowel == "à" then
		return iut.map_forms(base.verb.unaccented_stem, function(stem)
			if stem:find("[cg]$") then
				return stem .. "her" .. suffix
			elseif stem:find("[cg]i$") then
				return rsub(stem, "i$", "er") .. suffix
			else
				return stem .. "er" .. suffix
			end
		end)
	else
		return rsub(base.verb.verb, "e$", suffix)
	end
end


local function generate_default_conditional_principal_part(base, do_err)
	-- If fut:- is given, base.principal_part_forms.fut will be nil, and the following will correctly return nil,
	-- so that there's no conditional.
	return iut.map_forms(base.principal_part_forms.fut, function(form)
		local pref = rmatch(form, "^(.*)ò$")
		if not pref then
			-- This should have been caught earlier (when processing the future) and generated an error.
			error(("Internal error: When generating conditional, saw principal part for future '%s' that does not end in -ò")
				:format(form))
		end
		return pref .. "éi"
	end)
end


local function postprocess_imperfect_subj_after_row_overrides(base, rowslot)
	local function copy(pers, forms)
		copy_forms(base, rowslot .. pers, forms)
	end

	-- Copy 12s to 1s and 2s. This happens between the row overrides and the single overrides.
	copy("1s", base.forms.impsub12s)
	copy("2s", base.forms.impsub12s)
end


local function add_participle_reflexive_clitics(base, rowslot)
	-- do nothing
end


local function generate_default_past_participle_principal_part(base, do_err)
	if do_err then
		check_not_null(base, base.verb.pp, "+", "first-singular past historic")
	end
	return base.verb.pp
end


local function generate_default_gerund_principal_part(base, do_err)
	return iut.map_forms(base.verb.unaccented_stem, function(stem)
		return stem .. (base.conj_vowel == "à" and "àndo" or "èndo")
	end)
end


local function add_gerund_reflexive_clitics(base, rowslot)
	base.forms[rowslot] = iut.map_forms(base.forms[rowslot], function(form)
		return form .. get_unlinked_clitic_suffix(base, "nf")
	end)
end


local function generate_default_present_participle_principal_part(base, do_err)
	return iut.map_forms(base.verb.unaccented_stem, function(stem)
		return stem .. (base.conj_vowel == "à" and "ànte" or "ènte")
	end)
end


--[=[
Data on how to conjugate individual rows (i.e. tense/aspect combinations, such as present indicative or
conditional).

The order listed here matters. It determines the order of generating row forms. The order must have
'inf' < 'pres' < 'sub' < 'imp' < 'negimp' because the present indicative uses the root_stressed_stem generated
by add_infinitive; the present subjunctive uses generated forms from the present indicative; the imperative uses
forms from the present subjunctive and present indicative; and the negative imperative uses forms from the infinitive
and the imperative. Similarly we must have 'fut' < 'cond' because the conditional uses the future principal part.
]=]
local row_conjugation = {
	{"inf", {
		desc = "infinitive",
		tag_suffix = "inf",
		persnums = {""},
		-- No generate_default_principal_part; handled specially in add_infinitive.
		conjugate = add_infinitive,
		no_explicit_principal_part = true, -- because handled specially using / or \ notation
		no_row_overrides = true, -- useless because there's only one form; use / or \ notation
		no_single_overrides = true, --useless because there's only one form; use / or \ notation
		add_reflexive_clitics = add_infinitive_reflexive_clitics,
	}},
	{"pres", {
		desc = "present",
		tag_suffix = "pres|ind",
		persnums = full_person_number_list,
		-- No generate_default_principal_part; handled specially in add_present_indic because we actually have
		-- two principal parts for the present indicative ("pres" and "pres3s").
		conjugate = add_present_indic,
		no_explicit_principal_part = true, -- because handled specially in PRES^PRES3S,PHIS,PP spec
		add_reflexive_clitics = add_finite_reflexive_clitics,
	}},
	{"sub", {
		desc = "present subjunctive",
		tag_suffix = "pres|sub",
		persnums = full_person_number_list,
		row_override_persnums = {"123s", "1p", "2p", "3p"},
		generate_default_principal_part = generate_default_present_subj_principal_part,
		conjugate = add_present_subj,
		-- This copies 123s to 1s/2s/3s
		postprocess_after_row_overrides = postprocess_present_subj_after_row_overrides,
		add_reflexive_clitics = add_finite_reflexive_clitics,
	}},
	{"imp", {
		desc = "imperative",
		tag_suffix = "imp",
		persnums = imp_person_number_list,
		row_override_persnums = {"2s", "2p"},
		generate_default_principal_part = generate_default_imperative_principal_part,
		conjugate = add_imperative,
		add_reflexive_clitics = add_imperative_reflexive_clitics,
	}},
	{"negimp", {
		desc = "negative imperative",
		tag_suffix = "-",
		persnums = imp_person_number_list,
		-- No generate_default_principal_part because all parts are copied from other parts.
		conjugate = add_negative_imperative,
		add_reflexive_clitics = add_negative_imperative_reflexive_clitics,
		no_explicit_principal_part = true, -- because all parts are copied from other parts
		no_row_overrides = true, -- not useful; use single overrides if really needed
		dont_check_defective_status = true, -- we don't want a category for this
	}},
	{"phis", {
		desc = "past historic",
		tag_suffix = "phis",
		persnums = full_person_number_list,
		generate_default_principal_part = generate_default_past_historic_principal_part,
		conjugate = add_past_historic,
		add_reflexive_clitics = add_finite_reflexive_clitics,
		no_explicit_principal_part = "builtin", -- because handled specially in PRES^PRES3S,PHIS,PP spec
	}},
	{"imperf", {
		desc = "imperfect",
		tag_suffix = "impf|ind",
		persnums = full_person_number_list,
		generate_default_principal_part = function(base) return iut.map_forms(base.verb.unaccented_stem,
			function(stem) return stem .. base.conj_vowel .. "vo" end) end,
		principal_part_desc = "first-person imperfect",
		principal_part_ending = "o",
		conjugate = {"o", "i", "a", "àmo", "àte", "ano"},
		add_reflexive_clitics = add_finite_reflexive_clitics,
	}},
	{"impsub", {
		desc = "imperfect subjunctive",
		tag_suffix = "impf|sub",
		persnums = full_person_number_list,
		row_override_persnums = {"12s", "3s", "1p", "2p", "3p"},
		generate_default_principal_part = function(base) return iut.map_forms(base.verb.unaccented_stem,
			function(stem) return stem .. base.conj_vowel .. "ssi" end) end,
		principal_part_desc = "first/second-person imperfect subjunctive",
		principal_part_ending = "ssi",
		conjugate = {"ssi", "sse", "ssimo", "ste", "ssero"},
		-- This copies 12s to 1s/2s
		postprocess_after_row_overrides = postprocess_imperfect_subj_after_row_overrides,
		add_reflexive_clitics = add_finite_reflexive_clitics,
	}},
	{"fut", {
		desc = "future",
		tag_suffix = "fut",
		persnums = full_person_number_list,
		generate_default_principal_part = generate_default_future_principal_part,
		principal_part_desc = "first-person future",
		principal_part_ending = "ò",
		conjugate = {"ò", "ài", "à", "émo", "éte", "ànno"},
		add_reflexive_clitics = add_finite_reflexive_clitics,
	}},
	{"cond", {
		desc = "conditional",
		tag_suffix = "cond",
		persnums = full_person_number_list,
		generate_default_principal_part = generate_default_conditional_principal_part,
		principal_part_desc = "first-person conditional",
		principal_part_ending = "éi",
		conjugate = {"éi", "ésti", {"èbbe", "ébbe"}, "émmo", "éste", {"èbbero", "ébbero"}},
		add_reflexive_clitics = add_finite_reflexive_clitics,
	}},
	{"pp", {
		desc = "past participle",
		tag_suffix = "past|part",
		persnums = {""},
		generate_default_principal_part = generate_default_past_participle_principal_part,
		principal_part_desc = "past participle",
		principal_part_ending = "",
		conjugate = {""},
		add_reflexive_clitics = add_participle_reflexive_clitics,
		no_explicit_principal_part = "builtin", -- because handled specially in PRES^PRES3S,PHIS,PP spec
		no_row_overrides = true, -- useless because there's only one form; use the PRES^PRES3S,PHIS,PP spec
		no_single_overrides = true, --useless because there's only one form; use the PRES^PRES3S,PHIS,PP spec
	}},
	{"ger", {
		desc = "gerund",
		tag_suffix = "ger",
		persnums = {""},
		generate_default_principal_part = generate_default_gerund_principal_part,
		principal_part_desc = "gerund",
		principal_part_ending = "",
		conjugate = {""},
		add_reflexive_clitics = add_gerund_reflexive_clitics,
		no_row_overrides = true, -- useless because there's only one form; use explicit principal part
		no_single_overrides = true, -- useless because there's only one form; use explicit principal part
	}},
	{"presp", {
		desc = "present participle",
		tag_suffix = "pres|part",
		persnums = {""},
		generate_default_principal_part = generate_default_present_participle_principal_part,
		principal_part_desc = "present participle",
		principal_part_ending = "",
		conjugate = {""},
		add_reflexive_clitics = add_participle_reflexive_clitics,
		no_row_overrides = true, -- useless because there's only one form; use explicit principal part
		no_single_overrides = true, -- useless because there's only one form; use explicit principal part
		not_defaulted = true, -- not defaulted, user has to request it explicitly
		dont_check_defective_status = true, -- this is frequently missing and doesn't indicate a defective verb
	}},
}

local row_conjugation_map = {}

for _, spec in ipairs(row_conjugation) do
	local rowslot, rowconj = unpack(spec)
	row_conjugation_map[rowslot] = rowconj
end


local overridable_participle_slot_set = {}

local overridable_slot_set = m_table.shallowcopy(overridable_participle_slot_set)

-- Populate all_verb_slots and overridable_slot_set.
for _, spec in ipairs(row_conjugation) do
	local rowslot, rowconj = unpack(spec)
	for _, persnum in ipairs(rowconj.persnums) do
		local persnum_tag = person_number_tag_prefix[persnum]
		local slot = rowslot .. persnum
		if rowconj.tag_suffix == "-" then
			table.insert(all_verb_slots, {slot, "-"})
		else
			table.insert(all_verb_slots, {slot, persnum_tag .. rowconj.tag_suffix})
		end
		if not rowconj.no_single_overrides then
			overridable_slot_set[slot] = true
		end
	end
end

local function handle_row_overrides_for_row(base, row_slot)
	if base.row_override_specs[row_slot] then
		for persnum, specs in pairs(base.row_override_specs[row_slot]) do
			local slot = row_slot .. persnum
			local existing_generated_form = base.forms[slot]
			local function row_override_special_case(base, form)
				if form == "+" then
					if not existing_generated_form then
						error(("Default form '+' requested in row override '%s:' for slot %s but no default-generated form available; "
							.. "typically this means the principal part was given as '-'")
							:format(row_slot, slot))
					end
					return existing_generated_form
				end
				if not general_list_form_contains_form(existing_generated_form, form) then
					base.is_irreg[row_slot] = true
				end
				return form
			end
			base.forms[slot] = nil -- erase existing form before generating override
			process_specs(base, base.forms, slot, specs, row_override_special_case)
		end
	end
end


local function handle_single_overrides_for_row(base, row_slot)
	local rowspec = row_conjugation_map[row_slot]
	if not rowspec then
		error("Internal error: No row conjugation spec for " .. row_slot)
	end

	for _, persnum in ipairs(rowspec.persnums) do
		local slot = row_slot .. persnum
		if base.single_override_specs[slot] then
			local existing_generated_form = base.forms[slot]
			local function override_special_case(base, form)
				if form == "+" then
					if not existing_generated_form then
						error(("Default form '+' requested in override for slot %s but no default-generated form available; "
							.. "typically this means the principal part was given as '-'")
							:format(row_slot, slot))
					end
					return existing_generated_form
				end
				if not general_list_form_contains_form(existing_generated_form, form) then
					base.is_irreg[row_slot] = true
				end
				return form
			end
			base.forms[slot] = nil -- erase existing form before generating override
			process_specs(base, base.forms, slot, base.single_override_specs[slot], override_special_case)
		end
	end
end


local function conjugate_row(base, rowslot)
	add_default_verb_forms(base)
	local rowconj = row_conjugation_map[rowslot]
	if not rowconj then
		error("Internal error: Unrecognized row slot '" .. rowslot .. "'")
	end

	-- Generate the principal part for this row now if it has an entry for `generate_default_principal_part`.
	if rowconj.generate_default_principal_part then
		local function principal_part_special_case(base, form)
			local default_principal_part = rowconj.generate_default_principal_part(base, form == "+")
			if default_principal_part then
				-- There may be no default; e.g. if fut:- is given, the default conditional principal part is nil.
				-- process_specs() calls convert_to_general_list_form() on the output in any case and we need it in this form
				-- in order to call general_list_form_contains_form(), so we may as well convert it now.
				default_principal_part = iut.convert_to_general_list_form(default_principal_part)
			end
			if form == "+" then
				return default_principal_part
			end
			if not general_list_form_contains_form(default_principal_part, form) then
				base.is_irreg[rowslot] = true
			end
			return form
		end

		local principal_part_specs = base.principal_part_specs[rowslot] or rowconj.not_defaulted and {{form = "-"}}
			or {{form = "+"}}
		process_specs(base, base.principal_part_forms, rowslot, principal_part_specs, principal_part_special_case)
	end

	if type(rowconj.conjugate) == "table" then
		local persnums = rowconj.row_override_persnums or rowconj.persnums
		if #rowconj.conjugate ~= #persnums then
			error("Internal error: Expected " .. #persnums .. " elements for row slot '" .. rowslot
				.. ", but saw " .. #rowconj.conjugate)
		end
		local stem = iut.map_forms(base.principal_part_forms[rowslot], function(form)
			if not rfind(form, rowconj.principal_part_ending .. "$") then
				error(rowslot .. "row: must be given in order to generate the " .. rowconj.desc .. " because"
					.. "explicit " .. rowconj.principal_part_desc .. " '" .. form .. "' does not end in -"
					.. rowconj.principal_part_ending)
			end
			return rsub(form, rowconj.principal_part_ending .. "$", "")
		end)
		for i, persnum in ipairs(persnums) do
			add(base, rowslot .. persnum, stem, rowconj.conjugate[i])
		end
	else
		rowconj.conjugate(base, rowslot)
	end

	handle_row_overrides_for_row(base, rowslot)
	if rowconj.postprocess_after_row_overrides then
		rowconj.postprocess_after_row_overrides(base, rowslot)
	end
	handle_single_overrides_for_row(base, rowslot)
end


-- If a built-in verb was requested, add the verb's prefix to all forms.
local function add_prefix_to_forms(base)
	if base.verb.prefix and base.verb.prefix ~= "" then
		for slot, forms in pairs(base.forms) do
			for _, form in ipairs(forms) do
				form.form = base.verb.prefix .. form.form
			end
		end
	end
end


local function check_for_defective_rows(base)
	for _, rowspec in ipairs(row_conjugation) do
		local rowslot, rowconj = unpack(rowspec)
		if not rowconj.dont_check_defective_status then
			for i, persnum in ipairs(rowconj.persnums) do
				local slot = rowslot .. persnum
				if not base.forms[slot] and not skip_slot(base, slot) then
					base.is_defective[rowslot] = true
				end
			end
		end
	end
	if not base.principal_part_specs.aux and not base.verb.is_reflexive then
		base.is_defective.aux = true
	end
end


-- Any forms without links should get them now. Redundant ones will be stripped later.
local function add_missing_links_to_forms(base)
	for slot, forms in pairs(base.forms) do
		for _, form in ipairs(forms) do
			form.form = add_links(form.form)
		end
	end
end


local function remove_links_from_forms(base)
	-- Remove links from forms in case of noautolinkverb.
	for slot, forms in pairs(base.forms) do
		for _, form in ipairs(forms) do
			form.form = m_links.remove_links(form.form)
		end
	end
end


local function conjugate_verb(base)
	for _, rowspec in ipairs(row_conjugation) do
		local rowslot, rowconj = unpack(rowspec)
		conjugate_row(base, rowslot)
	end
	add_prefix_to_forms(base)
	if base.verb.linked_suf ~= "" then
		for _, rowspec in ipairs(row_conjugation) do
			local rowslot, rowconj = unpack(rowspec)
			rowconj.add_reflexive_clitics(base, rowslot)
		end
	end
	erase_suppressed_slots(base)
	check_for_defective_rows(base)
	if base.args.noautolinkverb then
		remove_links_from_forms(base)
	else
		add_missing_links_to_forms(base)
	end
end


local function analyze_verb(lemma)
	local is_pronominal = false
	local is_reflexive = false
	-- The particles that can go after a verb are:
	-- * la, le
	-- * ne
	-- * ci, vi (sometimes in the form ce, ve)
	-- * si (sometimes in the form se)
	-- Observed combinations:
	--   * ce + la: [[avercela]] "to be angry (at someone)", [[farcela]] "to make it, to succeed",
	--              [[mettercela tutta]] "to put everything (into something)"
	--   * se + la: [[sbrigarsela]] "to deal with", [[bersela]] "to naively believe in",
	--              [[sentirsela]] "to have the courage to face (a difficult situation)",
	--              [[spassarsela]] "to live it up", [[svignarsela]] "to scurry away",
	--              [[squagliarsela]] "to vamoose, to clear off", [[cercarsela]] "to be looking for (trouble etc.)",
	--              [[contarsela]] "to have a distortedly positive self-image; to chat at length",
	--              [[dormirsela]] "to be fast asleep", [[filarsela]] "to slip away, to scram",
	--              [[giostrarsela]] "to get away with; to turn a situation to one's advantage",
	--              [[cavarsela]] "to get away with; to get out of (trouble); to make the best of; to manage (to do); to be good at",
	--              [[meritarsela]] "to get one's comeuppance", [[passarsela]] "to fare (well, badly)",
	--              [[rifarsela]] "to take revenge", [[sbirbarsela]] "to slide by (in life)",
	--              [[farsela]]/[[intendersela]] "to have a secret affair or relationship with",
	--              [[farsela addosso]] "to shit oneself", [[prendersela]] "to take offense at; to blame",
	--              [[prendersela comoda]] "to take one's time", [[sbrigarsela]] "to finish up; to get out of (a difficult situation)",
	--              [[tirarsela]] "to lord it over", [[godersela]] "to enjoy", [[vedersela]] "to see (something) through",
	--              [[vedersela brutta]] "to have a hard time with; to be in a bad situation",
	--              [[aversela]] "to pick on (someone)", [[battersela]] "to run away, to sneak away",
	--              [[darsela a gambe]] "to run away", [[fumarsela]] "to sneak away",
	--              [[giocarsela]] "to behave (a certain way); to strategize; to play"
	--   * se + ne: [[andarsene]] "to take leave", [[approfittarsene]] "to take advantage of",
	--              [[fottersene]]/[[strafottersene]] "to not give a fuck",
	--              [[fregarsene]]/[[strafregarsene]] "to not give a damn",
	--              [[guardarsene]] "to beware; to think twice", [[impiparsene]] "to not give a damn",
	--              [[morirsene]] "to fade away; to die a lingering death", [[ridersene]] "to laugh at; to not give a damn",
	--              [[ritornarsene]] "to return to", [[sbattersene]]/[[strabattersene]] "to not give a damn",
	--              [[infischiarsene]] "to not give a damn", [[stropicciarsene]] "to not give a damn",
	--              [[sbarazzarsene]] "to get rid of, to bump off", [[andarsene in acqua]] "to be diluted; to decay",
	--              [[nutrirsene]] "to feed oneself", [[curarsene]] "to take care of",
	--              [[intendersene]] "to be an expert (in)", [[tornarsene]] "to return, to go back",
	--              [[starsene]] "to stay", [[farsene]] "to matter; to (not) consider; to use",
	--              [[farsene una ragione]] "to resign; to give up; to come to terms with; to settle (a dispute)",
	--              [[riuscirsene]] "to repeat (something annoying)", [[venirsene]] "to arrive slowly; to leave"
	--   * ci + si: [[trovarcisi]] "to find oneself in a happy situation",
	--              [[vedercisi]] "to imagine oneself (in a situation)", [[sentircisi]] "to feel at ease"
	--   * vi + si: [[recarvisi]] "to go there"
	--
	local ret = {}
	local linked_suf, finite_pref, finite_pref_elided_e, finite_pref_elided_ho
	local clitic_to_substitutable = {ce = "[[ce]]", ve = "[[ve]]", se = "<se>"}
	local clitic_to_elided = {
		ci = "[[c']]", vi = "[[vi]] ", si = "[[si]] ",
		lo = "[[l']]", la = "[[l']]", li = "[[li]] ", le = "[[le]] ",
	}
	local verb, clitic, clitic2 = rmatch(lemma, "^(.-)([cvs]e)(l[oaie])$")
	if verb then
		is_pronominal = true
		is_reflexive = clitic == "se"
		clitic = clitic_to_substitutable[clitic]
		linked_suf = clitic .. "[[" .. clitic2 .. "]]"
		finite_pref = clitic .. " [[" .. clitic2 .. "]] "
		finite_pref_elided_e = clitic .. " " .. clitic_to_elided[clitic2]
		finite_pref_elided_ho = clitic .. " " .. clitic_to_elided[clitic2]
	end
	if not verb then
		verb, clitic = rmatch(lemma, "^(.-)([cvs]e)ne$")
		if verb then
			is_pronominal = true
			is_reflexive = clitic == "se"
			clitic = clitic_to_substitutable[clitic]
			linked_suf = clitic .. "[[ne]]"
			finite_pref = clitic .. " [[ne]] "
			finite_pref_elided_e = clitic .. " [[n']]"
			finite_pref_elided_ho = clitic .. " [[ne]] "
		end
	end
	if not verb then
		verb, clitic = rmatch(lemma, "^(.-)([cv]i)si$")
		if verb then
			is_pronominal = true
			is_reflexive = true
			local si_no_clitic, space_no_clitic
			if clitic == "ci" then
				si_no_clitic = "<si_no_ci>"
				space_no_clitic = "<space_no_ci>"
			else
				si_no_clitic = "<si_no_vi>"
				space_no_clitic = "<space_no_vi>"
			end
			linked_suf = "[[" .. clitic .. "]]" .. si_no_clitic
			finite_pref = si_no_clitic .. space_no_clitic .. "[[" .. clitic .. "]] "
			finite_pref_elided_e = si_no_clitic .. space_no_clitic .. clitic_to_elided[clitic]
			finite_pref_elided_ho = finite_pref
		end
	end
	if not verb then
		verb, clitic = rmatch(lemma, "^(.-)([cv]i)$")
		if verb then
			is_pronominal = true
			linked_suf = "[[" .. clitic .. "]]"
			finite_pref = "[[" .. clitic .. "]] "
			finite_pref_elided_e = clitic_to_elided[clitic]
			finite_pref_elided_ho = finite_pref
		end
	end
	if not verb then
		verb = rmatch(lemma, "^(.-)si$")
		if verb then
			-- not pronominal
			is_reflexive = true
			linked_suf = "<si>"
			finite_pref = "<si> "
			finite_pref_elided_e = finite_pref
			finite_pref_elided_ho = finite_pref
		end
	end
	if not verb then
		verb = rmatch(lemma, "^(.-)ne$")
		if verb then
			is_pronominal = true
			linked_suf = "[[ne]]"
			finite_pref = "[[ne]] "
			finite_pref_elided_e = "[[n']]"
			finite_pref_elided_ho = "[[ne]] "
		end
	end
	if not verb then
		verb, clitic = rmatch(lemma, "^(.-)(l[oaie])$")
		if verb then
			is_pronominal = true
			linked_suf = "[[" .. clitic .. "]]"
			finite_pref = "[[" .. clitic .. "]] "
			finite_pref_elided_e = clitic_to_elided[clitic]
			finite_pref_elided_ho = clitic_to_elided[clitic]
		end
	end
	if not verb then
		-- not pronominal
		verb = lemma
		linked_suf = ""
		finite_pref = ""
		finite_pref_elided_e = ""
		finite_pref_elided_ho = ""
	end

	ret.raw_verb = verb
	ret.linked_suf = linked_suf
	ret.finite_pref = finite_pref
	ret.finite_pref_elided_e = finite_pref_elided_e
	ret.finite_pref_elided_ho = finite_pref_elided_ho
	ret.is_pronominal = is_pronominal
	ret.is_reflexive = is_reflexive
	return ret
end


-- Subfunction of find_builtin_verb(). Match a single spec (which may begin with ^ to anchor against the beginning,
-- otherwise anchored only at the end) against `verb`. Return the prefix and main verb.
local function match_spec_against_verb(spec, verb)
	if spec:find("^%^") then
		-- must match exactly
		if rfind(verb, spec .. "$") then
			return "", verb
		end
	else
		local prefix, main_verb = rmatch(verb, "^(.*)(" .. spec .. ")$")
		if prefix then
			return prefix, main_verb
		end
	end
end


-- Find and return the prefix, main verb and conj spec for a built-in verb.
local function find_builtin_verb(verb)
	for _, builtin_verb in ipairs(builtin_verbs) do
		local spec, conj, desc = unpack(builtin_verb)

		if type(spec) == "string" then
			local prefix, main_verb = match_spec_against_verb(spec, verb)
			if prefix then
				return prefix, main_verb, conj
			end
		else
			-- Of the form {term = "ergere", prefixes = {"^", "ad", "ri"}}. Note that the prefixes not preceded by ^
			-- can have further prefixes before them.
			for _, spec_prefix in ipairs(spec.prefixes) do
				local prefix, main_verb = match_spec_against_verb(spec_prefix .. spec.term, verb)
				if prefix then
					return prefix, main_verb, conj
				end
			end
		end
	end
end


local function parse_inside(base, inside, is_builtin_verb)
	local function parse_err(msg)
		error((is_builtin_verb and "Internal error processing built-in verb spec: " or "") .. msg
			.. ": <" .. inside .. ">")
	end

	local function parse_qualifiers(separated_group)
		local qualifiers
		for j = 2, #separated_group - 1, 2 do
			if separated_group[j + 1] ~= "" then
				parse_err("Extraneous text after bracketed qualifiers: '" .. table.concat(separated_group) .. "'")
			end
			if not qualifiers then
				qualifiers = {}
			end
			table.insert(qualifiers, separated_group[j])
		end
		return qualifiers
	end

	local function fetch_specs(comma_separated_group, allow_blank)
		local colon_separated_groups = split_alternating_runs_and_strip_spaces(comma_separated_group, ":")
		if allow_blank and #colon_separated_groups == 1 and #colon_separated_groups[1] == 1 and
			colon_separated_groups[1][1] == "" then
			return nil
		end
		local specs = {}
		for _, colon_separated_group in ipairs(colon_separated_groups) do
			local form = colon_separated_group[1]
			if form == "" then
				parse_err("Blank form not allowed here, but saw '" ..
					table.concat(comma_separated_group) .. "'")
			end
			local new_spec = {form = form, footnotes = parse_qualifiers(colon_separated_group)}
			for _, existing_spec in ipairs(specs) do
				if m_table.deepEquals(existing_spec, new_spec) then
					parse_err("Duplicate spec '" .. table.concat(colon_separated_group) .. "'")
				end
			end
			table.insert(specs, new_spec)
		end
		return specs
	end

	-- Parse present-tense spec of the form PRES^PRES3S or just PRES, and set the appropriate properties in `base`.
	-- Used in the PRES^PRES3S,PHIS,PP spec as well as with pres:PRES^PRES3S in conjunction with built-in verbs.
	local function parse_present_spec(run)
		local cflex_separated_groups = split_alternating_runs_and_strip_spaces(run, "%^")
		if #cflex_separated_groups > 2 then
			parse_err("At most one circumflex sign (^) can appear in present tense specs")
		end
		base.principal_part_specs.pres = fetch_specs(cflex_separated_groups[1])
		if #cflex_separated_groups == 2 then
			base.principal_part_specs.pres3s = fetch_specs(cflex_separated_groups[2])
		end
	end

	local segments = iut.parse_balanced_segment_run(inside, "[", "]")
	local dot_separated_groups = split_alternating_runs_and_strip_spaces(segments, "%.")
	for i, dot_separated_group in ipairs(dot_separated_groups) do
		local first_element = dot_separated_group[1]

		if i == 1 then -- first dot-separated group is PRES,PHIS,PP or PRES^PRES3S,PHIS,PP or similar.
			local comma_separated_groups = split_alternating_runs_and_strip_spaces(dot_separated_group, "[,\\/]",
				"preserve splitchar")
			local presind = 1
			local first_separator = #comma_separated_groups > 1 and comma_separated_groups[2][1]
			if base.verb.is_reflexive or is_builtin_verb then
				if #comma_separated_groups > 1 and first_separator ~= "," then
					presind = 3
					-- Fetch root-stressed infinitive, if given.
					local specs = fetch_specs(comma_separated_groups[1], "allow blank")
					if first_separator == "\\" then
						-- For verbs like [[scegliersi]] and [[proporsi]], allow either 'é\scélgo' or '\é\scélgo'
						-- and similarly either 'ó+\propóngo' or '\ó+\propóngo'.
						if specs == nil then
							if #comma_separated_groups > 3 and comma_separated_groups[4][1] == "\\" then
								base.principal_part_specs.root_stressed_inf = fetch_specs(comma_separated_groups[3])
								presind = 5
							else
								base.principal_part_specs.root_stressed_inf = {{form = "+"}}
							end
						else
							base.principal_part_specs.root_stressed_inf = specs
						end
					elseif specs ~= nil then
						local errpref = is_builtin_verb and "With built-in verb" or "With reflexive verb"
						parse_err(errpref .. ", can't specify anything before initial slash, but saw '"
							.. table.concat(comma_separated_groups[1]))
					end
				end
				if not is_builtin_verb then
					base.principal_part_specs.aux = {{form = "èssere"}}
				end
			else -- non-reflexive
				if #comma_separated_groups == 1 or first_separator == "," then
					parse_err("With non-reflexive verb, use a spec like AUX/PRES, AUX\\PRES, AUX/PRES,PAST,PP or similar")
				end
				presind = 3
				-- Fetch auxiliary or auxiliaries.
				local colon_separated_groups = split_alternating_runs_and_strip_spaces(comma_separated_groups[1], ":")
				for _, colon_separated_group in ipairs(colon_separated_groups) do
					local aux = colon_separated_group[1]
					if aux == "a" then
						aux = "avére"
					elseif aux == "e" then
						aux = "èssere"
					elseif aux == "-" then
						if #colon_separated_group > 1 then
							parse_err("No footnotes allowed with '-' spec for auxiliary")
						end
						aux = nil
					else
						parse_err("Unrecognized auxiliary '" .. aux ..
							"', should be 'a' (for [[avere]]), 'e' (for [[essere]]), or '-' if no past participle")
					end
					if aux then
						if base.principal_part_specs.aux then
							for _, existing_aux in ipairs(base.principal_part_specs.aux) do
								if existing_aux.form == aux then
									parse_err("Auxiliary '" .. aux .. "' specified twice")
								end
							end
						else
							base.principal_part_specs.aux = {}
						end
						table.insert(base.principal_part_specs.aux, {form = aux, footnotes = parse_qualifiers(colon_separated_group)})
					end
				end

				-- Fetch root-stressed infinitive, if given.
				if first_separator == "\\" then
					if #comma_separated_groups > 3 and comma_separated_groups[4][1] == "\\" then
						base.principal_part_specs.root_stressed_inf = fetch_specs(comma_separated_groups[3])
						presind = 5
					else
						base.principal_part_specs.root_stressed_inf = {{form = "+"}}
					end
				end
			end

			if #comma_separated_groups == presind and comma_separated_groups[presind][1] == "@" then
				-- We will find the conjugation for the built-in verb later, after we've seen whether there is an
				-- '.rre' property.
				base.props.builtin = true
			else
				-- Parse present
				parse_present_spec(comma_separated_groups[presind])

				-- Parse past historic
				if #comma_separated_groups > presind then if comma_separated_groups[presind + 1][1] ~= "," then
						parse_err("Use a comma not slash to separate present from past historic")
					end
					base.principal_part_specs.phis = fetch_specs(comma_separated_groups[presind + 2])
				end

				-- Parse past participle
				if #comma_separated_groups > presind + 2 then
					if comma_separated_groups[presind + 3][1] ~= "," then
						parse_err("Use a comma not slash to separate past historic from past participle")
					end
					base.principal_part_specs.pp = fetch_specs(comma_separated_groups[presind + 4])
				end

				if #comma_separated_groups > presind + 4 then
					parse_err("Extraneous text after past participle")
				end
			end
		elseif first_element == "only3s" or first_element == "only3sp" or first_element == "rre" then
			if #dot_separated_group > 1 then
				parse_err("No footnotes allowed with '" .. first_element .. "' spec")
			end
			base.props[first_element] = true
		else
			local first_element_prefix, first_element_minus_prefix = rmatch(first_element,
				"^%s*([a-z0-9_]+)%s*:%s*(.-)%s*$")
			if not first_element_prefix then
				parse_err("Dot-separated element should be either 'only3s', 'only3p', 'rre' or be of the form "
					.. "'PREFIX:SPEC', but saw '" .. table.concat(dot_separated_group) .. "'")
			end
			dot_separated_group[1] = first_element_minus_prefix
			if first_element_prefix == "stem" then
				base.principal_part_specs.explicit_stem_spec = fetch_specs(dot_separated_group)
			elseif first_element_prefix == "pres" then
				if not base.props.builtin then
					parse_err("Can't specify 'pres:' override except when '@' is given to request a built-in verb")
				end
				parse_present_spec(dot_separated_group)
			elseif row_conjugation_map[first_element_prefix] then
				local no_explicit_pp = row_conjugation_map[first_element_prefix].no_explicit_principal_part
				if no_explicit_pp == true or not base.props.builtin and no_explicit_pp == "builtin" then
					parse_err("Can't specify principal part for " .. row_conjugation_map[first_element_prefix].desc
						.. " using '" .. first_element_prefix .. ":'; use the specification PRES^PRES3S.PHIS.PP")
				else
					base.principal_part_specs[first_element_prefix] = fetch_specs(dot_separated_group)
				end
			elseif overridable_slot_set[first_element_prefix] then
				base.single_override_specs[first_element_prefix] = fetch_specs(dot_separated_group)
			elseif first_element_prefix:find("row$") then
				local row_override_slot = rmatch(first_element_prefix, "^(.*)row$")
				if row_conjugation_map[row_override_slot] then
					local rowspec = row_conjugation_map[row_override_slot]
					if rowspec.no_row_overrides then
						-- This happens with e.g. pp and negimp. Doesn't make sense with pp because it's a single form
						-- that can be specified completely using the explicit principal part. Rarely if ever useful
						-- for negimp; use single overrides if absolutely necessary.
						parse_err("Can't specify row override for " .. rowspec.desc .. " using " .. row_override_slot
							.. "row:; use an explicit principal part or single overrides (if allowed)")
					end
					local comma_separated_groups = split_alternating_runs_and_strip_spaces(dot_separated_group, ",")
					local persnums = rowspec.row_override_persnums or rowspec.persnums
					if #comma_separated_groups ~= #persnums then
						parse_err("For " .. row_override_slot .. "row:, expected " .. #persnums
							.. " comma-separated forms but saw " .. #comma_separated_groups .. " in '"
							.. table.concat(dot_separated_group) .. "'")
					end
					base.row_override_specs[row_override_slot] = {}
					for i, persnum in ipairs(persnums) do
						base.row_override_specs[row_override_slot][persnum] = fetch_specs(comma_separated_groups[i])
					end
				else
					local row_override_slots = {}
					for row_override_slot, _ in pairs(row_conjugation_map) do
						table.insert(row_override_slots, row_override_slot .. "row:")
					end
					table.sort(row_override_slots)
					parse_err("Row override spec should begin with one of " .. m_table.serialCommaJoin(row_override_slots)
						.. ", but saw '" .. table.concat(dot_separated_group) .. "'")
				end
			else
				parse_err("Unrecognized prefix '" .. first_element_prefix .. "' in '"
					.. table.concat(dot_separated_group) .. "'")
			end
		end
	end
end


local function create_base()
	-- `forms` contains the final per-slot forms. This is processed further in [[Module:inflection-utilities]].
	--    This is a table indexed by slot (e.g. "pres1s"). Each value in the table is a list of items of the form
	--    {form = FORM, footnotes = FOOTNOTES} where FORM is the actual generated form and FOOTNOTES is either nil
	--    or a list of footnotes (which must be surrounded by brackets, e.g. "[archaic]").
	-- `principal_part_specs` contains forms specified by the user in various fashions. The value is in the same form
	--    as for `forms``, but the FORM contained in it is the actual user-specified form, which may be e.g. "#è"
	--    rather than a verb form, and needs to be processed to generate the actual form. A spec may be "+" to insert
	--    the default-generated form or forms, or "-" to indicate that this form doesn't exist. The source of these
	--    forms is either
	--    (a) prefixes 'imperf:', 'fut:', 'sub:', 'impsub:', 'imp:', etc. (the key is "imperf", "fut", etc.);
	--    (b) specs in the format e.g. "vèngo:vègno[archaic or poetic]^viène,vénni,venùto" or "é:#è" (the key is one of
	--        "pres", "pres3s", "phis" or "pp" as appropriate);
	--    (c) an explicit stem specified using 'stem:' (the key is "explicit_stem_spec");
	--    (d) a root-stressed infinitive spec such as "o+" in "a\o+\compóngo,compósi,compósto" (the key is
	--        "root_stressed_inf");
	--    (e) an auxiliary specified using e.g. "a[transitive]:e[intransitive]/è" (the key is "aux" and the value will
	--        contain the actual auxiliary in the form in place of "a" or "e").
	-- `principal_part_forms` contains the processed versions of the specs contained in `principal_part_specs`. The
	--    keys are as in `principal_part_specs` and the values are the same as for `forms`.
	-- `row_override_specs` contains user-specified forms for a full tense/aspect row using 'presrow:', 'subrow:', etc.
	--    The key is "pres", "sub", etc. (i.e. minus the "row" suffix). The value is another table indexed by the
	--    person/number suffix (e.g. "1s", "2s", etc. for "pres"; "123s", "1p", "2p", etc. for "sub"), whose values
	--    are in the same format as `principal_part_specs`.
	-- `single_override_specs` contains user-specified forms using 'pres1s:', 'sub3p:', etc. The key is the slot
	--    ("pres1s", "sub3p", etc.) and the value is of the same format as `principal_part_specs`.
	-- `is_irreg` is a table indexed by the row suffix ("pres", "sub", etc.) whose value is true or false indicating
	--    whether a given row is irregular.
	-- `props` is a table of miscellaneous properties.
	--
	-- There should be no other properties set directly at the `base` level.
	return {forms = {}, principal_part_specs = {}, principal_part_forms = {}, row_override_specs = {},
		single_override_specs = {}, is_irreg = {}, is_defective = {}, props = {}}
end


local function parse_indicator_spec(angle_bracket_spec, lemma, pagename)
	local base = create_base()
	if lemma == "" then
		lemma = pagename
	end
	base.lemma = m_links.remove_links(lemma)
	base.verb = analyze_verb(lemma)

	local inside = angle_bracket_spec:match("^<(.*)>$")
	assert(inside)
	parse_inside(base, inside, false)

	local function parse_err(msg)
		error(msg .. ": " .. angle_bracket_spec)
	end

	-- Set up base.verb.verb. This must be done after parse_inside() because it depends on the '.rre' indicator.
	set_up_base_verb(base)

	if base.props.builtin then
		local prefix, main_verb, conj = find_builtin_verb(base.verb.verb)
		if not prefix then
			parse_err("Unable to find built-in verb corresponding to '" .. base.verb.verb .. "'")
		end
		-- Create a new `base`, fill it with properties from the built-in verb, and copy over the user-specified
		-- properties on top of it.
		local nbase = create_base()
		nbase.lemma = base.lemma
		nbase.verb = base.verb
		nbase.verb.prefix = prefix
		nbase.verb.verb = main_verb
		parse_inside(nbase, conj, "is builtin")
		for _, prop_table in ipairs { "principal_part_specs", "row_override_specs", "single_override_specs", "props" } do
			for slot, prop in pairs(base[prop_table]) do
				nbase[prop_table][slot] = prop
			end
		end
		return nbase
	end

	return base
end


-- Normalize all lemmas, substituting the pagename for blank lemmas and adding links to multiword lemmas.
local function normalize_all_lemmas(alternant_multiword_spec)

	-- (1) Add links to all before and after text.
	if not alternant_multiword_spec.args.noautolinktext then
		alternant_multiword_spec.post_text = add_links(alternant_multiword_spec.post_text)
		for _, alternant_or_word_spec in ipairs(alternant_multiword_spec.alternant_or_word_specs) do
			alternant_or_word_spec.before_text = add_links(alternant_or_word_spec.before_text)
			if alternant_or_word_spec.alternants then
				for _, multiword_spec in ipairs(alternant_or_word_spec.alternants) do
					multiword_spec.post_text = add_links(multiword_spec.post_text)
					for _, word_spec in ipairs(multiword_spec.word_specs) do
						word_spec.before_text = add_links(word_spec.before_text)
					end
				end
			end
		end
	end

	-- (2) Remove any links from the lemma, but remember the original form
	--     so we can use it below in the 'lemma_linked' form.
	iut.map_word_specs(alternant_multiword_spec, function(base)
		base.user_specified_lemma = base.lemma
		base.lemma = m_links.remove_links(base.lemma)
	end)
end


local function detect_indicator_spec(base)
	if base.props.only3s and base.props.only3sp then
		error("'only3s' and 'only3sp' cannot both be specified")
	end
end


local function detect_all_indicator_specs(alternant_multiword_spec, from_headword)
	alternant_multiword_spec.props = {}

	local props_that_must_be_consistent = {"only3s", "only3sp"}
	-- Propagate some settings up or down.
	iut.map_word_specs(alternant_multiword_spec, function(base)
		for _, prop in ipairs(props_that_must_be_consistent) do
			if base.props[prop] then
				alternant_multiword_spec.props[prop] = true
			end
		end
		base.from_headword = from_headword
		base.args = alternant_multiword_spec.args
	end)

	for _, prop in ipairs(props_that_must_be_consistent) do
		if alternant_multiword_spec.props[prop] then
			iut.map_word_specs(alternant_multiword_spec, function(base)
				if not base.props[prop] then
					error("If some alternants specify '" .. prop .. "', all must")
				end
			end)
		end
	end

	iut.map_word_specs(alternant_multiword_spec, function(base)
		detect_indicator_spec(base)
	end)
end


-- Set the overall auxiliary or auxiliaries. We can't do this using the normal inflection
-- code as it will produce e.g. '[[avere|avére]] [[e]] [[avere|avére]]' for conjoined verbs.
local function compute_auxiliary(alternant_multiword_spec)
	iut.map_word_specs(alternant_multiword_spec, function(base)
		iut.insert_forms(alternant_multiword_spec.forms, "aux",
			iut.map_forms(base.principal_part_specs.aux, function(form)
				return add_links(form)
			end)
		)
	end)
end


local function add_categories_and_annotation(alternant_multiword_spec, base, multiword_lemma, from_headword)
	local function insert_ann(anntype, value)
		m_table.insertIfNot(alternant_multiword_spec.annotation[anntype], value)
	end

	local function insert_cat(cat, also_when_multiword)
		-- Don't place multiword terms in categories like 'Italian verbs ending in -are' to avoid spamming the
		-- categories with such terms.
		if also_when_multiword or not multiword_lemma then
			m_table.insertIfNot(alternant_multiword_spec.categories, "Italian " .. cat)
		end
	end

	if check_for_red_links and not from_headword and not multiword_lemma then
		for _, slot_and_accel in ipairs(all_verb_slots) do
			local slot = slot_and_accel[1]
			local forms = base.forms[slot]
			local must_break = false
			if forms then
				for _, form in ipairs(forms) do
					if not form.form:find("%[%[") then
						local title = mw.title.new(form.form)
						if title and not title.exists then
							insert_cat("verbs with red links in their inflection tables")
							must_break = true
						break
						end
					end
				end
			end
			if must_break then
				break
			end
		end
	end

	if base.props.syncopated then
		insert_ann("conj", "syncopated")
		insert_cat("syncopated verbs")
	elseif base.principal_part_specs.root_stressed_inf then
		insert_ann("conj", "root-stressed -ere")
		insert_cat("root-stressed verbs")
		insert_cat("verbs ending in -ere")
	else
		local ending = base.conj_vowel == "à" and "are" or base.conj_vowel == "é" and "ere" or "ire"
		insert_ann("conj", "-" .. ending)
		insert_cat("verbs ending in -" .. ending)
	end

	if base.props.only3s then
		insert_ann("third_only", "impersonal")
		insert_cat("impersonal verbs")
	elseif base.props.only3sp then
		insert_ann("third_only", "third-person only")
		insert_cat("third-person-only verbs")
	else
		insert_ann("third_only", "regular")
	end

	local is_irreg = false
	local is_defective = false
	for _, rowspec in ipairs(row_conjugation) do
		local rowslot, rowconj = unpack(rowspec)
		if base.is_irreg[rowslot] then
			if not is_irreg then
				is_irreg = true
				insert_cat("irregular verbs")
			end
			insert_cat("verbs with irregular " .. rowconj.desc)
		end 
		if base.is_defective[rowslot] then
			if not is_defective then
				is_defective = true
				insert_cat("defective verbs")
			end
			insert_cat("verbs with defective " .. rowconj.desc)
		end 
	end
	if not base.verb.is_reflexive and not base.principal_part_specs.aux then
		if not is_defective then
			is_defective = true
			insert_cat("defective verbs")
		end
		insert_cat("verbs lacking composed tenses")
	end

	if is_irreg then
		insert_ann("irreg", "irregular")
	else
		insert_ann("irreg", "regular")
	end

	if is_defective then
		insert_ann("defective", "defective")
	else
		insert_ann("defective", "regular")
	end

	if not base.verb.is_reflexive and base.principal_part_specs.aux then
		for _, auxform in ipairs(base.principal_part_specs.aux) do
			insert_ann("aux", auxform.form)
			insert_cat("verbs taking " .. auxform.form .. " as auxiliary")
		end
	end

	if base.verb.is_pronominal then
		insert_cat("verbs with lexical clitics")
	end

	if base.verb.is_reflexive then
		insert_cat("reflexive verbs")
	end
end


-- Compute the categories to add the verb to, as well as the annotation to display in the
-- conjugation title bar. We combine the code to do these functions as both categories and
-- title bar contain similar information.
local function compute_categories_and_annotation(alternant_multiword_spec, from_headword)
	alternant_multiword_spec.categories = {}
	local ann = {}
	alternant_multiword_spec.annotation = ann
	ann.conj = {}
	ann.third_only = {}
	ann.irreg = {}
	ann.defective = {}
	ann.aux = {}

	local multiword_lemma = false
	for _, form in ipairs(alternant_multiword_spec.forms.inf) do
		if form.form:find(" ") then
			multiword_lemma = true
			break
		end
	end

	iut.map_word_specs(alternant_multiword_spec, function(base)
		add_categories_and_annotation(alternant_multiword_spec, base, multiword_lemma, from_headword)
	end)
	local ann_parts = {}
	local conj = table.concat(ann.conj, " or ")
	table.insert(ann_parts, conj)
	local third_only = table.concat(ann.third_only, " or ")
	if third_only ~= "" and third_only ~= "regular" then
		table.insert(ann_parts, third_only)
	end
	local irreg = table.concat(ann.irreg, " or ")
	if irreg ~= "" and irreg ~= "regular" then
		table.insert(ann_parts, irreg)
	end
	local defective = table.concat(ann.defective, " or ")
	if defective ~= "" and defective ~= "regular" then
		table.insert(ann_parts, defective)
	end
	alternant_multiword_spec.annotation = table.concat(ann_parts, "; ")
end


local function show_forms(alternant_multiword_spec)
	local lemmas = iut.map_forms(alternant_multiword_spec.forms.inf,
		remove_reflexive_indicators)
	alternant_multiword_spec.lemmas = lemmas -- save for later use in make_table()

	local props = {
		lang = lang,
		lemmas = lemmas,
		slot_list = all_verb_slots,
	}
	iut.show_forms(alternant_multiword_spec.forms, props)
	alternant_multiword_spec.footnote_basic = alternant_multiword_spec.forms.footnote
end


local notes_template = [=[
<div style="width:100%;text-align:left;background:#d9ebff">
<div style="display:inline-block;text-align:left;padding-left:1em;padding-right:1em">
{footnote}
</div></div>
]=]

local basic_table = [=[
{description}<div class="NavFrame">
<div class="NavHead" align=center>&nbsp; &nbsp; Conjugation of {title} (See [[Appendix:Italian verbs]])</div>
<div class="NavContent">
{\op}| style="background:#F0F0F0;border-collapse:separate;border-spacing:2px;width:100%" class="inflection-table"
|-
! style="background:#e2e4c0" | <span title="infinito">infinitive</span>
| {inf}
|-
! colspan="2" style="background:#e2e4c0" | <span title="verbo ausiliare">auxiliary verb</span>
| {aux}
! colspan="2" style="background:#e2e4c0" | <span title="gerundio">gerund</span>
| colspan="2" | {ger}
|-
! colspan="2" style="background:#e2e4c0" |  <span title="participio presente">present participle</span>
| {presp}
! colspan="2" style="background:#e2e4c0" | <span title="participio passato">past participle</span>
| colspan="2" | {pp}
|-
! rowspan="2" style="background:#C0C0C0" | person
! colspan="3" style="background:#C0C0C0" | singular
! colspan="3" style="background:#C0C0C0" | plural
|-
! style="background:#C0C0C0;width:12.5%" | first
! style="background:#C0C0C0;width:12.5%" | second
! style="background:#C0C0C0;width:12.5%" | third
! style="background:#C0C0C0;width:12.5%" | first
! style="background:#C0C0C0;width:12.5%" | second
! style="background:#C0C0C0;width:12.5%" | third
|-
! style="background:#c0cfe4" | <span title="indicativo">indicative</span>
! style="background:#c0cfe4" | io
! style="background:#c0cfe4" | tu
! style="background:#c0cfe4" | lui/lei, esso/essa
! style="background:#c0cfe4" | noi
! style="background:#c0cfe4" | voi
! style="background:#c0cfe4" | loro, essi/esse
|-
! style="height:3em;background:#c0cfe4" | <span title="presente">present</span>
| {pres1s}
| {pres2s}
| {pres3s}
| {pres1p}
| {pres2p}
| {pres3p}
|-
! style="height:3em;background:#c0cfe4" | <span title="imperfetto">imperfect</span>
| {imperf1s}
| {imperf2s}
| {imperf3s}
| {imperf1p}
| {imperf2p}
| {imperf3p}
|-
! style="height:3em;background:#c0cfe4" | <span title="passato remoto">past historic</span>
| {phis1s}
| {phis2s}
| {phis3s}
| {phis1p}
| {phis2p}
| {phis3p}
|-
! style="height:3em;background:#c0cfe4" | <span title="futuro semplice">future</span>
| {fut1s}
| {fut2s}
| {fut3s}
| {fut1p}
| {fut2p}
| {fut3p}
|-
! style="background:#c0d8e4" | <span title="condizionale">conditional</span>
! style="background:#c0d8e4" | io
! style="background:#c0d8e4" | tu
! style="background:#c0d8e4" | lui/lei, esso/essa
! style="background:#c0d8e4" | noi
! style="background:#c0d8e4" | voi
! style="background:#c0d8e4" | loro, essi/esse
|-
! style="height:3em;background:#c0d8e4" | <span title="condizionale presente">present</span>
| {cond1s}
| {cond2s}
| {cond3s}
| {cond1p}
| {cond2p}
| {cond3p}
|-
! style="background:#c0e4c0" | <span title="congiuntivo">subjunctive</span>
! style="background:#c0e4c0" | che io
! style="background:#c0e4c0" | che tu
! style="background:#c0e4c0" | che lui/che lei, che esso/che essa
! style="background:#c0e4c0" | che noi
! style="background:#c0e4c0" | che voi
! style="background:#c0e4c0" | che loro, che essi/che esse
|-
! style="height:3em;background:#c0e4c0" | <span title="congiuntivo presente">present</span>
| {sub1s}
| {sub2s}
| {sub3s}
| {sub1p}
| {sub2p}
| {sub3p}
|-
! style="height:3em;background:#c0e4c0" | <span title="congiuntivo imperfetto">imperfect</span>
| {impsub1s}
| {impsub2s}
| {impsub3s}
| {impsub1p}
| {impsub2p}
| {impsub3p}
|-
! rowspan="2" style="height:3em;background:#e4d4c0" | <span title="imperativo">imperative</span>
! style="background:#e4d4c0" | &mdash;
! style="background:#e4d4c0" | tu
! style="background:#e4d4c0" | Lei
! style="background:#e4d4c0" | noi
! style="background:#e4d4c0" | voi
! style="background:#e4d4c0" | Loro
|-
|
| {imp2s}
| {imp3s}
| {imp1p}
| {imp2p}
| {imp3p}
|-
! style="height:3em;background:#e4d4c0" | <span title="imperativo negativo">negative imperative</span>
|
| {negimp2s}
| {negimp3s}
| {negimp1p}
| {negimp2p}
| {negimp3p}
|{\cl}{notes_clause}</div></div>
]=]


local function make_table(alternant_multiword_spec)
	local forms = alternant_multiword_spec.forms

	forms.title = m_links.full_link({ lang = lang, term = alternant_multiword_spec.lemmas[1].form }, "term")

	if alternant_multiword_spec.annotation ~= "" then
		forms.title = forms.title .. " (" .. alternant_multiword_spec.annotation .. ")"
	end
	forms.description = ""

	-- Format the table.
	forms.footnote = alternant_multiword_spec.footnote_basic
	forms.notes_clause = forms.footnote ~= "" and m_string_utilities.format(notes_template, forms) or ""
	return m_string_utilities.format(basic_table, forms)
end


-- Externally callable function to parse and conjugate a verb given user-specified arguments.
-- Return value is WORD_SPEC, an object where the conjugated forms are in `WORD_SPEC.forms`
-- for each slot. If there are no values for a slot, the slot key will be missing. The value
-- for a given slot is a list of objects {form=FORM, footnotes=FOOTNOTES}.
function export.do_generate_forms(parent_args, from_headword, def)
	local params = {
		[1] = {required = true, default = def or "mettere<a\é,mìsi,mésso>"},
		["nocomb"] = {type = "boolean"},
		["noautolinktext"] = {type = "boolean"},
		["noautolinkverb"] = {type = "boolean"},
		["pagename"] = {} -- for testing
	}

	if from_headword then
		params["head"] = {list = true}
		params["id"] = {}
	end

	local args = require("Module:parameters").process(parent_args, params)

	local iut = require("Module:inflection utilities")

	local arg1 = args[1]
	local need_surrounding_angle_brackets = true
	-- Check whether we need to add <...> around the argument. If the
	-- argument has no < in it, we definitely do. Otherwise, we need to
	-- parse the balanced [...] and <...> and add <...> only if there isn't
	-- a top-level <...>. We check for [...] because there might be angle
	-- brackets inside of them (HTML tags in qualifiers or <<name:...>> and
	-- such in references).
	if arg1:find("<") then
		local segments = iut.parse_multi_delimiter_balanced_segment_run(arg1,
			{{"<", ">"}, {"[", "]"}})
		for i = 2, #segments, 2 do
			if segments[i]:find("^<.*>$") then
				need_surrounding_angle_brackets = false
				break
			end
		end
	end
	if need_surrounding_angle_brackets then
		arg1 = "<" .. arg1 .. ">"
	end

	local function do_parse_indicator_spec(angle_bracket_spec, lemma)
		local pagename = args.pagename or mw.title.getCurrentTitle().text
		return parse_indicator_spec(angle_bracket_spec, lemma, pagename)
	end

	local parse_props = {
		parse_indicator_spec = do_parse_indicator_spec,
		allow_default_indicator = true,
		allow_blank_lemma = true,
	}
	local escaped_arg1 = escape_reflexive_indicators(arg1)
	local alternant_multiword_spec = iut.parse_inflected_text(escaped_arg1, parse_props)
	alternant_multiword_spec.pos = pos or "verbs"
	alternant_multiword_spec.args = args
	normalize_all_lemmas(alternant_multiword_spec)
	detect_all_indicator_specs(alternant_multiword_spec, from_headword)
	local inflect_props = {
		slot_list = all_verb_slots,
		inflect_word_spec = conjugate_verb,
		-- We add links around the generated verbal forms rather than allow the entire multiword
		-- expression to be a link, so ensure that user-specified links get included as well.
		include_user_specified_links = true,
	}
	iut.inflect_multiword_or_alternant_multiword_spec(alternant_multiword_spec, inflect_props)
	compute_auxiliary(alternant_multiword_spec)

	-- Convert accented forms to two-part forms and remove PRESERVE_ACCENT characters.
	for slot, forms in pairs(alternant_multiword_spec.forms) do
		for _, form in ipairs(forms) do
			form.form = convert_accented_links(form.form)
		end
	end

	compute_categories_and_annotation(alternant_multiword_spec, from_headword)
	return alternant_multiword_spec
end


-- Entry point for {{it-conj}}. Template-callable function to parse and conjugate a verb given
-- user-specified arguments and generate a displayable table of the conjugated forms.
function export.show(frame)
	local parent_args = frame:getParent().args
	local alternant_multiword_spec = export.do_generate_forms(parent_args)
	show_forms(alternant_multiword_spec)
	return make_table(alternant_multiword_spec) ..
		require("Module:utilities").format_categories(alternant_multiword_spec.categories, lang, nil, nil, force_cat)
end


-- Concatenate all forms of all slots into a single string of the form
-- "SLOT=FORM,FORM,...|SLOT=FORM,FORM,...|...". Embedded pipe symbols (as might occur
-- in embedded links) are converted to <!>. If INCLUDE_PROPS is given, also include
-- additional properties (currently, none). This is for use by bots.
local function concat_forms(alternant_multiword_spec, include_props)
	local ins_text = {}
	for _, slot_and_accel in ipairs(all_verb_slots) do
		local slot = slot_and_accel[1]
		local formtext = iut.concat_forms_in_slot(alternant_multiword_spec.forms[slot])
		if formtext then
			table.insert(ins_text, slot .. "=" .. formtext)
		end
	end
	return table.concat(ins_text, "|")
end


-- Template-callable function to parse and conjugate a verb given user-specified arguments and return
-- the forms as a string "SLOT=FORM,FORM,...|SLOT=FORM,FORM,...|...". Embedded pipe symbols (as might
-- occur in embedded links) are converted to <!>. If |include_props=1 is given, also include
-- additional properties (currently, none). This is for use by bots.
function export.generate_forms(frame)
	local include_props = frame.args["include_props"]
	local parent_args = frame:getParent().args
	local alternant_multiword_spec = export.do_generate_forms(parent_args)
	return concat_forms(alternant_multiword_spec, include_props)
end


return export
