local export = {}


--[=[

Authorship: Ben Wing <benwing2>

]=]

--[=[

TERMINOLOGY:

-- "slot" = A particular combination of tense/mood/person/number/etc.
	 Example slot names for verbs are "pres_1s" (present indicative first-person singular), "pres_sub_2sv" (present
	 subjunctive second-person singular voseo form) "impf_sub_ra_3p" (imperfect subjunctive -ra form third-person
	 plural), "imp_1p_comb_lo" (imperative first-person plural combined with clitic [[lo]]).
	 Each slot is filled with zero or more forms.

-- "form" = The conjugated Italian form representing the value of a given slot.

-- "lemma" = The dictionary form of a given Italian term. For Italian, always the infinitive.
]=]

--[=[

RULES FOR CONJUGATION:

1. Present indicative:
-- Individual form overrides always take precedence.
-- Otherwise, if presrow: if given, this specifies all six forms (1s, 2s, 3s, 1p, 2p, 3p).
-- Otherwise:
   1. The 1s form is generated from the explicitly specified pres1s form.
   2. The 3p form is generated from the explicitly specified pres1s form by replacing -o with -ano (for -are verbs)
      or with -ono (for -ere/-ire verbs).
   3. The 2s and 3s forms are generated as follows:
      a. If an explicit pres3s form is given using PRES1S#PRES3S, the 2s/3s stem is generated by removing final -a/-e.
	  b. Otherwise, if an explicit stem was given using stem:, this serves as the 2s/3s stem.
	  c. Otherwise, if the infinitive is root-stressed, the 2s/3s stem comes from the infinitive. This is used e.g.
		 with [[togliere]] (tòlgo, tògli, tòglie, togliàmo, togliéte, tòlgono), where the stem of the 1s and 3p forms
		 is different from the stem of the 2s and 3s forms.
	  d. Otherwise, the pres1s stem is used.
	  From this stem, the 2s form is generated by adding -i (possibly with some adjustments; two unstressed i's
	  together are compressed to one, and -h- is inserted after the stem if the verb is an -are verb and the stem ends
	  with -c or -g), and the 3s form is generated by adding -a (for -are verbs) or -e (for -ere/-ire verbs).
   4. The 1p and 2p forms are generated from the infinitive stem (or explicit stem given by stem:) by adding -iàmo
      (1p form) and -àte/-éte/-ìte (2p form, -are/-ere/-ire verbs). We don't use the pres1s form because it might have
	  a different stem (e.g. +isc verbs).

2. Present subjunctive:
-- Individual form overrides always take precedence.
-- Otherwise, if subrow: if given, this specifies all four forms (123s, 1p, 2p, 3p).
-- Otherwise:
   1. If sub: is given, this specifies the 123s form; otherwise the 123s form is generated from the pres1s form by
   changing -o to -a (for -ere/-ire verbs), or to -i (for -are verbs). E.g. for [[venire]], vèngo -> vènga;
   for [[potere]], pòsso -> pòssa. sub: needs to be given for e.g. [[essere]] (pres1s sóno, sub1s sìa),
   [[sapere]] (pres1s sò* but sub1s sàppia), [[fare]] (pres1s fàccio:fò*[archaic or dialectal] but sub1s just fàccia),
   [[andare]] (similar to [[fare]]), [[dovere]].
   2. The 3p form is generated from the 123s form by adding -no.
   3. The 1p form is copied from the pres1p form.
   4. The 2p form is generated from the 1p form by replacing -mo with -te.

3. Imperative:
-- If noimp given, the imperative is suppressed.
-- Otherwise, individual form overrides take precedence.
-- Otherwise, if improw: if given, this specifies 2s, 2p.
-- Otherwise:
   1. If imp: given, this specifies the 2s form; otherwise the 2s form is generated by copying the pres2s form
      (for -ere/-ire verbs) or by copying the pres3s form (for -are verbs). We use the present indicative 2s/3s
	  forms to preserve vowel and other alternations in the root-stressed forms (for all -are verbs, for
	  [[venire]] and [[tenere]], for +isc verbs, etc.).
   2. The 2p form is generated by copying the pres2p form.
   3. The 3s, 1p, 3p forms are copied from the corresponding present subjunctive forms.
]=]

--[=[

EXAMPLES OF CONJUGATION:

{{it-conj|mettere<a\é,mìsi,mésso>}}

{{it-conj|arrivare<e:a[transitive]/ì>}}

{{it-conj|trovare<a/ò>}}

{{it-conj|sembrare<e/é>}}

{{it-conj|temprare<e/é:#è>}}

{{it-conj|essere<e\è\-,-,stàto.
  presrow:sóno,sèi,è,siàmo,siète,sóno.
  imperfrow:èro,èri,èra,eravàmo,eravàte,èrano.
  phisrow:fùi,fósti,fù*,fùmmo,fóste,fùrono.
  fut:sarò.
  sub:sìa.
  impsub:fóssi.
  improw:sìi:siàte.
  presp:essènte[rare]
>}}

; Including archaic and literary forms:
{{it-conj|essere<e\è\-,-,stàto:essùto[archaic]:sùto[archaic].
  presrow:sóno,sèi,è,siàmo:sémo[archaic],siète:sète[archaic],sóno:èmmo[archaic].
  imperfrow:èro:èra[literary],èri,èra,eravàmo:èramo[archaic],eravàte,èrano.
  phisrow:fùi,fósti:fùsti[archaic],fù*,fùmmo,fóste:fùste[archaic],fùrono:fùro[archaic]:fóre[archaic]:fòro[archaic].
  futrow:sarò,sarài,sarà:fìa[archaic]:fìe[archaic],sarémo,saréte,sarànno:fìano[archaic]:fìeno[archaic].
  condrow:sarèi:sarìa[archaic]:fòra[archaic],sarésti,sarèbbe:sarìa[archaic]:fòra[archaic],sarémmo,saréste,sarèbbero:sarìano[archaic]:fòro[archaic].
  subrow:sìa,siàmo,siàte,sìano:sìeno[literary].
  impsub:fóssi:fùssi[archaic].
  improw:sìi:siàte.
  ger:essèndo:sèndo[archaic].
  presp:essènte[rare]:ènte[archaic]
>}}

{{it-conj|fare<a/-,féci,fàtto.
  stem:fàce.
  presrow:fàccio:fò*[archaic or dialectal],fài,fà*,facciàmo,fàte,fànno.
  sub:fàccia.
  imp:fà*:fài:fà'
>}}

{{it-conj|potere<a:e[as an auxiliary, with main verbs taking ''essere'']/-,potéi:potètti[less common].
  presrow:pòsso,puòi,può*,possiàmo,potéte,pòssono.
  fut:potrò.
  noimp
>}}

{{it-conj|dire<a/+,dìssi,détto.
  stem:dìce.
  pres2p:dìte.
  imp:dì':*dì*
>}}

{{it-conj|dare<a/dò*:*dò*,dièdi:dètti,dàto.
  presrow:dò*:*dò*,dài,*dà*,diàmo,dàte,dànno.
  sub:dìa.
  fut:darò.
  impsub:déssi.
  imp:dài:da':*dà*
>}}

{{it-conj|dovere<a:e[as an auxiliary, with main verbs taking ''essere'']/dèvo:dévo:dèbbo:débbo#dève:déve.
  fut:dovrò.
  sub:dèbba:débba:dèva[rare]:déva[rare].
  noimp
>}}

; Including archaic and poetic forms:
{{it-conj|dovere<a:e[as an auxiliary, with main verbs taking ''essere'']/-.
  presrow:
    dèvo:dévo:dèbbo:débbo:dèggio[archaic or poetic]:déggio[archaic or poetic],
    dèvi:dévi:dèi[archaic, poetic or popular Tuscan]:déi[archaic, poetic or popular Tuscan],
    dève:déve:dèe[archaic, poetic or popular Tuscan]:dée[archaic, poetic or popular Tuscan]:dèbbe[archaic]:débbe[archaic],
    dobbiàmo,
    dovéte,
	dèvono:dévono:dèbbono:débbono:dènno[archaic or poetic]:dénno[archaic or poetic].
  fut:dovrò.
  sub:dèbba:débba:dèva[rare]:déva[rare]:dèggia[archaic or poetic]:déggia[archaic or poetic]:dèbbia[obsolete]:débbia[obsolete].
  noimp
>}}

{{it-conj|andare<e/-.
  presrow:vàdo:vò*[less common],vài,và*,andiàmo,andàte,vànno.
  fut:andrò.
  sub:vàda.
  imp:vài:và':và*
>}}

{{it-conj|valere<e:a[transitive]/vàlgo#à,vàlsi,vàlso.fut:varrò>}}

{{it-conj|vedere<a/védo:véggo[literary]:véggio[poetic]#é,vìdi,vìsto:vedùto[less popular].
  fut:vedrò
>}}

{{it-conj|venire<e/vèngo:vègno[archaic or poetic]#viène,vénni,venùto.
  fut:verrò
>}}

{{it-conj|sapere<a:e[as an auxiliary, with main verbs taking ''essere'']/-,sèppi.
  presrow:sò*,sài,sà*,sappiàmo,sapéte,sànno.
  fut:saprò.
  sub:sàppia.
  improw:sàppi:sappiàte
>}}

{{it-conj|togliere<a\ò\tòlgo,tòlsi,tòlto.fut:+:torrò[literary].presp:+>}}

{{it-conj|condurre<a\+,condùssi,condótto.stem:condùce>}}

{{it-verb|proporre<a\ó+\propóngo,propósi,propósto:propòsto.stem:propóne>}}

{{it-verb|trarre<a\tràggo,tràssi,tràtto.stem:tràe>}}
]=]

--[=[

FIXME:

1. Implement no_pres_stressed for aterir, garantir. (NOTE: Per RAE, garantir used in all forms in Argentina/Uruguay.) [DONE]
2. Support concluyo. [DONE]
3. Fixes for veo -> ve vs. preveo -> prevé. [DONE]
4. Various more irregular verbs, e.g. predecir, redecir, bendecir, maldecir. [DONE]
5. Raising of e -> i, o -> u before -iendo, -ió, etc. occurs only in -ir verbs. [DONE]
6. Raising of e -> i, o -> u happens before subjunctive -amos, -áis in -ir verbs. [DONE]
7. Implement reflexive verbs. [DONE]
8. Implement categories. [DONE]
9. Implement show_forms. [DONE]
10. Reconcile stems.vowel_alt from irregular verbs with vowel_alt from indicators. May require
    moving the irregular-verb handling code in construct_stems() into detect_indicator_spec(). [DONE]
11. Implement make_table. [DONE]
12. Vowel alternation should show u-ue (jugar), i-ie (adquirir), e-í (reír) alternations specially. [DONE]
13. Handle linking of multiword forms as is done in [[Module:es-headword]]. [DONE]
14. Implement comparison against previous module. [DONE]
15. Implement categorization of irregularities for individual tenses.
16. Support nocomb=1. [DONE]
17. (Possibly) display irregular forms in a different color, as with the old module.
18. (Possibly) display a "rule" description indicating the types of alternations.
19. Implement replace_reflexive_indicators().
20. Implement verbs with attached clitics e.g. [[pasarlo]], [[corrérsela]]. [DONE]
21. When footnote + tú/vos notation, add a space before tú/vos.
22. Fix [[erguir]] so ie-i vowel alternation produces ye- at beginning of word, similarly for errar. Also allow
    multiple vowel alternation specs in irregular verbs, for errar. Finally, ie should show as e-ye for errar
    and as e-ye-i for erguir. [DONE]
23. Figure out why red links in combined forms show up as black not red.
24. Consider including alternative superseded forms of verbs like [[ciar]] (e.g. pret_3s = cio, ció with footnote).
25. Allow conjugation of suffixes e.g. -ir, -ecer; need to fix in [[Module:inflection utilities]]. [DONE]
26. Allow specification of stems esp. so that footnotes can be hung off them; use + for the default.
27. Don't remove monosyllabic accents when conjugating suffixes. [DONE]
28. If multiword expression with no <>, add <> after first word, as with [[Module:es-headword]]. [DONE]
29. (Possibly) link the parts of a reflexive or cliticized infinitive, as done in [[Module:es-headword]]. [DONE]
30. Final fixes to allow [[Module:es-headword]] to use this module. [DONE]
--]=]

local lang = require("Module:languages").getByCode("it")
local m_string_utilities = require("Module:string utilities")
local m_links = require("Module:links")
local m_table = require("Module:table")
local iut = require("Module:inflection utilities")
local com = require("Module:it-common")

local force_cat = false -- set to true for debugging
local check_for_red_links = false -- set to false for debugging

local rfind = mw.ustring.find
local rmatch = mw.ustring.match
local rsplit = mw.text.split
local rsub = com.rsub

local function link_term(term, face)
	return m_links.full_link({ lang = lang, term = term }, face)
end

local all_persons_numbers = {
	["1s"] = "1|s",
	["2s"] = "2|s",
	["3s"] = "3|s",
	["1p"] = "1|p",
	["2p"] = "2|p",
	["3p"] = "3|p",
}

local person_number_list = { "1s", "2s", "3s", "1p", "2p", "3p", }
local sub_person_number_list = { "123s", "1p", "2p", "3p", }
local imp_person_number_list = { "2s", "3s", "1p", "2p", "3p", }
local impsub_person_number_list = { "12s", "3s", "1p", "2p", "3p", }

person_number_to_reflexive_pronoun = {
	["1s"] = "mi",
	["2s"] = "ti",
	["3s"] = "si",
	["1p"] = "ci",
	["2p"] = "vi",
	["3p"] = "si",
}

-- Define as forward references so `row_conjugation` can use them.
local add_present_indic, add_present_subj, add_imperative, add_past_historic
local generate_future_stem, generate_conditional_stem

local row_conjugation = {
	["pres"] = {
		rowdesc = "present",
		persnums = person_number_list,
		conjugate = add_present_indic,
	},
	["sub"] = {
		rowdesc = "present subjunctive",
		persnums = {"123s", "1p", "2p", "3p"},
		conjugate = add_present_subj,
	},
	["imp"] = {
		rowdesc = "imperative",
		persnums = {"2s", "2p"},
		conjugate = add_imperative,
	},
	["phis"] = {
		rowdesc = "past historic",
		persnums = person_number_list,
		conjugate = add_past_historic,
	},
	["imperf"] = {
		rowdesc = "imperfect",
		persnums = person_number_list,
		irregform_ending = "o",
		irregform_desc = "first-person imperfect",
		generate_default_stem = function(base) return iut.map_forms(base.verb.unaccented_stem,
			function(stem) return stem .. base.conj_vowel .. "v" end) end,
		conjugate = {"o", "i", "a", "àmo", "àte", "ano"},
	},
	["impsub"] = {
		rowdesc = "imperfect subjunctive",
		persnums = impsub_person_number_list,
		irregform_ending = "ssi",
		irregform_desc = "first/second-person imperfect subjunctive",
		generate_default_stem = function(base) return iut.map_forms(base.verb.unaccented_stem,
			function(stem) return stem .. base.conj_vowel end) end,
		conjugate = {"ssi", "sse", "ssimo", "ste", "ssero"},
	},
	["fut"] = {
		rowdesc = "future",
		persnums = person_number_list,
		irregform_ending = "ò",
		irregform_desc = "first-person future",
		generate_default_stem = generate_future_stem,
		conjugate = {"ò", "ài", "à", "émo", "éte", "ànno"},
	},
	["cond"] = {
		rowdesc = "conditional",
		persnums = person_number_list,
		irregform_ending = "éi",
		irregform_desc = "first-person conditional",
		generate_default_stem = generate_conditional_stem,
		conjugate = {"éi", "ésti", {"èbbe", "ébbe"}, "émmo", "éste", {"èbbero", "ébbero"}},
	},
}

local explicit_slot_set = m_table.listToSet(com.explicit_slots)

local all_verb_slots = {
	{"inf", "inf"},
	{"inf_linked", "inf"},
	{"ger", "ger"},
	{"pp", "past|part"},
	{"presp", "pres|part"},
}

local overridable_participle_slot_set = {
	["ger"] = true,
	["presp"] = true,
}

local overridable_slot_set = m_table.shallowcopy(overridable_participle_slot_set)

--[=[
Add entries for a slot with person/number variants.
`verb_slots` is the table to add to.
`slot_prefix` is the prefix of the slot, typically specifying the tense/aspect, and usually has a corresponding
   entry in `row_conjugation`.
`tag_suffix` is the set of inflection tags to add after the person/number tags when forming the accelerator entry,
   or "-" to indicate that no accelerator entry should be generated.
`persnum_list` is the list of person/number suffixes to add to `slot_prefix`. If omitted, it is taken from
   `row_conjugation`.
]=]
local function add_slot_personal(verb_slots, slot_prefix, tag_suffix, persnum_list)
	persnum_list = persnum_list or row_conjugation[slot_prefix].persnum
	for _, persnum in ipairs(persnum_list) do
		local persnum_tag = all_persons_numbers[persnum]
		local slot = slot_prefix .. persnum
		if tag_suffix == "-" then
			table.insert(verb_slots, {slot, "-"})
		else
			table.insert(verb_slots, {slot, persnum_tag .. "|" .. tag_suffix})
		end
		overridable_slot_set[slot] = true
	end
end

add_slot_personal(all_verb_slots, "pres", "pres|ind")
add_slot_personal(all_verb_slots, "sub", "pres|sub")
-- For the imperative, the improw: tag specifies only the 2s and 2p forms as the remaining are copied from the
-- present subjunctive (but can be individually overridden if necessary).
add_slot_personal(all_verb_slots, "imp", "imp", imp_person_number_list)
add_slot_personal(all_verb_slots, "negimp", "-", imp_person_number_list)
add_slot_personal(all_verb_slots, "phis", "phis")
add_slot_personal(all_verb_slots, "imperf", "impf|ind")
add_slot_personal(all_verb_slots, "impsub", "impf|sub")
add_slot_personal(all_verb_slots, "fut", "fut|ind")
add_slot_personal(all_verb_slots, "cond", "cond")

local reflexive_masc_forms = {
	["su"] = {"mi", "tu", "su", "nuestro", "vuestro", "su"},
	["sus"] = {"mis", "tus", "sus", "nuestros", "vuestros", "sus"},
	["sí"] = {"mí", "ti", "sí", "nosotros", "vosotros", "sí"},
}

local reflexive_fem_forms = {
	["su"] = {"mi", "tu", "su", "nuestra", "vuestra", "su"},
	["sus"] = {"mis", "tus", "sus", "nuestras", "vuestras", "sus"},
	["sí"] = {"mí", "ti", "sí", "nosotras", "vosotras", "sí"},
}

local reflexive_forms = {
	["se"] = {"me", "te", "se", "nos", "os", "se"},
	["suyo"] = {"mío", "tuyo", "suyo", "nuestro", "vuestro", "suyo"},
	["suya"] = {"mía", "tuya", "suya", "nuestra", "vuestra", "suya"},
	["suyos"] = {"míos", "tuyos", "suyos", "nuestros", "vuestros", "suyos"},
	["suyas"] = {"mías", "tuyas", "suyas", "nuestras", "vuestras", "suyas"},
}


local function skip_slot(base, slot, allow_overrides)
	if not allow_overrides and (base.basic_overrides[slot] or base.combined_overrides[slot] or
		base.refl and base.basic_reflexive_only_overrides[slot]) then
		-- Skip any slots for which there are overrides.
		return true
	end

	if not slot:find("[123]") then
		-- Don't skip non-personal slots.
		return false
	end

	if base.nofinite then
		return true
	end

	if base.only3s and (not slot:find("3s") or slot:find("^imp[123]") or slot:find("^negimp")) then
		-- diluviar, atardecer, neviscar
		return true
	end

	if base.only3sp and (not slot:find("3[sp]") or slot:find("^imp[123]") or slot:find("^negimp")) then
		-- atañer, concernir
		return true
	end

	return false
end


local function escape_reflexive_indicators(arg1)
	if not arg1:find("pron>") then
		return arg1
	end
	local segments = iut.parse_balanced_segment_run(arg1, "<", ">")
	-- Loop over every other segment. The even-numbered segments are angle-bracket specs while
	-- the odd-numbered segments are the text between them.
	for i = 2, #segments - 1, 2 do
		if segments[i] == "<mpron>" then
			segments[i] = "⦃⦃mpron⦄⦄"
		elseif segments[i] == "<fpron>" then
			segments[i] = "⦃⦃fpron⦄⦄"
		elseif segments[i] == "<pron>" then
			segments[i] = "⦃⦃pron⦄⦄"
		end
	end
	return table.concat(segments)
end


local function undo_escape_form(form)
	-- assign to var to throw away second value
	local newform = form:gsub("⦃⦃", "<"):gsub("⦄⦄", ">")
	return newform
end


local function remove_reflexive_indicators(form)
	-- assign to var to throw away second value
	local newform = form:gsub("⦃⦃.-⦄⦄", "")
	return newform
end


local function replace_reflexive_indicators(slot, form)
	if not form:find("⦃") then
		return form
	end
	error("Internal error: replace_reflexive_indicators not implemented yet")
end


local function add(base, slot, stems, endings, allow_overrides)
	if skip_slot(base, slot, allow_overrides) then
		return
	end
	local function do_combine_stem_ending(stem, ending)
		return com.combine_stem_ending(base, slot, stem, ending)
	end
	iut.add_forms(base.forms, slot, stems, endings, do_combine_stem_ending)
end


local function insert_form(base, slot, form)
	if not skip_slot(base, slot) then
		iut.insert_form(base.forms, slot, form)
	end
end


local function insert_forms(base, slot, forms)
	if not skip_slot(base, slot) then
		iut.insert_forms(base.forms, slot, forms)
	end
end


local function process_specs(base, destforms, slot, specs, is_finite, special_case)
	specs = specs or {{form = "+"}}
	for _, spec in ipairs(specs) do
		local decorated_form = spec.form
		local prespec, form, syntactic_gemination =
			rmatch(decorated_form, "^([*!#]*)(.-)(%**)$")
		local forms = special_case(base, form)
		forms = iut.convert_to_general_list_form(forms, spec.footnotes)
		if base.all_footnotes then
			forms = iut.convert_to_general_list_form(forms, base.all_footnotes)
		end
		for _, formobj in ipairs(forms) do
			local qualifiers = formobj.footnotes
			local form = formobj.form
			-- If the form is -, insert it directly, unlinked; we handle this specially
			-- below, turning it into special labels like "no past participle".
			if form ~= "-" then
				if prespec:find("!!") then
					qualifiers = iut.combine_footnotes({"[elevated style]"}, qualifiers)
					prespec = prespec:gsub("!!", "")
				end
				if prespec:find("!") then
					qualifiers = iut.combine_footnotes({"[careful style]"}, qualifiers)
					prespec = prespec:gsub("!", "")
				end
				if prespec:find("#") then
					qualifiers = iut.combine_footnotes({"[traditional]"}, qualifiers)
					prespec = prespec:gsub("#", "")
				end
				local preserve_monosyllabic_accent
				if prespec:find("%*") then
					preserve_monosyllabic_accent = true
					prespec = prespec:gsub("%*", "")
				end
				local unaccented_form
				if rfind(form, "^.*" .. com.V .. ".*" .. com.AV .. "$") then
					-- final accented vowel with preceding vowel; keep accent
					unaccented_form = form
				elseif rfind(form, com.AV .. "$") and preserve_monosyllabic_accent then
					unaccented_form = form
					qualifiers = iut.combine_footnotes(qualifiers, {"[with written accent]"})
				else
					unaccented_form = rsub(form, com.AV, function(v) return usub(unfd(v), 1, 1) end)
				end
				if syntactic_gemination == "*" then
					qualifiers = iut.combine_footnotes(qualifiers, {"[with following syntactic gemination]"})
				elseif syntactic_gemination == "**" then
					qualifiers = iut.combine_footnotes(qualifiers, {"[with optional following syntactic gemination]"})
				elseif syntactic_gemination ~= "" then
					error("Decorated form '" .. decorated_form .. "' has too many asterisks after it, use '*' for syntactic gemination and '**' for optional syntactic gemination")
				end
				form = "[[" .. unaccented_form .. "|" .. form .. "]]"
				if is_finite then
					if unaccented_form == "ho" then
						form = base.verb.finite_pref_ho .. form
					else
						form = base.verb.finite_pref .. form
					end
				end
			end
			iut.insert_form(destforms, slot, {form = form, footnotes = qualifiers})
		end
	end
end


local function add_default_verb_forms(base, from_headword)
	local ret = base.verb
	local raw_verb = ret.raw_verb

	if rfind(raw_verb, "r$") then
		if rfind(raw_verb, "[ou]r$") or base.rre then
			ret.verb = raw_verb .. "re"
		else
			ret.verb = raw_verb .. "e"
		end
	else
		ret.verb = raw_verb
	end

	local conj_vowel
	if base.explicit_stem_spec then
		local function explicit_stem_special_case(base, form)
			if form == "+" then
				error("Can't specify + with 'stem:'")
			end
			local stem, ending = rmatch(form, "^(.*)([aei])$")
			if not stem then
				error("Unrecognized stem '" .. form .. "', should end in -a, -e or -i")
			end
			if conj_vowel and conj_vowel ~= ending then
				error("Can't currently specify explicit stems with two different conjugation vowels (" .. conj_vowel
					.. " and " .. ending .. ")")
			end
			conj_vowel = ending
			return stem
		end
		-- Put the explicit stem in base.verb.stem.
		process_specs(base, ret, "stem", base.explicit_stem_spec, false, explicit_stem_special_case)
	else
		ret.stem, conj_vowel = rmatch(raw_verb, "^(.-)([aeiour])re?$")
		if not ret.stem then
			error("Unrecognized verb '" .. raw_verb .. "', doesn't end in -are, -ere, -ire, -rre, -ar, -er, -ir, -or or -ur")
		end
		-- Need to add base.all_footnotes here; it is added to other stems and base forms in process_specs(),
		-- but here we don't go through process_specs().
		ret.stem = iut.convert_to_general_list_form(ret.stem, base.all_footnotes)
		if not rfind(conj_vowel, "^[aei]$") then
			base.rre = true
		end
		if base.rre then
			if not from_headword then
				error("With syncopated verb '" .. raw_verb .. "', must use stem: to specify an explicit stem")
			else
				conj_vowel = "e"
			end
		end
	end

	base.conj_vowel = conj_vowel == "a" and "à" or conj_vowel == "e" and "é" or "ì"

	if base.rre then
		-- Can't generate defaults for verbs in -rre
		return
	end

	local unaccented_stems = iut.map_forms(ret.stem, function(stem) return export.remove_accents(stem) end)
	ret.unaccented_stem = unaccented_stems
	ret.pres = iut.map_forms(ret.stem, function(stem)
		if base.third then
			return conj_vowel == "a" and stem .. "a" or stem .. "e"
		else
			return stem .. "o"
		end
	end)
	ret.pres3s = iut.map_forms(stems, function(stem) return conj_vowel == "a" and stem .. "a" or stem .. "e" end)
	if conj_vowel == "i" then
		ret.isc_pres = iut.map_forms(unaccented_stems, function(stem) return stem .. "ìsco" end)
		ret.isc_pres3s = iut.map_forms(unaccented_stems, function(stem) return stem .. "ìsci" end)
	end
	ret.past = iut.flatmap_forms(unaccented_stems, function(stem)
		if conj_vowel == "a" then
			return {stem .. (base.third and "ò" or "ài")}
		elseif conj_vowel == "e" then
			return {stem .. (base.third and "é" or "éi"), stem .. (base.third and "étte" or "étti")}
		else
			return {stem .. (base.third and "ì" or "ìi")}
		end
	end)
	ret.pp = iut.map_forms(unaccented_stems, function(stem)
		if conj_vowel == "a" then
			return stem .. "àto"
		elseif conj_vowel == "e" then
			return rfind(stem, "[cg]$") and stem .. "iùto" or stem .. "ùto"
		else
			return stem .. "ìto"
		end
	end)
end


local function create_base_forms(base)
	com.add_default_verb_forms(base)

	for _, explicit_specs_spec in ipairs({
		{"pres", "finite", comp.pres_special_case},
		{"pres3s", "finite", comp.pres3s_special_case},
		{"phis", "finite", comp.phis_special_case},
		{"pp", false, comp.pp_special_case},
	}) do
		local slot, is_finite, special_case = unpack(explicit_specs_spec)
		process_specs(base, base.explicit_forms, slot, base.explicit_specs[slot], is_finite, special_case)
	end

	local function explicit_special_case(base, form)
		return form
	end

	for _, explicit_slot in ipairs(com.explicit_slots) do
		if base.explicit_specs[explicit_slot] then
			process_specs(base, base.explicit_forms, explicit_slot, base.explicit_specs[explicit_slot], explicit_slot ~= "imp",
				explicit_special_case)
		end
	end

	for rowslot, rowconj in pairs(row_conjugation) do
		if base.explicit_row_specs[rowslot] then
			for _, persnum in ipairs(rowconj.i...) do
				...
			end
		end
	end

	iut.insert_form(base.forms, "lemma", {form = base.lemma})
	-- Add linked version of lemma for use in head=.
	if base.root_stressed_inf then
		com.do_root_stressed_inf(iut, base, base.root_stressed_inf)
	else
		com.do_ending_stressed_inf(iut, base)
	end
end


local function handle_explicit_row(base, row_slot)
	if base.explicit_row_specs[row_slot] then
		for persnum, specs in pairs(base.explicit_row_specs[row_slot]) do
			local slot = row_slot .. persnum
			local existing_generated_form = base.forms[slot]
			if not existing_generated_form then
				error("Internal error: Explicit row spec for slot " .. slot .. " being processed and no "
					.. "default-generated forms available")
			end
			local function explicit_special_case(base, form)
				if form == "+" then
					return existing_generated_form
				end
				return form
			end
			base.forms[slot] = nil -- erase existing form before generating override
			process_specs(base, base.forms, slot, specs, "finite", explicit_special_case)
		end
	end
end


local function handle_overrides_for_row(base, row_slot)
	local rowspec = row_conjugation[row_slot]
	if not rowspec then
		error("Internal error: No row conjugation spec for " .. row_slot)
	end
	for _, persnum in ipairs(rowspec.persnums) do
		local slot = row_slot .. persnum
		if base.override_specs[slot] then
			local existing_generated_form = base.forms[slot]
			if not existing_generated_form then
				error("Internal error: Explicit override spec for slot " .. slot .. " being processed and no "
					.. "default-generated forms available")
			end
			local function override_special_case(base, form)
				if form == "+" then
					return existing_generated_form
				end
				return form
			end
			base.forms[slot] = nil -- erase existing form before generating override
			process_specs(base, base.forms, slot, base.override_specs[slot], "finite", override_special_case)
		end
	end
end


-- Generate the present indicative. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
-- Defined earlier as a forward reference.
add_present_indic = function(base, prefix)
	local function addit(pers, stems, endings)
		add(base, prefix .. pers, stems, endings)
	end

	addit("1s", base.explicit_forms.pres, "")
	local pres_1s_stem = iut.map_forms(base.explicit_forms.pres, function(form)
		if not form:find("o$") then
			error("presrow: must be given in order to generate the present indicative because explicit first-person "
				.. "singular present indicative '" .. form .. "' does not end in -o")
		end
		return rsub(form, "o$", "")
	end)
	addit("3p", pres_1s_stem, base.conj_vowel == "à" and "ano" or "ono")
	local pres_23s_stem
	if base.explicit_forms.pres3s then
		pres_23s_stem = iut.map_forms(base.explicit_forms.pres3s, function(form)
			if not form:find("[ae]$") then
				error("presrow: must be given in order to generate the present indicative because explicit third-person "
					.. "singular present indicative '" .. form .. "' does not end in -a or -e")
			end
			return rsub(form, "[ae]$", "")
		end)
	else
		pres_23s_form = base.explicit_stem_spec and base.verb.stem or base.root_stressed_stem or pres_1s_stem
	end
	addit("2s", pres_23s_stem, "i")
	addit("3s", pres_23s_stem, base.conj_vowel == "à" and "a" or "e")
	addit("1p", base.verb.stem, "iàmo")
	addit("2p", base.verb.stem, base.conj_vowel .. "te")
end


-- Generate the present subjunctive. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
-- Defined earlier as a forward reference.
add_present_subj = function(base, prefix)
	local function addit(pers, stems, endings)
		add(base, prefix .. pers, stems, endings)
	end
	local function insit(pers, forms)
		insert_forms(base, prefix .. pers, forms)
	end

	-- Generate the 123s and 3p forms. Don't copy the 123s form to the 3p form with -no added in case there's an
	-- override of the 123s form (in which case the 123s form won't be added).
	if base.irregrow_forms.sub then
		addit("123s", base.irregrow_forms.sub, "")
		addit("3p", base.irregrow_forms.sub, "no")
	else
		local pres_1s_stem = iut.map_forms(base.forms.pres_1s, function(form)
			if not form:find("o$") then
				error("sub: or subrow: must be given in order to generate the singular present subjunctive "
					.. "because first-person singular present indicative '" .. form .. "' does not end in -o")
			end
			return rsub(form, "o$", "")
		end)
		addit("123s", s123_stem, base.conj_vowel == "à" and "i" or "a")
		addit("3p", s123_stem, base.conj_vowel == "à" and "ino" or "ano")
	end

	-- Copy present indicative 1p to present subjunctive.
	insit("1p", iut.map_forms(base.forms.pres_1p, iut.identity end))
	-- Generate present subjunctive 2p from present indicative 1p by replacing -mo with -te.
	insit("2p", iut.map_forms(base.forms.pres_1p, function(form)
		if not form:find("mo$") then
			error("subrow: must be given in order to generate the second-person plural present subjunctive "
				.. "because first-person plural present indicative '" .. form .. "' does not end in -mo")
		end
		return rsub(form, "mo$", "te")
	end)
end


-- Generate the imperative. See "RULES FOR CONJUGATION" near the top of the file for the detailed rules.
-- Defined earlier as a forward reference.
add_imperative = function(base, prefix)
	if base.noimp then
		return
	end

	local function addit(pers, stems, endings)
		add(base, prefix .. pers, stems, endings)
	raq
	local function insit(pers, forms)
		insert_forms(base, prefix .. pers, forms)
	end

	if base.irregrow_forms.imp then
		addit("2s", base.irregrow_forms.imp, "")
	elseif base.conj_vowel == "à" then
		-- Copy present indicative 3s to imperative 2s.
		insit("2s", iut.map_forms(base.forms.pres_3s, iut.identity end))
	else
		-- Copy present indicative 2s to imperative 2s.
		insit("2s", iut.map_forms(base.forms.pres_2s, iut.identity end))
	end
	-- Copy present indicative 2p to imperative 2p.
	insit("2p", iut.map_forms(base.forms.pres_2p, iut.identity end))
	-- Copy present subjunctive 3s, 1p, 2p to imperative.
	insit("3s", iut.map_forms(base.forms.sub_3s, iut.identity end))
	insit("1p", iut.map_forms(base.forms.sub_1p, iut.identity end))
	insit("2p", iut.map_forms(base.forms.sub_2p, iut.identity end))
end


-- Defined earlier as a forward reference.
add_past_historic = function(base, prefix)
	for _, form in ipairs(base.stems.phis_form) do
		local function add_phis(pref, s1, s2, s3, p1, p2, p3)
			local newform = {form = pref, footnotes = form.footnotes}
			local function addit(pers, endings)
				add(base, prefix .. pers, newform, endings)
			end
			addit("1s", s1)
			addit("2s", s2)
			addit("3s", s3)
			addit("1p", p1)
			addit("2p", p2)
			addit("3p", p3)
		end
		while true do
			local pref = rmatch(form.form, "^(.*)ài$")
			if pref then
				add_phis(pref, "ài", "àsti", "ò", "àmmo", "àste", "àrono")
				break
			end
			pref = rmatch(form.form, "^(.*)éi$")
			if pref then
				add_phis(pref, "éi", "ésti", "é", "émmo", "éste", "érono")
				break
			end
			pref = rmatch(form.form, "^(.*)[èé]tti$")
			if pref then
				add_phis(pref, {{form = "étti"}, {form = "ètti", footnotes = {"[traditional]"}}},
					"ésti", {{form = "étte"}, {form = "ètte", footnotes = {"[traditional]"}}},
					"émmo", "éste", {{form = "éttero"}, {form = "èttero", footnotes = {"[traditional]"}}})
				break
			end
			pref = rmatch(form.form, "^(.*)ìi$")
			if pref then
				add_phis(pref, "ìi", "ìsti", "ì", "ìmmo", "ìste", "ìrono")
				break
			end
			pref = rmatch(form.form, "^(.*)i$")
			if pref then
				add_phis(pref, "i", {}, "e", {}, {}, "ero")
				add_phis(base.verb.stem, {}, base.conj_vowel .. "sti", {}, base.conj_vowel .. "mmo",
					base.conj_vowel .. "ste", {})
				break
			end
			error("phisrow: must be given in order to generate the past historic because explicit first-person "
				.. "singular past historic '" .. form.form .. "' does not end in -i")
		end
	end
end


local function get_stem_for_row_conjugation(base, rowslot, rowconj)
	local stem
	if base.irregrow_forms[rowslot] then
		stem = iut.map_forms(base.irregrow_forms[rowslot], function(form)
			if form == "+" then
				return rowconj.generate_default_stem(base)
			end
			if not form:find(rowconj.irregform_ending .. "$") then
				error(rowslot .. "row: must be given in order to generate the " .. rowconj.rowdesc .. " because"
					.. "explicit " .. rowconj.irregform_desc .. " '" .. form .. "' does not end in -"
					.. rowconj.irregform_ending)
			end
			return rsub(form, rowconj.irregform_ending .. "$", "")
		end)
	else
		stem = rowconj.generate_default_stem(base)
	end
	return stem
end


local function conjugate_row(base, rowslot)
	local rowconj = row_conjugation[rowslot]
	if not rowconj then
		error("Internal error: Unrecognized row slot '" .. rowslot .. "'")
	end

	local stem = get_stem_for_row_conjugation(base, rowslot, rowconj)

	if type(rowconj.conjugate) == "table" then
		if #rowconj.conjugate ~= #rowconj.persnum then
			error("Internal error: Expected " .. #rowconj.persnum .. " elements for row slot '" .. rowslot
				.. ", but saw " .. #rowconj.conjugate)
		end
		for _, persnum in ipairs(#rowconj.persnum) do
			add(base, rowconj.prefix .. "_" .. rowconj.persnum[persnum], stem, rowconj.conjugate[persnum])
		end
	else
		rowconj.conjugate(base, rowconj.prefix, stem)
	end

	handle_explicit_row(base, rowslot)
	handle_overrides_for_row(base, rowslot)
end


-- Defined earlier as a forward reference.
generate_future_stem = function(base, prefix)
	return iut.map_forms(base.verb.unaccented_stem, function(stem)
		if base.conj_vowel == "à" then
			if stem:find("[cg]$") then
				return stem .. "her"
			elseif stem:find("[cg]i$") then
				return rsub(stem, "i$", "er")
			else
				return stem .. "er"
			end
		else
			return base.verb.verb:gsub("e$", "")
		end
	end)
end


-- Defined earlier as a forward reference.
generate_conditional_stem = function(base, prefix)
	local futrowconj = row_conjugation.fut
	if not futrowconj then
		error("Internal error: Can't find 'fut' in row_conjugation")
	end

	return get_stem_for_row_conjugation(base, "fut", futrowconj)
end


local function add_participles(base)
	-- Do the participles.
	local function addit(slot, stems, ending)
		add3(base, slot, base.prefix, stems, ending)
	end
	insert_form(base, "inf", {form = base.verb})
	addit("ger", stems.pres_unstressed, base.conj_vowel == "à" and "àndo" or "èndo")
	addit("presp", stems.pres_unstressed, base.conj_vowel == "à" and "ànte" or "ènte")
	addit("pp", stems.pp, "o")
end


-- Add the clitic pronouns in `pronouns` to the forms in `base_slot`. If `do_combined_slots` is given,
-- store the results into the appropriate combined slots, e.g. `imp_2s_comb_lo` for second singular imperative + lo.
-- Otherwise, directly modify `base_slot`. The latter case is used for handling reflexive verbs, and in that case
-- `pronouns` should contain only a single pronoun.
local function add_forms_with_clitic(base, base_slot, pronouns, do_combined_slots)
	if not base.forms[base_slot] then
		-- This can happen, e.g. in only3s/only3sp verbs.
		return
	end
	for _, form in ipairs(base.forms[base_slot]) do
		-- Figure out that correct accenting of the verb when a clitic pronoun is attached to it. We may need to
		-- add or remove an accent mark:
		-- (1) No accent mark currently, none needed: infinitive sentar because of sentarlo; imperative singular
		--     ten because of tenlo;
		-- (2) Accent mark currently, still needed: infinitive oír because of oírlo;
		-- (3) No accent mark currently, accent needed: imperative singular siente -> siénte because of siéntelo;
		-- (4) Accent mark currently, not needed: imperative singular está -> estálo, sé -> selo.
		local syllables = com.syllabify(form.form)
		local sylno = com.stressed_syllable(syllables)
		table.insert(syllables, "lo")
		local needs_accent = com.accent_needed(syllables, sylno)
		if needs_accent then
			syllables[sylno] = com.add_accent_to_syllable(syllables[sylno])
		else
			syllables[sylno] = com.remove_accent_from_syllable(syllables[sylno])
		end
		table.remove(syllables) -- remove added clitic pronoun
		local reaccented_verb = table.concat(syllables)
		for _, pronoun in ipairs(pronouns) do
			local cliticized_verb
			-- Some further special cases.
			if base_slot == "imp_1p" and (pronoun == "nos" or pronoun == "os") then
				-- Final -s disappears: sintamos + nos -> sintámonos, sintamos + os -> sintámoos
				cliticized_verb = reaccented_verb:gsub("s$", "") .. pronoun
			elseif base_slot == "imp_2p" and pronoun == "os" then
				-- Final -d disappears, which may cause an accent to be required:
				-- haced + os -> haceos, sentid + os -> sentíos
				if reaccented_verb:find("id$") then
					cliticized_verb = reaccented_verb:gsub("id$", "íos")
				else
					cliticized_verb = reaccented_verb:gsub("d$", "os")
				end
			else
				cliticized_verb = reaccented_verb .. pronoun
			end
			if do_combined_slots then
				insert_form(base, base_slot .. "_comb_" .. pronoun,
					{form = cliticized_verb, footnotes = form.footnotes})
			else
				form.form = cliticized_verb
			end
		end
	end
end


-- Generate the combinations of verb form (infinitive, gerund or various imperatives) + clitic pronoun.
local function add_combined_forms(base)
	for _, base_slot_and_pronouns in ipairs(verb_slot_combined_rows) do
		local base_slot, pronouns = unpack(base_slot_and_pronouns)
		-- Skip non-infinitive/gerund combinations for reflexive verbs. We will copy the appropriate imperative
		-- combinations later.
		if not base.refl or base_slot == "inf" or base_slot == "ger" then
			add_forms_with_clitic(base, base_slot, pronouns, "do combined slots")
		end
	end
end


local function process_slot_overrides(base, do_basic, reflexive_only)
	local overrides = reflexive_only and base.basic_reflexive_only_overrides or
		do_basic and base.basic_overrides or base.combined_overrides
	for slot, forms in pairs(overrides) do
		add(base, slot, base.prefix, forms, "allow overrides")
	end
end


-- Add a reflexive pronoun or fixed clitic, e.g. [[lo]], as appropriate to the base form that were generated.
-- `do_joined` means to do only the forms where the pronoun is joined to the end of the form; otherwise, do only the
-- forms where it is not joined and precedes the form.
local function add_reflexive_or_fixed_clitic_to_forms(base, do_reflexive, do_joined)
	for _, slotaccel in ipairs(all_verb_slots) do
		local slot, accel = unpack(slotaccel)
		local clitic
		if not do_reflexive then
			clitic = base.clitic
		elseif slot:find("[123]") then
			local persnum = slot:match("^.*([123][sp])$")
			clitic = person_number_to_reflexive_pronoun[persnum]
		else
			clitic = "si"
		end
		if base.forms[slot] then
			if slot == "inf" or slot == "ger" or slot:find("^imp[123]") then
				if do_joined then
					add_forms_with_clitic(base, slot, {clitic})
				end
			elseif do_reflexive and slot == "pp" or slot == "inf_linked" then
				-- do nothing with reflexive past participles or with infinitive linked (handled at the end)
			elseif slot:find("^negimp") then
				error("Internal error: Should not have forms set for negative imperative at this stage")
			elseif not do_joined then
				-- Add clitic as separate word before all other forms. Check whether form already has brackets
				-- (as will be the case if the form has a fixed clitic).
				for _, form in ipairs(base.forms[slot]) do
					if base.args.noautolinkverb then
						form.form = clitic .. " " .. form.form
					else
						local clitic_pref = "[[" .. clitic .. "]] "
						if form.form:find("%[%[") then
							form.form = clitic_pref .. form.form
						else
							form.form = clitic_pref .. "[[" .. form.form .. "]]"
						end
					end
				end
			end
		end
	end
end


local function copy_subjunctives_to_imperatives(base)
	-- Copy subjunctives to imperatives, unless there's an override for the given slot (as with the imp_1p of [[ir]]).
	for _, persnum in ipairs({"3s", "1p", "3p"}) do
		local from = "sub" .. persnum
		local to = "imp" .. persnum
		insert_forms(base, to, iut.map_forms(base.forms[from], function(form) return form end))
	end
end


local function handle_infinitive_linked(base)
	-- Compute linked versions of potential lemma slots, for use in {{it-verb}}.
	-- We substitute the original lemma (before removing links) for forms that
	-- are the same as the lemma, if the original lemma has links.
	for _, slot in ipairs({"inf"}) do
		insert_forms(base, slot .. "_linked", iut.map_forms(base.forms[slot], function(form)
			if form == base.lemma and rfind(base.linked_lemma, "%[%[") then
				return base.linked_lemma
			else
				return form
			end
		end))
	end
end


local function generate_negative_imperatives(base)
	-- Copy subjunctives to negative imperatives, preceded by "no".
	for _, persnum in ipairs({"2s", "3s", "1p", "2p", "3p"}) do
		local from = "pres_sub_" .. persnum
		local to = "neg_imp_" .. persnum
		insert_forms(base, to, iut.map_forms(base.forms[from], function(form)
			if base.args.noautolinkverb then
				return "no " .. form
			elseif form:find("%[%[") then
				-- already linked, e.g. when reflexive
				return "[[no]] " .. form
			else
				return "[[no]] [[" .. form .. "]]"
			end
		end))
	end
end


local function copy_imperatives_to_reflexive_combined_forms(base)
	local copy_table = {
		{"imp_2s", "imp_2s_comb_te"},
		{"imp_3s", "imp_3s_comb_se"},
		{"imp_1p", "imp_1p_comb_nos"},
		{"imp_2p", "imp_2p_comb_os"},
		{"imp_3p", "imp_3p_comb_se"},
	}

	-- Copy imperatives (with the clitic reflexive pronoun already added) to the appropriate "combined" reflexive
	-- forms.
	for _, entry in ipairs(copy_table) do
		local from, to = unpack(entry)
		-- Need to call map_forms() to clone the form objects because insert_forms() doesn't clone them, and may
		-- side-effect them when inserting footnotes.
		insert_forms(base, to, iut.map_forms(base.forms[from], function(form) return form end))
	end
end


local function add_missing_links_to_forms(base)
	-- Any forms without links should get them now. Redundant ones will be stripped later.
	for slot, forms in pairs(base.forms) do
		for _, form in ipairs(forms) do
			if not form.form:find("%[%[") then
				form.form = "[[" .. form.form .. "]]"
			end
		end
	end
end


local function conjugate_verb(base)
	add_present_indic(base)
	process_slot_overrides(base, "pres")
	add_present_subj(base)
	add_imperative(base)
	add_non_present(base)
	-- This should happen before add_combined_forms() so overrides of basic forms end up part of the combined forms.
	-- This should happen after process_slot_overrides() in case a derived slot is based on an override (as with the
	-- imp_3s of [[dar]], [[estar]]).
	copy_subjunctives_to_imperatives(base)
	-- This should happen after process_slot_overrides() because overrides may have accents in them that need to be
	-- removed. (This happens e.g. for most present indicative forms of [[ver]], which have accents in them for the
	-- prefixed derived verbs, but the accents shouldn't be present in the base verb.)
	remove_monosyllabic_accents(base)
	if not base.nocomb then
		-- This should happen before add_reflexive_pronouns() because the combined forms of reflexive verbs don't have
		-- the reflexive attached.
		add_combined_forms(base)
	end
	-- We need to add joined reflexives, then joined and non-joined clitics, then non-joined reflexives, so we get
	-- [[házmelo]] but [[no]] [[me]] [[lo]] [[haga]].
	if base.refl then
		-- This should happen after remove_monosyllabic_accents() so the * marking the preservation of monosyllabic
		-- accents doesn't end up in the middle of a word.
		add_reflexive_or_fixed_clitic_to_forms(base, "do reflexive", "do joined")
		process_slot_overrides(base, "do basic", "do reflexive") -- do reflexive-only basic slot overrides
	end
	if base.clitic then
		-- This should happen after reflexives are added.
		add_reflexive_or_fixed_clitic_to_forms(base, false, "do joined")
		add_reflexive_or_fixed_clitic_to_forms(base, false, false)
	end
	if base.refl then
		add_reflexive_or_fixed_clitic_to_forms(base, "do reflexive", false)
	end
	-- This should happen after add_reflexive_or_fixed_clitic_to_forms() so negative imperatives get the reflexive pronoun
	-- and clitic in them.
	generate_negative_imperatives(base)
	if not base.nocomb then
		if base.refl then
			-- This should happen after process_slot_overrides() for reflexive-only basic slots so the overridden
			-- forms (e.g. [[idos]]/[[iros]] for [[ir]]) get appropriately copied.
			copy_imperatives_to_reflexive_combined_forms(base)
		end
		process_slot_overrides(base, false) -- do combined slot overrides
	end
	-- This should happen before add_missing_links_to_forms() so that the comparison `form == base.lemma`
	-- in handle_infinitive_linked() works correctly and compares unlinked forms to unlinked forms.
	handle_infinitive_linked(base)
	if not base.args.noautolinkverb then
		add_missing_links_to_forms(base)
	end
end


local function parse_indicator_spec(angle_bracket_spec, lemma)
	-- `forms` contains the final per-slot forms. This is processed further in [[Module:inflection-utilities]].
	--    This is a table indexed by slot (e.g. "pres1s"). Each value in the table is a list of items of the form
	--    {form = FORM, footnotes = FOOTNOTES} where FORM is the actual generated form and FOOTNOTES is either nil
	--    or a list of footnotes (which must be surrounded by brackets, e.g. "[archaic]").
	-- `genforms` contains the forms generated by the various form-generating functions such as add_present_indic().
	--    `forms` and `genforms` will differ in the presence of overrides, which are included in the former but not
	--    the latter. We separate the two so that e.g. we can use + in overrides to request the generated forms in
	--    `genforms`.
	-- `explicit_specs` contains forms specified by the user using either the prefixes 'imperf:', 'fut:', 'sub:',
	--    'impsub:' or 'imp:' or in the format e.g. "vèngo:vègno[archaic or poetic]#viène,vénni,venùto" or "é:#è".
	--    The key is the prefix ("imperf", "fut", etc., for the former format) or "pres", "pres3s", "phis" or "pp"
	--    (for the latter format). The value is in the same form as for `forms` and `genforms`, but the FORM contained
	--    in it is the actual user-specified form, which may be e.g. "#è" rather than a verb form, and needs to
	--    be processed to generate the actual form. A spec may be "+" to insert the default-generated form or forms,
	--    or "-" to indicate that this form doesn't exist.
	-- `explicit_forms` contains the processed versions of the specs contained in `explicit_specs`. The keys are as
	--    in `explicit_specs` and the values are the same as for `forms` and `genforms`.
	-- `explicit_row_specs` contains user-specified forms for a full tense/aspect row using 'presrow:', 'subrow:', etc.
	--    The key is "pres", "sub", etc. (i.e. minus the "row" suffix). The value is another table indexed by the
	--    person/number suffix (e.g. "1s", "2s", etc. for "pres"; "123s", "1p", "2p", etc. for "sub"), whose values
	--    are in the same format as `explicit_specs`.
	-- `explicit_row_forms` contains the processed versions of `explicit_row_specs`. The key is as for
	--    `explicit_row_specs`, while the value is another table indexed by the person/number suffix ("1s", "2s",
	--    etc.), whose values are in the same format as for `forms` and `genforms`.
	-- `override_specs` contains user-specified forms using 'pres1s:', 'sub3p:', etc. The key is the slot ("pres1s",
	--   "sub3p", etc.) and the value is of the same format as `explicit_specs`.
	-- `override_forms` contains the processed versions of `override_specs`, as with `explicit_forms` vs.
	--   `explicit_specs`.
	local base = {forms = {}, genforms = {}, explicit_specs = {}, explicit_forms = {}, explicit_row_specs = {},
		explicit_row_forms = {}, override_specs = {}, override_forms = {}}
	local function parse_err(msg)
		error(msg .. ": " .. angle_bracket_spec)
	end

	local function parse_qualifiers(separated_group)
		local qualifiers
		for j = 2, #separated_group - 1, 2 do
			if separated_group[j + 1] ~= "" then
				parse_err("Extraneous text after bracketed qualifiers: '" .. table.concat(separated_group) .. "'")
			end
			if not qualifiers then
				qualifiers = {}
			end
			table.insert(qualifiers, separated_group[j])
		end
		return qualifiers
	end

	local function fetch_specs(comma_separated_group, allow_blank)
		local colon_separated_groups = iut.split_alternating_runs(comma_separated_group, ":")
		if allow_blank and #colon_separated_groups == 1 and #colon_separated_groups[1] == 1 and
			colon_separated_groups[1][1] == "" then
			return nil
		end
		local specs = {}
		for _, colon_separated_group in ipairs(colon_separated_groups) do
			local form = colon_separated_group[1]
			if form == "" then
				parse_err("Blank form not allowed here, but saw '" ..
					table.concat(comma_separated_group) .. "'")
			end
			local new_spec = {form = form, footnotes = parse_qualifiers(colon_separated_group)}
			for _, existing_spec in ipairs(specs) do
				if m_table.deepEquals(existing_spec, new_spec) then
					parse_err("Duplicate spec '" .. table.concat(colon_separated_group) .. "'")
				end
			end
			table.insert(specs, new_spec)
		end
		return specs
	end

	if lemma == "" then
		lemma = data.pagename
	end
	base.lemma = m_links.remove_links(lemma)
	base.verb = com.analyze_verb(lemma)

	local inside = angle_bracket_spec:match("^<(.*)>$")
	assert(inside)

	local segments = iut.parse_balanced_segment_run(inside, "[", "]")
	local dot_separated_groups = iut.split_alternating_runs(segments, "%s*%.%s*")
	for i, dot_separated_group in ipairs(dot_separated_groups) do
		local first_element = dot_separated_group[1]

		if i == 1 then -- first dot-separated group is PRES,PHIS,PP or PRES#PRES3S,PHIS,PP or similar.
			local comma_separated_groups = iut.split_alternating_runs(dot_separated_group, "%s*[,\\/]%s*", "preserve splitchar")
			local presind = 1
			local first_separator = #comma_separated_groups > 1 and
				com.strip_spaces(comma_separated_groups[2][1])
			if base.verb.is_reflexive then
				if #comma_separated_groups > 1 and first_separator ~= "," then
					presind = 3
					-- Fetch root-stressed infinitive, if given.
					local specs = fetch_specs(comma_separated_groups[1], "allow blank")
					if first_separator == "\\" then
						-- For verbs like [[scegliersi]] and [[proporsi]], allow either 'é\scélgo' or '\é\scélgo'
						-- and similarly either 'ó+\propóngo' or '\ó+\propóngo'.
						if specs == nil then
							if #comma_separated_groups > 3 and com.strip_spaces(comma_separated_groups[4][1]) == "\\" then
								base.root_stressed_inf = fetch_specs(comma_separated_groups[3])
								presind = 5
							else
								base.root_stressed_inf = {{form = "+"}}
							end
						else
							base.root_stressed_inf = specs
						end
					elseif specs ~= nil then
						parse_err("With reflexive verb, can't specify anything before initial slash, but saw '"
							.. table.concat(comma_separated_groups[1]))
					end
				end
				base.aux = {{form = "essere"}}
			else -- non-reflexive
				if #comma_separated_groups == 1 or first_separator == "," then
					parse_err("With non-reflexive verb, use a spec like AUX/PRES, AUX\\PRES, AUX/PRES,PAST,PP or similar")
				end
				presind = 3
				-- Fetch auxiliary or auxiliaries.
				local colon_separated_groups = iut.split_alternating_runs(comma_separated_groups[1], ":")
				for _, colon_separated_group in ipairs(colon_separated_groups) do
					local aux = colon_separated_group[1]
					if aux == "a" then
						aux = "avere"
					elseif aux == "e" then
						aux = "essere"
					elseif aux == "-" then
						if #colon_separated_group > 1 then
							parse_err("No footnotes allowed with '-' spec for auxiliary")
						end
						aux = nil
					else
						parse_err("Unrecognized auxiliary '" .. aux ..
							"', should be 'a' (for [[avere]]), 'e' (for [[essere]]), or '-' if no past participle")
					end
					if aux then
						if base.aux then
							for _, existing_aux in ipairs(base.aux) do
								if existing_aux.form == aux then
									parse_err("Auxiliary '" .. aux .. "' specified twice")
								end
							end
						else
							base.aux = {}
						end
						table.insert(base.aux, {form = aux, footnotes = parse_qualifiers(colon_separated_group)})
					end
				end

				-- Fetch root-stressed infinitive, if given.
				if first_separator == "\\" then
					if #comma_separated_groups > 3 and com.strip_spaces(comma_separated_groups[4][1]) == "\\" then
						base.root_stressed_inf = fetch_specs(comma_separated_groups[3])
						presind = 5
					else
						base.root_stressed_inf = {{form = "+"}}
					end
				end
			end

			-- Parse present
			local hash_separated_groups = iut.split_alternating_runs(comma_separated_groups[presind], "%s*#%s*")
			if #hash_separated_groups > 2 then
				parse_err("At most one hash sign (#) can appear in present tense specs")
			end
			base.explicit_specs.pres = fetch_specs(hash_separated_groups[1])
			if #hash_separated_groups == 2 then
				base.explicit_specs.pres3s = fetch_specs(hash_separated_groups[2])
			end

			-- Parse past historic
			if #comma_separated_groups > presind then
				if com.strip_spaces(comma_separated_groups[presind + 1][1]) ~= "," then
					parse_err("Use a comma not slash to separate present from past historic")
				end
				base.explicit_specs.past = fetch_specs(comma_separated_groups[presind + 2])
			end

			-- Parse past participle
			if #comma_separated_groups > presind + 2 then
				if com.strip_spaces(comma_separated_groups[presind + 3][1]) ~= "," then
					parse_err("Use a comma not slash to separate past historic from past participle")
				end
				base.explicit_specs.pp = fetch_specs(comma_separated_groups[presind + 4])
			end

			if #comma_separated_groups > presind + 4 then
				parse_err("Extraneous text after past participle")
			end
		elseif first_element == "only3s" or first_element == "only3sp" or first_element == "rre" then
			if #dot_separated_group > 1 then
				parse_err("No footnotes allowed with '" .. first_element .. "' spec")
			end
			base[first_element] = true
		else
			local first_element_prefix, first_element_minus_prefix = rmatch(first_element,
				"^%s*([a-z0-9_]+)%s*:%s*(.-)%s*$")
			if not first_element_prefix then
				parse_err("Dot-separated element should be either 'only3s', 'only3p', 'rre' or be of the form "
					.. "'PREFIX:SPEC', but saw '" .. table.concat(dot_separated_group) .. "'")
			end
			dot_separated_group[1] = first_element_minus_prefix
			if first_element_prefix == "stem" then
				base.explicit_stem_spec = fetch_specs(dot_separated_group)
			elseif explicit_slot_set[first_element_prefix] then
				base.explicit_specs[first_element_prefix] = fetch_specs(dot_separated_group)
			elseif overridable_slot_set[first_element_prefix] then
				base.override_specs[first_element_prefix] = fetch_specs(dot_separated_group)
			elseif first_element_prefix:find("row$") then
				local explicit_row_slot = rmatch(first_element_prefix, "^(.*)row$")
				if row_conjugation[explicit_row_slot] then
					local rowspec = row_conjugation[explicit_row_slot]
					local comma_separated_groups = iut.split_alternating_runs(dot_separated_group, "%s*,%s*")
					if #comma_separated_groups != #rowspec.persnums then
						parse_err("For " .. explicit_row_slot .. "row:, expected " .. #rowspec.persnums
							.. " forms but saw " .. #comma_separated_groups .. " in '"
							.. table.concat(dot_separated_group) .. "'")
					end
					base.explicit_row_specs[explicit_row_slot] = {}
					for i, persnum in ipairs(persnums) do
						base.explicit_row_specs[explicit_row_slot][persnum] = fetch_specs(comma_separated_group[i])
					end
				else
					local explicit_row_slots = {}
					for explicit_row_slot, _ in pairs(row_conjugation) do
						table.insert(explicit_row_slots, explicit_row_slot .. "row:")
					end
					table.sort(explicit_row_slots)
					parse_err("Explicit row spec should begin with one of " .. m_table.serialCommaJoin(explicit_row_slots)
						.. ", but saw '" .. table.concat(dot_separated_group) .. "'")
				end
			else
				parse_err("Unrecognized prefix '" .. first_element_prefix .. "' in '"
					.. table.concat(dot_separated_group) .. "'")
			end
		end
	end
	return base
end


-- Normalize all lemmas, substituting the pagename for blank lemmas and adding links to multiword lemmas.
local function normalize_all_lemmas(alternant_multiword_spec)

	-- (1) Add links to all before and after text.
	if not alternant_multiword_spec.args.noautolinktext then
		alternant_multiword_spec.post_text = com.add_links(alternant_multiword_spec.post_text)
		for _, alternant_or_word_spec in ipairs(alternant_multiword_spec.alternant_or_word_specs) do
			alternant_or_word_spec.before_text = com.add_links(alternant_or_word_spec.before_text)
			if alternant_or_word_spec.alternants then
				for _, multiword_spec in ipairs(alternant_or_word_spec.alternants) do
					multiword_spec.post_text = com.add_links(multiword_spec.post_text)
					for _, word_spec in ipairs(multiword_spec.word_specs) do
						word_spec.before_text = com.add_links(word_spec.before_text)
					end
				end
			end
		end
	end

	-- (2) Remove any links from the lemma, but remember the original form
	--     so we can use it below in the 'lemma_linked' form.
	iut.map_word_specs(alternant_multiword_spec, function(base)
		if base.lemma == "" then
			base.lemma = alternant_multiword_spec.args.pagename or
				alternant_multiword_spec.args.head and alternant_multiword_spec.args.head[1]
			if not base.lemma then
				local PAGENAME = mw.title.getCurrentTitle().text
				base.lemma = PAGENAME
			end
		end

		base.user_specified_lemma = base.lemma

		base.lemma = m_links.remove_links(base.lemma)
		local refl_verb, clitic = rmatch(base.lemma, "^(.-)(l[aeo]s?)$")
		if not refl_verb then
			refl_verb, clitic = base.lemma, nil
		end
		local verb, refl = rmatch(refl_verb, "^(.-)(se)$")
		if not verb then
			verb, refl = refl_verb, nil
		end
		base.user_specified_verb = verb
		base.refl = refl
		base.clitic = clitic

		if base.refl and base.clitic then
			-- We have to parse the verb suffix to see how to construct the base verb; e.g.
			-- abrírsela -> abrir but oírsela -> oír. We parse the verb suffix again in all cases
			-- in detect_indicator_spec(), after splitting off the prefix of irrregular verbs.
			local actual_verb
			local inf_stem, suffix = rmatch(base.user_specified_verb, "^(.*)([aáeéií]r)$")
			if not inf_stem then
				error("Unrecognized infinitive: " .. base.user_specified_verb)
			end
			if suffix == "ír" and inf_stem:find("[aeo]$") then
				-- accent on suffix should remain
				base.verb = base.user_specified_verb
			else
				base.verb = inf_stem .. com.remove_accent_from_syllable(suffix)
			end
		else
			base.verb = base.user_specified_verb
		end

		local linked_lemma
		if alternant_multiword_spec.args.noautolinkverb or base.user_specified_lemma:find("%[%[") then
			linked_lemma = base.user_specified_lemma
		elseif base.refl or base.clitic then
			-- Reconstruct the linked lemma with separate links around base verb, reflexive pronoun and clitic.
			linked_lemma = base.user_specified_verb == base.verb and "[[" .. base.user_specified_verb .. "]]" or
				"[[" .. base.verb .. "|" .. base.user_specified_verb .. "]]"
			linked_lemma = linked_lemma .. (refl and "[[" .. refl .. "]]" or "") ..
				(clitic and "[[" .. clitic .. "]]" or "")
		else
			-- Add links to the lemma so the user doesn't specifically need to, since we preserve
			-- links in multiword lemmas and include links in non-lemma forms rather than allowing
			-- the entire form to be a link.
			linked_lemma = com.add_links(base.user_specified_lemma)
		end
		base.linked_lemma = linked_lemma
	end)
end


local function detect_indicator_spec(base)
	base.forms = {}
	base.stems = {}

	if base.only3s and base.only3sp then
		error("'only3s' and 'only3sp' cannot both be specified")
	end

	base.basic_overrides = {}
	base.basic_reflexive_only_overrides = {}
	base.combined_overrides = {}
	base.non_prefixed_verb = base.non_prefixed_verb or base.verb
	local inf_stem, suffix = rmatch(base.non_prefixed_verb, "^(.*)([aeií]r)$")
	if not inf_stem then
		error("Unrecognized infinitive: " .. base.verb)
	end
	base.inf_stem = inf_stem
end


local function detect_all_indicator_specs(alternant_multiword_spec, from_headword)
	-- Propagate some settings up or down.
	iut.map_word_specs(alternant_multiword_spec, function(base)
		if base.is_pronominal then
			alternant_multiword_spec.is_pronominal = true
		end
		-- FIXME, old Spanish stuff
		if base.refl then
			alternant_multiword_spec.refl = true
		end
		if base.clitic then
			alternant_multiword_spec.clitic = true
		end
		base.from_headword = from_headword
		base.args = alternant_multiword_spec.args
		-- If fixed clitic, don't include combined forms.
		base.nocomb = alternant_multiword_spec.args.nocomb or base.clitic
	end)

	if not from_headword and not alternant_multiword_spec.args.nocomb then
		-- If we have a combined table, we run into issues if we have multiple
		-- verbs and some are reflexive and some aren't, because we use a
		-- different table for reflexive verbs. So throw an error.
		if alternant_multiword_spec.refl then
			iut.map_word_specs(alternant_multiword_spec, function(base)
				if not base.refl then
					error("If some alternants are reflexive, all must be")
				end
			end)
		end
	end

	iut.map_word_specs(alternant_multiword_spec, function(base)
		detect_indicator_spec(base)
		construct_stems(base)
	end)
end


local function add_categories_and_annotation(alternant_multiword_spec, base, multiword_lemma, from_headword)
	local function insert_ann(anntype, value)
		m_table.insertIfNot(alternant_multiword_spec.annotation[anntype], value)
	end

	local function insert_cat(cat, also_when_multiword)
		-- Don't place multiword terms in categories like 'Italian verbs ending in -ar' to avoid spamming the
		-- categories with such terms.
		if also_when_multiword or not multiword_lemma then
			m_table.insertIfNot(alternant_multiword_spec.categories, "Italian " .. cat)
		end
	end

	if check_for_red_links and not from_headword and not multiword_lemma then
		for _, slot_and_accel in ipairs(all_verb_slots) do
			local slot = slot_and_accel[1]
			local forms = base.forms[slot]
			local must_break = false
			if forms then
				for _, form in ipairs(forms) do
					if not form.form:find("%[%[") then
						local title = mw.title.new(form.form)
						if title and not title.exists then
							insert_cat("verbs with red links in their inflection tables")
							must_break = true
						break
						end
					end
				end
			end
			if must_break then
				break
			end
		end
	end

	insert_cat("verbs ending in -" .. base.conj)

	if base.irreg_verb then
		insert_ann("irreg", "irregular")
		insert_cat("irregular verbs")
	else
		insert_ann("irreg", "regular")
	end

	if base.only3s then
		insert_ann("defective", "impersonal")
		insert_cat("impersonal verbs")
	elseif base.only3sp then
		insert_ann("defective", "third-person only")
		insert_cat("third-person-only verbs")
	elseif base.no_pres_stressed or base.no_pres1_and_sub then
		insert_ann("defective", "defective")
		insert_cat("defective verbs")
	else
		insert_ann("defective", "regular")
	end

	if base.clitic then
		insert_cat("verbs with lexical clitics")
	end

	if base.refl then
		insert_cat("reflexive verbs")
	end

	if not base.vowel_alt then
		insert_ann("vowel_alt", "non-alternating")
	else
		local inf_stem = base.inf_stem:gsub("[gq]u$", "x")
		for _, alt in ipairs(base.vowel_alt) do
			if alt.alt == "+" then
				insert_ann("vowel_alt", "non-alternating")
			else
				local desc
				if alt.alt == "ue" and rfind(inf_stem, "u" .. C .. "*$") then
					desc = "u-ue alternation" -- jugar
				elseif alt.alt == "ie" and rfind(inf_stem, "i" .. C .. "*$") then
					desc = "i-ie alternation" -- adquirir
				elseif alt.alt == "í" and rfind(inf_stem, "e" .. C .. "*$") then
					desc = "e-í alternation" -- reír, freír, etc.
				else
					desc = vowel_alternant_to_desc[alt.alt] .. " alternation"
				end
				insert_ann("vowel_alt", desc)
				insert_cat("verbs with " .. desc)
			end
		end
	end

	local cons_alt = base.stems.cons_alt
	if cons_alt == nil then
		if base.conj == "ar" then
			if base.inf_stem:find("z$") then
				cons_alt = "c-z"
			elseif base.inf_stem:find("ç$") then
				cons_alt = "c-ç"
			elseif base.inf_stem:find("c$") then
				cons_alt = "c-qu"
			elseif base.inf_stem:find("g$") then
				cons_alt = "g-gu"
			elseif base.inf_stem:find("gu$") then
				cons_alt = "gu-gü"
			end
		else
			if base.no_pres_stressed or base.no_pres1_and_sub then
				cons_alt = nil -- no c-zc alternation in balbucir or arrecir
			elseif rfind(base.inf_stem, V .. "c$") then
				cons_alt = "c-zc"
			elseif base.inf_stem:find("sc$") then
				cons_alt = "hard-soft"
			elseif base.inf_stem:find("c$") then
				cons_alt = "c-z"
			elseif base.inf_stem:find("qu$") then
				cons_alt = "c-qu"
			elseif base.inf_stem:find("g$") then
				cons_alt = "g-j"
			elseif base.inf_stem:find("gu$") then
				cons_alt = "g-gu"
			elseif base.inf_stem:find("gü$") then
				cons_alt = "gu-gü"
			end
		end
	end

	if cons_alt then
		local desc = cons_alt .. " alternation"
		insert_ann("cons_alt", desc)
		insert_cat("verbs with " .. desc)
	else
		insert_ann("cons_alt", "non-alternating")
	end
end


-- Compute the categories to add the verb to, as well as the annotation to display in the
-- conjugation title bar. We combine the code to do these functions as both categories and
-- title bar contain similar information.
local function compute_categories_and_annotation(alternant_multiword_spec, from_headword)
	alternant_multiword_spec.categories = {}
	local ann = {}
	alternant_multiword_spec.annotation = ann
	ann.irreg = {}
	ann.defective = {}
	ann.vowel_alt = {}
	ann.cons_alt = {}

	local multiword_lemma = false
	for _, form in ipairs(alternant_multiword_spec.forms.infinitive) do
		if form.form:find(" ") then
			multiword_lemma = true
			break
		end
	end

	iut.map_word_specs(alternant_multiword_spec, function(base)
		add_categories_and_annotation(alternant_multiword_spec, base, multiword_lemma, from_headword)
	end)
	local ann_parts = {}
	local irreg = table.concat(ann.irreg, " or ")
	if irreg ~= "" and irreg ~= "regular" then
		table.insert(ann_parts, irreg)
	end
	local defective = table.concat(ann.defective, " or ")
	if defective ~= "" and defective ~= "regular" then
		table.insert(ann_parts, defective)
	end
	local vowel_alt = table.concat(ann.vowel_alt, " or ")
	if vowel_alt ~= "" and vowel_alt ~= "non-alternating" then
		table.insert(ann_parts, vowel_alt)
	end
	local cons_alt = table.concat(ann.cons_alt, " or ")
	if cons_alt ~= "" and cons_alt ~= "non-alternating" then
		table.insert(ann_parts, cons_alt)
	end
	alternant_multiword_spec.annotation = table.concat(ann_parts, "; ")
end


local function show_forms(alternant_multiword_spec)
	local lemmas = iut.map_forms(alternant_multiword_spec.forms.infinitive,
		remove_reflexive_indicators)
	alternant_multiword_spec.lemmas = lemmas -- save for later use in make_table()

	local props = {
		lang = lang,
		lemmas = lemmas,
	}
	props.slot_list = all_verb_slots
	iut.show_forms(alternant_multiword_spec.forms, props)
	alternant_multiword_spec.footnote_basic = alternant_multiword_spec.forms.footnote
end


local notes_template = [=[
<div style="width:100%;text-align:left;background:#d9ebff">
<div style="display:inline-block;text-align:left;padding-left:1em;padding-right:1em">
{footnote}
</div></div>
]=]

local basic_table = [=[
{description}<div class="NavFrame">
<div class="NavHead" align=center>&nbsp; &nbsp; Conjugation of {title} (See [[Appendix:Italian verbs]])</div>
<div class="NavContent">
{\op}| style="background:#F0F0F0;border-collapse:separate;border-spacing:2px;width:100%" class="inflection-table"
|-
! style="background:#e2e4c0" | <span title="infinito">infinitive</span>
| {inf}
|-
! colspan="2" style="background:#e2e4c0" | <span title="verbo ausiliare">auxiliary verb</span>
| {aux}
! colspan="2" style="background:#e2e4c0" | <span title="gerundio">gerund</span>
| colspan="2" | {ger}
|-
! colspan="2" style="background:#e2e4c0" |  <span title="participio presente">present participle</span>
| {presp}
! colspan="2" style="background:#e2e4c0" | <span title="participio passato">past participle</span>
| colspan="2" | {pp}
|-
! rowspan="2" style="background:#C0C0C0" | person
! colspan="3" style="background:#C0C0C0" | singular
! colspan="3" style="background:#C0C0C0" | plural
|-
! style="background:#C0C0C0;width:12.5%" | first
! style="background:#C0C0C0;width:12.5%" | second
! style="background:#C0C0C0;width:12.5%" | third
! style="background:#C0C0C0;width:12.5%" | first
! style="background:#C0C0C0;width:12.5%" | second
! style="background:#C0C0C0;width:12.5%" | third
|-
! style="background:#c0cfe4" | <span title="indicativo">indicative</span>
! style="background:#c0cfe4" | io
! style="background:#c0cfe4" | tu
! style="background:#c0cfe4" | lui/lei, esso/essa
! style="background:#c0cfe4" | noi
! style="background:#c0cfe4" | voi
! style="background:#c0cfe4" | loro, essi/esse
|-
! style="height:3em;background:#c0cfe4" | <span title="presente">present</span>
| {pres1s}
| {pres2s}
| {pres3s}
| {pres1p}
| {pres2p}
| {pres3p}
|-
! style="height:3em;background:#c0cfe4" | <span title="imperfetto">imperfect</span>
| {imperf1s}
| {imperf2s}
| {imperf3s}
| {imperf1p}
| {imperf2p}
| {imperf3p}
|-
! style="height:3em;background:#c0cfe4" | <span title="passato remoto">past historic</span>
| {phis1s}
| {phis2s}
| {phis3s}
| {phis1p}
| {phis2p}
| {phis3p}
|-
! style="height:3em;background:#c0cfe4" | <span title="futuro semplice">future</span>
| {fut1s}
| {fut2s}
| {fut3s}
| {fut1p}
| {fut2p}
| {fut3p}
|-
! style="background:#c0d8e4" | <span title="condizionale">conditional</span>
! style="background:#c0d8e4" | io
! style="background:#c0d8e4" | tu
! style="background:#c0d8e4" | lui/lei, esso/essa
! style="background:#c0d8e4" | noi
! style="background:#c0d8e4" | voi
! style="background:#c0d8e4" | loro, essi/esse
|-
! style="height:3em;background:#c0d8e4" | <span title="condizionale presente">present</span>
| {cond1s}
| {cond2s}
| {cond3s}
| {cond1p}
| {cond2p}
| {cond3p}
|-
! style="background:#c0e4c0" | <span title="congiuntivo">subjunctive</span>
! style="background:#c0e4c0" | che io
! style="background:#c0e4c0" | che tu
! style="background:#c0e4c0" | che lui/che lei, che esso/che essa
! style="background:#c0e4c0" | che noi
! style="background:#c0e4c0" | che voi
! style="background:#c0e4c0" | che loro, che essi/che esse
|-
! style="height:3em;background:#c0e4c0" | <span title="congiuntivo presente">present</span>
| colspan="3" | {sub123s}
| {sub1p}
| {sub2p}
| {sub3p}
|-
! style="height:3em;background:#c0e4c0" | <span title="congiuntivo imperfetto">imperfect</span>
| colspan="2" | {impsub12s}
| {impsub3s}
| {impsub1p}
| {impsub2p}
| {impsub3p}
|-
! rowspan="2" style="height:3em;background:#e4d4c0" | <span title="imperativo">imperative</span>
! style="background:#e4d4c0" | &mdash;
! style="background:#e4d4c0" | tu
! style="background:#e4d4c0" | Lei
! style="background:#e4d4c0" | noi
! style="background:#e4d4c0" | voi
! style="background:#e4d4c0" | Loro
|-
|
| {imp2s}
| {imp3s}
| {imp1p}
| {imp2p}
| {imp3p}
|-
! style="height:3em;background:#e4d4c0" | <span title="imperativo negativo">negative imperative</span>
|
| {negimp2s}
| {negimp3s}
| {negimp1p}
| {negimp2p}
| {negimp3p}
|{\cl}{notes_clause}</div></div>
]=]


local function make_table(alternant_multiword_spec)
	local forms = alternant_multiword_spec.forms

	forms.title = link_term(alternant_multiword_spec.lemmas[1].form, "term")
	if alternant_multiword_spec.annotation ~= "" then
		forms.title = forms.title .. " (" .. alternant_multiword_spec.annotation .. ")"
	end
	forms.description = ""

	-- Format the table.
	forms.footnote = alternant_multiword_spec.footnote_basic
	forms.notes_clause = forms.footnote ~= "" and m_string_utilities.format(notes_template, forms) or ""
	return m_string_utilities.format(basic_table, forms)
end


-- Externally callable function to parse and conjugate a verb given user-specified arguments.
-- Return value is WORD_SPEC, an object where the conjugated forms are in `WORD_SPEC.forms`
-- for each slot. If there are no values for a slot, the slot key will be missing. The value
-- for a given slot is a list of objects {form=FORM, footnotes=FOOTNOTES}.
function export.do_generate_forms(parent_args, from_headword, def)
	local params = {
		[1] = {required = true, default = def or "mettere<a\é,mìsi,mésso>"},
		["nocomb"] = {type = "boolean"},
		["noautolinktext"] = {type = "boolean"},
		["noautolinkverb"] = {type = "boolean"},
		params["pagename"] = {} -- for testing
	}

	if from_headword then
		params["head"] = {list = true}
		params["id"] = {}
	end

	local args = require("Module:parameters").process(parent_args, params)

	local iut = require("Module:inflection utilities")

	local arg1 = args[1]
	local need_surrounding_angle_brackets = true
	-- Check whether we need to add <...> around the argument. If the
	-- argument has no < in it, we definitely do. Otherwise, we need to
	-- parse the balanced [...] and <...> and add <...> only if there isn't
	-- a top-level <...>. We check for [...] because there might be angle
	-- brackets inside of them (HTML tags in qualifiers or <<name:...>> and
	-- such in references).
	if arg1:find("<") then
		local segments = iut.parse_multi_delimiter_balanced_segment_run(arg1,
			{{"<", ">"}, {"[", "]"}})
		for i = 2, #segments, 2 do
			if segments[i]:find("^<.*>$") then
				need_surrounding_angle_brackets = false
				break
			end
		end
	end
	if need_surrounding_angle_brackets then
		arg1 = "<" .. arg1 .. ">"
	end

	local parse_props = {
		parse_indicator_spec = parse_indicator_spec,
		lang = lang,
		allow_default_indicator = true,
		allow_blank_lemma = true,
	}
	local escaped_arg1 = escape_reflexive_indicators(arg1)
	local alternant_multiword_spec = iut.parse_inflected_text(escaped_arg1, parse_props)
	alternant_multiword_spec.pos = pos or "verbs"
	alternant_multiword_spec.args = args
	normalize_all_lemmas(alternant_multiword_spec)
	detect_all_indicator_specs(alternant_multiword_spec, from_headword)
	local inflect_props = {
		slot_list = all_verb_slots,
		lang = lang,
		inflect_word_spec = conjugate_verb,
		-- We add links around the generated verbal forms rather than allow the entire multiword
		-- expression to be a link, so ensure that user-specified links get included as well.
		include_user_specified_links = true,
	}
	iut.inflect_multiword_or_alternant_multiword_spec(alternant_multiword_spec, inflect_props)

	-- Remove redundant brackets around entire forms.
	for slot, forms in pairs(alternant_multiword_spec.forms) do
		for _, form in ipairs(forms) do
			form.form = com.strip_redundant_links(form.form)
		end
	end

	compute_categories_and_annotation(alternant_multiword_spec, from_headword)
	return alternant_multiword_spec
end


-- Entry point for {{it-conj}}. Template-callable function to parse and conjugate a verb given
-- user-specified arguments and generate a displayable table of the conjugated forms.
function export.show(frame)
	local parent_args = frame:getParent().args
	local alternant_multiword_spec = export.do_generate_forms(parent_args)
	show_forms(alternant_multiword_spec)
	return make_table(alternant_multiword_spec) ..
		require("Module:utilities").format_categories(alternant_multiword_spec.categories, lang, nil, nil, force_cat)
end


-- Concatenate all forms of all slots into a single string of the form
-- "SLOT=FORM,FORM,...|SLOT=FORM,FORM,...|...". Embedded pipe symbols (as might occur
-- in embedded links) are converted to <!>. If INCLUDE_PROPS is given, also include
-- additional properties (currently, none). This is for use by bots.
local function concat_forms(alternant_multiword_spec, include_props)
	local ins_text = {}
	for _, slot_and_accel in ipairs(all_verb_slots) do
		local slot = slot_and_accel[1]
		local formtext = iut.concat_forms_in_slot(alternant_multiword_spec.forms[slot])
		if formtext then
			table.insert(ins_text, slot .. "=" .. formtext)
		end
	end
	return table.concat(ins_text, "|")
end


-- Template-callable function to parse and conjugate a verb given user-specified arguments and return
-- the forms as a string "SLOT=FORM,FORM,...|SLOT=FORM,FORM,...|...". Embedded pipe symbols (as might
-- occur in embedded links) are converted to <!>. If |include_props=1 is given, also include
-- additional properties (currently, none). This is for use by bots.
function export.generate_forms(frame)
	local include_props = frame.args["include_props"]
	local parent_args = frame:getParent().args
	local alternant_multiword_spec = export.do_generate_forms(parent_args)
	return concat_forms(alternant_multiword_spec, include_props)
end


return export
