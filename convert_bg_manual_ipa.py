#!/usr/bin/env python
# -*- coding: utf-8 -*-

# FIXME:
# 1. i in IPA corresponding to й e.g. белогвардейка /bɛloɡvərˈdɛikə/, азербайджанец /əzɛrbəiˈdʒanɛt͡s/ (DONE)
# 2. Assimilated geminate e.g. безстрашен /bɛsˈtraʃɛn/, изслушай /iˈsɫuʃəj/
# 3. Both phonemic and phonetic IPA, e.g. абсолютен {{IPA|bg|/apsɔˈlʲutɛn/|[ɐps̪oˈlʲut̪ɛn̪]}} (DONE)
# 4. Phonetic IPA only, e.g. бера душа [беръ́ душа̟́] (DONE)
# 5. Multiword expressions with endschwa in non-final word, e.g. бера душа [беръ́ душа̟́]
# 6. endschwa before final т, берат /bɛˈɾɤt̪/, благословят /bɫəɡosɫoˈvʲɤt̪/ (DONE)
# 7. Two phonemic IPA with different stresses, e.g. бесил {{IPA|bg|/ˈbɛsiɫ/|/bɛˈsiɫ/}} (DONE)
# 8. Capitalized page titles, e.g. Зара /ˈzara/
# 9. Stress accent mark position in cluster not matching what is autogenerated (FIXME, check for this)
# 
import pywikibot, re, sys, codecs, argparse, unicodedata

import blib
from blib import getparam, rmparam, msg, site, tname, pname

GRAVE = u"\u0300"
ACUTE = u"\u0301"
PRIMARY = u"\u02C8"
SECONDARY = u"\u02CC"
TIE = u"\u0361"
RAISED = u"\u031D"
LOWERED = u"\u031E"
FRONTED = u"\u031F"
DOTUNDER = u"\u0323"
DENTAL = u"\u032A"
accent = ACUTE + GRAVE
accent_c = "[" + accent + "]"
vowel = u"аеиоуъяю"
V = "[" + vowel + "]"
NV = "[^" + vowel + "]"
cons = u"бцдфгчйклмнпрствшхзщж"
C = "[" + cons + "]"

# These should be ignored because the raw pronunciation is unstressed and using {{bg-IPA}} will generate stress (I think).
deny_list = {u"ю", u"я"}

voiced_to_unvoiced = {
  u"б": u"п",
  u"в": u"ф",
  u"г": u"к",
  u"д": u"т",
  u"ж": u"ш",
  u"з": u"с",
}
voiced_obstruent = u"бвгджз"

unvoiced_to_voiced = {y: x for x, y in voiced_to_unvoiced.iteritems()}
unvoiced_obstruent = u"пфктшсхчщц"

ipa_to_cyrillic = {
  "a": u"а",
  u"æ": u"а",
  "b": u"б",
  "v": u"в",
  u"ɡ": u"г",
  "d": u"д",
  "e": u"е",
  u"ɛ": u"е",
  u"ʒ": u"ж",
  "z": u"з",
  "i": u"и",
  u"ɪ": u"и",
  "j": u"й",
  "k": u"к",
  "l": u"л",
  u"ɫ": u"л",
  u"ʎ": u"ль",
  "m": u"м",
  u"ɱ": u"м", # e.g. ансамбъл with pronunciation /əŋˈsaɱbəl/
  "n": u"н",
  u"ŋ": u"н",
  "o": u"о",
  u"ɔ": u"о",
  "p": u"п",
  "r": u"р",
  u"ɾ": u"р",
  "s": u"с",
  "t": u"т",
  "u": u"у",
  u"ʊ": u"у",
  u"ʉ": u"у",
  "f": u"ф",
  "x": u"х",
  "h": u"х",
  u"ʃ": u"ш",
  u"ɐ": u"ъ",
  u"ə": u"ъ",
  u"ɤ": u"ъ",
  u"ɵ": u"ъ", # e.g. арменка with pronunciation /ərˈmɛnkɵ/
  u"ʲ": u"ь",
  TIE: "",
  DENTAL: "",
  RAISED: "",
  LOWERED: "",
  FRONTED: "",
  "(": "",
  ")": "",
  PRIMARY: ACUTE,
  SECONDARY: GRAVE,
  ".": "",
}

def convert_bg_manual_ipa(ipa, pagetitle, pagemsg):
  endschwa = False
  orig_ipa = ipa

  ########## Some early substitutions.
  ipa = ipa.replace(u"i̯", "j")

  ########## Decompose.
  ipa = unicodedata.normalize("NFD", ipa)

  ########## Apply basic conversions.
  ipa = re.sub("(.)", lambda m: ipa_to_cyrillic.get(m.group(1), m.group(1)), ipa)

  ########## Geminate consonant correction.
  ipa = ipa.replace(u"иː", u"ий")
  ipa = re.sub(u"(.)ː", r"\1\1", ipa)

  ########## Sometimes i appears for й instead of j, e.g. действителност /dɛisˈtvitɛlnost/; correct this.

  # To allow matching up и/й chars properly, hack the pagetitle to contain йа/йу in place of я/ю word-initial or after a vowel.
  hacked_pagetitle = re.sub(r"(\b|" + V + u")я", ur"\1йа", pagetitle)
  hacked_pagetitle = re.sub(r"(\b|" + V + u")ю", ur"\1йу", hacked_pagetitle)
  hacked_pagetitle_chars = list(hacked_pagetitle)
  ipa_chars = list(ipa)

  # Get the indices of all и/й in the pagetitle, along with the corresponding char.
  pagetitle_ij_indices = [[i, x] for i, x in enumerate(hacked_pagetitle_chars) if x in u"ий"]
  # Get the indices of all i/j in the IPA, along with the corresponding char.
  ipa_ij_indices = [[i, x] for i, x in enumerate(ipa_chars) if x in u"ий"]

  # Make sure same number of i/j in both.
  num_ipa_ij = len(ipa_ij_indices)
  num_pagetitle_ij = len(pagetitle_ij_indices)
  if num_ipa_ij != num_pagetitle_ij:
    pagemsg(u"WARNING: IPA %s (original %s) has %s i/j chars but pagetitle '%s' has %s и/й chars" % (
      ipa, orig_ipa, num_ipa_ij, pagetitle, num_pagetitle_ij))
  else:
    # If so, match up corresponding i/j.
    for (ipa_index, ipa_ij), (pagetitle_index, pagetitle_ij) in zip(ipa_ij_indices, pagetitle_ij_indices):
      # Correct IPA и to й as appropriate.
      if ipa_ij == u"и" and pagetitle_ij == u"й":
        pagemsg(u"Replacing IPA и with й at index %s in %s based on pagetitle й at index %s" %
          (ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"й"

  ipa = "".join(ipa_chars)

  ########## Preliminary handling of ю/я. More work needed to handle vowel reduction and endschwa; see below.
  ipa = ipa.replace(u"ьу", u"ю")
  ipa = ipa.replace(u"ьа", u"я")
  ipa = ipa.replace(u"йу", u"ю")
  ipa = ipa.replace(u"йа", u"я")
  ipa = ipa.replace(u"ьи", u"и") # e.g. абаджийките with pronunciation /ˌabəˈd̪ʒijkʲit̪ɛ/
  ipa = ipa.replace(u"ье", u"е") # e.g. аборигена with pronunciation /ˌaboɾiˈɡʲɛnə/

  ########## Move accents after vowels
  ipa = re.sub("(" + accent_c + ")(" + NV + "*" + V + ")", r"\2\1", ipa)

  ########## Correct vowel reduction (unstressed а -> ъ, unstressed у -> о) and endschwa (ъ́ written as а́, ьъ́/йъ́ written as я́).

  pagetitle_chars = list(pagetitle)
  ipa_chars = list(ipa)

  # Get the indices of all vowels in the pagetitle, along with the corresponding vowel.
  pagetitle_vowel_indices = [[i, x] for i, x in enumerate(pagetitle_chars) if x in vowel]

  # Get the indices of all vowels in the IPA, along with the corresponding vowel. If there is a stress mark, combine it
  # with preceding IPA vowel, as we need to distinguish stressed from unstressed vowels.
  ipa_vowel_indices_with_stress = [[i, x] for i, x in enumerate(ipa_chars) if x in vowel or x in accent]
  ipa_vowel_indices = []
  for i, x in ipa_vowel_indices_with_stress:
    if x in accent:
      if len(ipa_vowel_indices) == 0:
        pagemsg("WARNING: Stress mark at index %s not following vowel for IPA %s (original %s)" % (i, ipa, orig_ipa))
        return
      if ipa_vowel_indices[-1][0] != i - 1:
        pagemsg("WARNING: Stress mark at index %s not directly following vowel for IPA %s (original %s)" % (i, ipa, orig_ipa))
        return
      ipa_vowel_indices[-1][1] += x
    else:
      ipa_vowel_indices.append([i, x])

  # Make sure same number of vowels in both.
  num_ipa_vowels = len(ipa_vowel_indices)
  num_pagetitle_vowels = len(pagetitle_vowel_indices)
  if num_ipa_vowels != num_pagetitle_vowels:
    pagemsg("WARNING: IPA %s (original %s) has %s vowel(s) but pagetitle '%s' has %s vowel(s)" % (
      ipa, orig_ipa, num_ipa_vowels, pagetitle, num_pagetitle_vowels))
  else:
    # If so, match up corresponding vowels.
    for (ipa_index, ipa_vowel), (pagetitle_index, pagetitle_vowel) in zip(ipa_vowel_indices, pagetitle_vowel_indices):
      # Correct unstressed IPA о to у/ю as appropriate.
      if ipa_vowel == u"о" and pagetitle_vowel == u"у":
        pagemsg(u"Replacing unstressed IPA о with у at index %s in %s based on pagetitle vowel at index %s" %
          (ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"у"
      elif ipa_vowel == u"о" and ipa_index > 0 and ipa_chars[ipa_index - 1] in [u"ь", u"й"] and pagetitle_vowel == u"ю":
        pagemsg(u"Replacing unstressed IPA %sо with ю at index %s in %s based on pagetitle vowel at index %s" %
          (ipa_chars[ipa_index - 1], ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"ю"
        ipa_chars[ipa_index - 1] = ""
      # Correct unstressed IPA у to о as appropriate (e.g. акробатика with pronunciation /akruˈbatikə/)
      elif ipa_vowel == u"у" and pagetitle_vowel == u"о":
        pagemsg(u"Replacing unstressed IPA у with о at index %s in %s based on pagetitle vowel at index %s" %
          (ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"о"
      # Correct unstressed IPA ъ to а/я as appropriate.
      elif ipa_vowel == u"ъ" and pagetitle_vowel == u"а":
        pagemsg(u"Replacing unstressed IPA ъ with а at index %s in %s based on pagetitle vowel at index %s" %
          (ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"а"
      elif ipa_vowel == u"ъ" and ipa_index > 0 and ipa_chars[ipa_index - 1] in [u"ь", u"й"] and pagetitle_vowel == u"я":
        pagemsg(u"Replacing unstressed IPA %sъ with я at index %s in %s based on pagetitle vowel at index %s" %
          (ipa_chars[ipa_index - 1], ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"я"
        ipa_chars[ipa_index - 1] = ""
      # Correct stressed IPA ъ to а/я as appropriate if word-final, setting endschwa=1.
      elif ipa_vowel == u"ъ́" and pagetitle_vowel == u"а" and (
          ipa_index == len(ipa) - 2 or ipa_index == len(ipa) - 3 and ipa.endswith(u"т")):
        pagemsg(u"Replacing stressed IPA ъ with а at index %s in %s and endschwa=1 based on pagetitle vowel at index %s" %
          (ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"а"
        endschwa = True
      elif (ipa_vowel == u"ъ́" and ipa_index > 0 and ipa_chars[ipa_index - 1] in [u"ь", u"й"] and pagetitle_vowel == u"я" and (
        ipa_index == len(ipa) - 2 or ipa_index == len(ipa) - 3 and ipa.endswith(u"т"))):
        pagemsg(u"Replacing unstressed IPA %sъ with я at index %s in %s and endschwa=1 based on pagetitle vowel at index %s" %
          (ipa_chars[ipa_index - 1], ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"я"
        ipa_chars[ipa_index - 1] = ""
        endschwa = True

  ipa = "".join(ipa_chars)

  ########## Misc cluster corrections. FIXME: Might not work in some cases.
  if u"щ" in pagetitle:
    ipa = ipa.replace(u"шт", u"щ")
  if u"ц" in pagetitle:
    ipa = ipa.replace(u"тс", u"ц")
  if u"ч" in pagetitle:
    ipa = ipa.replace(u"тш", u"ч")
  if u"нтс" in pagetitle:
    ipa = ipa.replace(u"нс", u"нтс")
  if u"стк" in pagetitle:
    ipa = ipa.replace(u"ск", u"стк")
  if u"ктн" in pagetitle:
    ipa = ipa.replace(u"кн", u"ктн")
  if u"ждн" in pagetitle:
    ipa = ipa.replace(u"жн", u"ждн")
  if u"щн" in pagetitle:
    ipa = ipa.replace(u"шн", u"щн") # e.g. срещнала /ˈsrɛʃnəɫə/
  if re.search(u"зс" + C, pagetitle):
    ipa = re.sub(u"(с" + C + ")", ur"з\1", ipa)
  if u"зсъ" in pagetitle and u"зсъ" not in ipa: # HACK, e.g. неразсъдителност /nɛrəsəˈditɛlnost/
    ipa = ipa.replace(u"съ", u"зсъ")
  if u"нв" in pagetitle:
    ipa = ipa.replace(u"мв", u"нв")
  if u"нф" in pagetitle:
    ipa = ipa.replace(u"мф", u"нф")
  if u"чт" in pagetitle:
    ipa = ipa.replace(u"тщ", u"чт") # e.g. мечтаещ /mɛtʃˈt̪aɛʃt̪/

  ########## Correct consonant voicing assimilation.

  #### First, correct final devoicing.
  if pagetitle[-1] in voiced_to_unvoiced and ipa[-1] == voiced_to_unvoiced[pagetitle[-1]]:
    pagemsg(u"Replacing final devoiced IPA %s with %s based on final voiced pagetitle consonant" % (ipa[-1], pagetitle[-1]))
    ipa = ipa[:-1] + pagetitle[-1]

  #### Then, correct voicing assimilation before an obstruent.
  ipa_chars = list(ipa)

  # Get the indices of all consonants in the IPA, along with the corresponding consonant.
  ipa_cons_indices = [[i, x] for i, x in enumerate(ipa_chars) if x not in vowel and x not in accent]
  # Get the indices of all consonants in the pagetitle, along with the corresponding consonant.
  pagetitle_cons_indices = [[i, x] for i, x in enumerate(pagetitle_chars) if x not in vowel and x not in accent]

  # Make sure same number of consonants in both.
  num_ipa_cons = len(ipa_cons_indices)
  num_pagetitle_cons = len(pagetitle_cons_indices)
  if num_ipa_cons != num_pagetitle_cons:
    pagemsg("WARNING: IPA %s (original %s) has %s consonant(s) but pagetitle '%s' has %s consonant(s)" % (
      ipa, orig_ipa, num_ipa_cons, pagetitle, num_pagetitle_cons))
  else:
    # If so, match up corresponding consonants.
    for (ipa_index, ipa_cons), (pagetitle_index, pagetitle_cons) in zip(ipa_cons_indices, pagetitle_cons_indices):
      # Correct devoiced IPA obstruent to voiced equivalent as appropriate.
      if (ipa_cons in unvoiced_to_voiced and ipa_index < len(ipa) - 1 and ipa_chars[ipa_index + 1] in unvoiced_obstruent
          and pagetitle_cons == unvoiced_to_voiced[ipa_cons]):
        new_ipa_cons = unvoiced_to_voiced[ipa_cons]
        pagemsg(u"Replacing unvoiced IPA %s before unvoiced obstruent with %s at index %s in %s based on pagetitle cons at index %s" %
          (ipa_cons, new_ipa_cons, ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = new_ipa_cons
      # Correct voiced IPA obstruent to unvoiced equivalent as appropriate.
      elif (ipa_cons in voiced_to_unvoiced and ipa_index < len(ipa) - 1 and ipa_chars[ipa_index + 1] in voiced_obstruent
          and pagetitle_cons == voiced_to_unvoiced[ipa_cons]):
        new_ipa_cons = voiced_to_unvoiced[ipa_cons]
        pagemsg(u"Replacing voiced IPA %s before voiced obstruent with %s at index %s in %s based on pagetitle cons at index %s" %
          (ipa_cons, new_ipa_cons, ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = new_ipa_cons

  ipa = "".join(ipa_chars)

  ########## Finally, check to see whether respelling matches pagetitle except in accents.
  pagetitle_from_ipa = re.sub(accent_c, "", ipa)
  if pagetitle_from_ipa != pagetitle:
    pagemsg("WARNING: Inferred respelling %s from IPA %s, does not match pagetitle" %
      (ipa, orig_ipa))
    return None, False
  return ipa, endschwa

def process_text_on_page(index, pagetitle, text):
  global args
  def pagemsg(txt):
    msg("Page %s %s: %s" % (index, pagetitle, txt))

  notes = []

  if pagetitle in deny_list:
    pagemsg("WARNING: Skipping because in deny list")
    return

  retval = blib.find_modifiable_lang_section(text, None if args.partial_page else "Polish", pagemsg,
    force_final_nls=True)
  if retval is None:
    return
  sections, j, secbody, sectail, has_non_lang = retval

  parsed = blib.parse_text(secbody)

  to_substitute = []

  for t in parsed.filter_templates():
    tn = tname(t)
    if tn == "IPA" and getparam(t, "1") == "bg":
      origt = unicode(t)
      ipas = blib.fetch_param_chain(t, "2")
      must_continue = False
      for param in t.params:
        pn = pname(param)
        pv = unicode(param.value)
        if not re.search("^[0-9]+$", pn):
          pagemsg("WARNING: Saw unrecognized param %s=%s in raw IPA, skipping: %s" % (pn, pv, origt))
          must_continue = True
          break
      if must_continue:
        continue
      must_continue = False
      this_notes = []
      respellings = []
      for ipa in ipas:
        ipa = re.sub("^/(.*)/$", r"\1", ipa)
        ipa = re.sub(r"^\[(.*)\]$", r"\1", ipa)
        respelling, endschwa = convert_bg_manual_ipa(ipa, pagetitle, pagemsg)
        if respelling is None:
          must_continue = True
          break
        new_respelling = (respelling, endschwa)
        if new_respelling not in respellings:
          respellings.append(new_respelling)
          endschwa_note = " with endschwa=1" if endschwa else ""
          pagemsg("Converting IPA %s to respelling %s%s" % (ipa, respelling, endschwa_note))
          this_notes.append("convert IPA %s to respelling %s%s" % (ipa, respelling, endschwa_note))
      if must_continue:
        continue
      if len(respellings) == 1:
        # Replace directly if only one respelling, to reduce cases where we get "Already found replacement text" messages.
        blib.set_template_name(t, "bg-IPA")
        del t.params[:]
        respelling, endschwa = respellings[0]
        t.add("1", respelling)
        if endschwa:
          t.add("endschwa", "1")
        pagemsg("Replaced %s with %s directly" % (origt, unicode(t)))
      else:
        replacement_parts = []
        annparam = "|ann=1" if len(respellings) > 1 else ""
        for respelling, endschwa in respellings:
          endschwa_param = "|endschwa=1" if endschwa else ""
          replacement_parts.append("{{bg-IPA|%s%s%s}}" % (respelling, endschwa_param, annparam))
        replacement_text = "\n* ".join(replacement_parts)
        to_substitute.append((origt, replacement_text))
      notes.extend(this_notes)

  secbody = unicode(parsed)
  for fromtext, totext in to_substitute:
    secbody, replaced = blib.replace_in_text(secbody, fromtext, totext, pagemsg, abort_if_warning=True)
    if not replaced:
      return
    pagemsg("Replaced %s with %s using textual substitution" % (fromtext, totext.replace("\n", r"\n")))

  # Strip extra newlines added to secbody
  sections[j] = secbody.rstrip("\n") + sectail
  return "".join(sections), notes

parser = blib.create_argparser("Convert manual Bulgarian IPA pronunciations to bg-IPA", include_pagefile=True,
    include_stdin=True)
parser.add_argument("--partial-page", action="store_true", help="Input was generated with 'find_regex.py --lang LANG' and has no ==LANG== header.")
args = parser.parse_args()
start, end = blib.parse_start_end(args.start, args.end)

blib.do_pagefile_cats_refs(args, start, end, process_text_on_page,
    default_cats=["Bulgarian terms with IPA pronunciation"], edit=True, stdin=True)

blib.elapsed_time()
