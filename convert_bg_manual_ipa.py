#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# FIXME:
# 1. i in IPA corresponding to й e.g. белогвардейка /bɛloɡvərˈdɛikə/, азербайджанец /əzɛrbəiˈdʒanɛt͡s/ (DONE)
# 2. Assimilated geminate e.g. безстрашен /bɛsˈtraʃɛn/, изслушай /iˈsɫuʃəj/ (DONE)
# 3. Both phonemic and phonetic IPA, e.g. абсолютен {{IPA|bg|/apsɔˈlʲutɛn/|[ɐps̪oˈlʲut̪ɛn̪]}} (DONE)
# 4. Phonetic IPA only, e.g. бера душа [беръ́ душа̟́] (DONE)
# 5. Multiword expressions with endschwa in non-final word, e.g. бера душа [беръ́ душа̟́]
# 6. endschwa before final т, берат /bɛˈɾɤt̪/, благословят /bɫəɡosɫoˈvʲɤt̪/ (DONE)
# 7. Two phonemic IPA with different stresses, e.g. бесил {{IPA|bg|/ˈbɛsiɫ/|/bɛˈsiɫ/}} (DONE)
# 8. Capitalized page titles, e.g. Зара /ˈzara/
# 9. Stress accent mark position in cluster not matching what is autogenerated (DONE)
# 10. Most words beginning with а- with manual IPA have secondary stress on а-. FIXME: Correct? Check with native speaker.
# 
import pywikibot, re, sys, codecs, argparse, unicodedata

import blib
from blib import getparam, rmparam, msg, site, tname, pname

GRAVE = u"\u0300"
ACUTE = u"\u0301"
PRIMARY = u"\u02C8"
SECONDARY = u"\u02CC"
TIE = u"\u0361"
RAISED = u"\u031D"
LOWERED = u"\u031E"
FRONTED = u"\u031F"
DOTUNDER = u"\u0323"
DENTAL = u"\u032A"
accent = ACUTE + GRAVE
accent_c = "[" + accent + "]"
stress_mark = PRIMARY + SECONDARY
stress_mark_c = "[" + stress_mark + "]"
vowel = u"аеиоуъяю"
V = "[" + vowel + "]"
NV = "[^" + vowel + "]"
cons = u"бцдфгчйклмнпрствшхзщжь"
C = "[" + cons + "]"

# These should be ignored because the raw pronunciation is unstressed and using {{bg-IPA}} will generate stress (I think).
deny_list = {u"ю", u"я"}

# Special case replacements based on known cases where we get it wrong and need explicit syllable divisions.
# Only at the beginning of a word.
special_case_replacements = [
  (u"зам.р", u"за.мр"),
  (u"изм.р", u"из.мр"),
  (u"надв.н", u"над.вн"),
  (u"о.брек", u"об.рек"),
  (u"о.бреч", u"об.реч"),
  (u"о.брич", u"об.рич"),
  (u"отм.р", u"от.мр"),
  # The manual IPA claims от.рав and от.ров "to poison; to exhume" but it is derived from о- + трав- per Vasmer.
  # (u"о.трав", u"от.рав"),
  # (u"о.тров", u"от.ров"),
  (u"о.трек", u"от.рек"),
  (u"о.треч", u"от.реч"),
  (u"о.трич", u"от.рич"),
  (u"о.тсек", u"от.сек"),
  (u"о.тсеч", u"от.сеч"),
  (u"о.тсич", u"от.сич"),
  (u"о.тсъст", u"от.съст"),
  (u"о.тсяк", u"от.сяк"),
  (u"пре.дрек", u"пред.рек"),
  (u"пре.дреч", u"пред.реч"),
  (u"пре.дрич", u"пред.рич"),
  (u"прем.р", u"пре.мр"),
  # The manual IPA claims при.внас and при.внес "to bring in, to introduce". This is derived from при- + в- + нес-.
  # Unclear if при.вн makes sense but we also have над.вн, which is clearly better than надв.н.
  (u"прив.н", u"при.вн"),
  (u"прим.р", u"при.мр"),
  (u"съ.зда", u"съз.да"),
  (u"ум.р", u"у.мр"),
]

voiced_to_unvoiced = {
  u"б": u"п",
  u"в": u"ф",
  u"г": u"к",
  u"д": u"т",
  u"ж": u"ш",
  u"з": u"с",
}
voiced_obstruent = u"бвгджз"

unvoiced_to_voiced = {y: x for x, y in voiced_to_unvoiced.iteritems()}
unvoiced_obstruent = u"пфктшсхчщц"

prefixes = [u"без", u"въз", u"възпроиз", u"из", u"наиз", u"поиз", u"превъз", u"произ", u"раз"]

ipa_to_cyrillic = {
  "a": u"а",
  u"æ": u"а",
  "b": u"б",
  "v": u"в",
  u"ɡ": u"г",
  "d": u"д",
  "e": u"е",
  u"ɛ": u"е",
  u"ʒ": u"ж",
  "z": u"з",
  "i": u"и",
  u"ɪ": u"и",
  "j": u"й",
  "k": u"к",
  "l": u"л",
  u"ɫ": u"л",
  u"ʎ": u"ль",
  "m": u"м",
  u"ɱ": u"м", # e.g. ансамбъл with pronunciation /əŋˈsaɱbəl/
  "n": u"н",
  u"ŋ": u"н",
  "o": u"о",
  u"ɔ": u"о",
  "p": u"п",
  "r": u"р",
  u"ɾ": u"р",
  "s": u"с",
  "t": u"т",
  "u": u"у",
  u"ʊ": u"у",
  u"ʉ": u"у",
  "f": u"ф",
  "x": u"х",
  "h": u"х",
  u"ʃ": u"ш",
  u"ɐ": u"ъ",
  u"ə": u"ъ",
  u"ɤ": u"ъ",
  u"ɵ": u"ъ", # e.g. арменка with pronunciation /ərˈmɛnkɵ/
  u"ʲ": u"ь",
  TIE: "",
  DENTAL: "",
  RAISED: "",
  LOWERED: "",
  FRONTED: "",
  "(": "",
  ")": "",
  ".": "",
}

def convert_bg_manual_ipa(ipa, pagetitle, pagemsg):
  endschwa = False
  orig_ipa = ipa

  ########## Some early substitutions.
  ipa = ipa.replace(u"i̯", "j")

  ########## Decompose.
  ipa = unicodedata.normalize("NFD", ipa)

  ########## Apply basic conversions.
  ipa = re.sub("(.)", lambda m: ipa_to_cyrillic.get(m.group(1), m.group(1)), ipa)

  ########## Geminate consonant correction.
  ipa = ipa.replace(u"иː", u"ий")
  ipa = re.sub(u"(.)ː", r"\1\1", ipa)

  ########## Sometimes i appears for й instead of j, e.g. действителност /dɛisˈtvitɛlnost/; correct this.

  # To allow matching up и/й chars properly, hack the pagetitle to contain йа/йу in place of я/ю word-initial or after a vowel.
  hacked_pagetitle = re.sub(r"(\b|" + V + u")я", ur"\1йа", pagetitle, 0, re.U)
  hacked_pagetitle = re.sub(r"(\b|" + V + u")ю", ur"\1йу", hacked_pagetitle, 0, re.U)
  hacked_pagetitle_chars = list(hacked_pagetitle)
  ipa_chars = list(ipa)

  # Get the indices of all и/й in the pagetitle, along with the corresponding char.
  pagetitle_ij_indices = [[i, x] for i, x in enumerate(hacked_pagetitle_chars) if x in u"ий"]
  # Get the indices of all i/j in the IPA, along with the corresponding char.
  ipa_ij_indices = [[i, x] for i, x in enumerate(ipa_chars) if x in u"ий"]

  # Make sure same number of i/j in both.
  num_ipa_ij = len(ipa_ij_indices)
  num_pagetitle_ij = len(pagetitle_ij_indices)
  if num_ipa_ij != num_pagetitle_ij:
    pagemsg(u"WARNING: IPA %s (original %s) has %s i/j chars but pagetitle '%s' has %s и/й chars" % (
      ipa, orig_ipa, num_ipa_ij, pagetitle, num_pagetitle_ij))
  else:
    # If so, match up corresponding i/j.
    for (ipa_index, ipa_ij), (pagetitle_index, pagetitle_ij) in zip(ipa_ij_indices, pagetitle_ij_indices):
      # Correct IPA и to й as appropriate.
      if ipa_ij == u"и" and pagetitle_ij == u"й":
        pagemsg(u"Replacing IPA и with й at index %s in %s based on pagetitle й at index %s" %
          (ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"й"

  ipa = "".join(ipa_chars)

  ########## Preliminary handling of ю/я. More work needed to handle vowel reduction and endschwa; see below.
  ipa = ipa.replace(u"ьу", u"ю")
  ipa = ipa.replace(u"ьа", u"я")
  ipa = ipa.replace(u"йу", u"ю")
  ipa = ipa.replace(u"йа", u"я")
  ipa = ipa.replace(u"ьи", u"и") # e.g. абаджийките with pronunciation /ˌabəˈd̪ʒijkʲit̪ɛ/
  ipa = ipa.replace(u"ье", u"е") # e.g. аборигена with pronunciation /ˌaboɾiˈɡʲɛnə/

  ########## Move accents after vowels, but leave original IPA stress mark there as well for later syllable division checking
  ipa = re.sub("(" + PRIMARY + C + "*" + V + ")", r"\1" + ACUTE, ipa)
  ipa = re.sub("(" + SECONDARY + C + "*" + V + ")", r"\1" + GRAVE, ipa)

  ########## Correct vowel reduction (unstressed а -> ъ, unstressed у -> о) and endschwa (ъ́ written as а́, ьъ́/йъ́ written as я́).

  pagetitle_chars = list(pagetitle)
  ipa_chars = list(ipa)

  # Get the indices of all vowels in the pagetitle, along with the corresponding vowel.
  pagetitle_vowel_indices = [[i, x] for i, x in enumerate(pagetitle_chars) if x in vowel]

  # Get the indices of all vowels in the IPA, along with the corresponding vowel. If there is a stress mark, combine it
  # with preceding IPA vowel, as we need to distinguish stressed from unstressed vowels.
  ipa_vowel_indices_with_stress = [[i, x] for i, x in enumerate(ipa_chars) if x in vowel or x in accent]
  ipa_vowel_indices = []
  for i, x in ipa_vowel_indices_with_stress:
    if x in accent:
      if len(ipa_vowel_indices) == 0:
        pagemsg("WARNING: Stress mark at index %s not following vowel for IPA %s (original %s)" % (i, ipa, orig_ipa))
        return
      if ipa_vowel_indices[-1][0] != i - 1:
        pagemsg("WARNING: Stress mark at index %s not directly following vowel for IPA %s (original %s)" % (i, ipa, orig_ipa))
        return
      ipa_vowel_indices[-1][1] += x
    else:
      ipa_vowel_indices.append([i, x])

  # Make sure same number of vowels in both.
  num_ipa_vowels = len(ipa_vowel_indices)
  num_pagetitle_vowels = len(pagetitle_vowel_indices)
  if num_ipa_vowels != num_pagetitle_vowels:
    pagemsg("WARNING: IPA %s (original %s) has %s vowel(s) but pagetitle '%s' has %s vowel(s)" % (
      ipa, orig_ipa, num_ipa_vowels, pagetitle, num_pagetitle_vowels))
  else:
    # If so, match up corresponding vowels.
    for (ipa_index, ipa_vowel), (pagetitle_index, pagetitle_vowel) in zip(ipa_vowel_indices, pagetitle_vowel_indices):
      # Correct unstressed IPA о to у/ю as appropriate.
      if ipa_vowel == u"о" and pagetitle_vowel == u"у":
        pagemsg(u"Replacing unstressed IPA о with у at index %s in %s based on pagetitle vowel at index %s" %
          (ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"у"
      elif ipa_vowel == u"о" and ipa_index > 0 and ipa_chars[ipa_index - 1] in [u"ь", u"й"] and pagetitle_vowel == u"ю":
        pagemsg(u"Replacing unstressed IPA %sо with ю at index %s in %s based on pagetitle vowel at index %s" %
          (ipa_chars[ipa_index - 1], ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"ю"
        ipa_chars[ipa_index - 1] = ""
      # Correct unstressed IPA у to о as appropriate (e.g. акробатика with pronunciation /akruˈbatikə/)
      elif ipa_vowel == u"у" and pagetitle_vowel == u"о":
        pagemsg(u"Replacing unstressed IPA у with о at index %s in %s based on pagetitle vowel at index %s" %
          (ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"о"
      # Correct unstressed IPA ъ to а/я as appropriate.
      elif ipa_vowel == u"ъ" and pagetitle_vowel == u"а":
        pagemsg(u"Replacing unstressed IPA ъ with а at index %s in %s based on pagetitle vowel at index %s" %
          (ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"а"
      elif ipa_vowel == u"ъ" and ipa_index > 0 and ipa_chars[ipa_index - 1] in [u"ь", u"й"] and pagetitle_vowel == u"я":
        pagemsg(u"Replacing unstressed IPA %sъ with я at index %s in %s based on pagetitle vowel at index %s" %
          (ipa_chars[ipa_index - 1], ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"я"
        ipa_chars[ipa_index - 1] = ""
      # Correct stressed IPA ъ to а/я as appropriate if word-final, setting endschwa=1.
      elif ipa_vowel == u"ъ́" and pagetitle_vowel == u"а" and (
          ipa_index == len(ipa) - 2 or ipa_index == len(ipa) - 3 and ipa.endswith(u"т")):
        pagemsg(u"Replacing stressed IPA ъ with а at index %s in %s and endschwa=1 based on pagetitle vowel at index %s" %
          (ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"а"
        endschwa = True
      elif (ipa_vowel == u"ъ́" and ipa_index > 0 and ipa_chars[ipa_index - 1] in [u"ь", u"й"] and pagetitle_vowel == u"я" and (
        ipa_index == len(ipa) - 2 or ipa_index == len(ipa) - 3 and ipa.endswith(u"т"))):
        pagemsg(u"Replacing unstressed IPA %sъ with я at index %s in %s and endschwa=1 based on pagetitle vowel at index %s" %
          (ipa_chars[ipa_index - 1], ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = u"я"
        ipa_chars[ipa_index - 1] = ""
        endschwa = True

  ipa = "".join(ipa_chars)

  ########## Misc cluster corrections. FIXME: Might not work in some cases.
  if u"щ" in pagetitle:
    ipa = re.sub(u"ш(" + stress_mark_c + u"?)т", ur"\1щ", ipa)
  if u"ц" in pagetitle:
    ipa = re.sub(u"т(" + stress_mark_c + u"?)с", ur"\1ц", ipa)
  if u"ч" in pagetitle:
    ipa = re.sub(u"т(" + stress_mark_c + u"?)ш", ur"\1ч", ipa)
  if u"нтс" in pagetitle:
    ipa = re.sub(u"н(" + stress_mark_c + u"?)с", ur"нт\1с", ipa)
  if u"стк" in pagetitle:
    ipa = re.sub(u"с(" + stress_mark_c + u"?)к", ur"ст\1к", ipa)
  if u"ктн" in pagetitle:
    ipa = re.sub(u"к(" + stress_mark_c + u"?)н", ur"кт\1н", ipa)
  if u"ждн" in pagetitle:
    ipa = re.sub(u"ж(" + stress_mark_c + u"?)н", ur"жд\1н", ipa)
  if u"щн" in pagetitle:
    ipa = re.sub(u"ш(" + stress_mark_c + u"?)н", ur"щ\1н", ipa) # e.g. срещнала /ˈsrɛʃnəɫə/
  if re.search(u"зс" + C, pagetitle):
    # Stress mark should be before с
    ipa = re.sub("(" + stress_mark_c + u"?с" + C + ")", ur"з\1", ipa)
  if u"зсъ" in pagetitle and u"зсъ" not in ipa: # HACK, e.g. неразсъдителност /nɛrəsəˈditɛlnost/
    ipa = re.sub(u"съ", u"зсъ", ipa)
  if u"нв" in pagetitle:
    ipa = re.sub(u"м(" + stress_mark_c + u"?)в", ur"н\1в", ipa)
  if u"нф" in pagetitle:
    ipa = re.sub(u"м(" + stress_mark_c + u"?)ф", ur"н\1ф", ipa)
  if u"чт" in pagetitle:
    ipa = re.sub(u"т(" + stress_mark_c + u"?)щ", ur"ч\1т", ipa) # e.g. мечтаещ /mɛtʃˈt̪aɛʃt̪/

  ########## Correct consonant voicing assimilation.

  #### First, correct final devoicing.
  if pagetitle[-1] in voiced_to_unvoiced and ipa[-1] == voiced_to_unvoiced[pagetitle[-1]]:
    pagemsg(u"Replacing final devoiced IPA %s with %s based on final voiced pagetitle consonant" % (ipa[-1], pagetitle[-1]))
    ipa = ipa[:-1] + pagetitle[-1]

  #### Then, correct voicing assimilation before an obstruent.
  ipa_chars = list(ipa)

  # Get the indices of all consonants in the IPA, along with the corresponding consonant.
  ipa_cons_indices = [[i, x] for i, x in enumerate(ipa_chars) if x in cons]
  # Get the indices of all consonants in the pagetitle, along with the corresponding consonant.
  pagetitle_cons_indices = [[i, x] for i, x in enumerate(pagetitle_chars) if x in cons]

  # Make sure same number of consonants in both.
  num_ipa_cons = len(ipa_cons_indices)
  num_pagetitle_cons = len(pagetitle_cons_indices)
  if num_ipa_cons != num_pagetitle_cons:
    pagemsg("WARNING: IPA %s (original %s) has %s consonant(s) but pagetitle '%s' has %s consonant(s)" % (
      ipa, orig_ipa, num_ipa_cons, pagetitle, num_pagetitle_cons))
  else:
    # If so, match up corresponding consonants.
    for (ipa_index, ipa_cons), (pagetitle_index, pagetitle_cons) in zip(ipa_cons_indices, pagetitle_cons_indices):
      # Check that the next character is voiced or unvoiced (according to `obstruents`), or that the next character is an IPA
      # stress mark and the following character is voiced or unvoiced.
      def check_next_voicing(obstruents):
        return ipa_index < len(ipa) - 1 and ipa_chars[ipa_index + 1] in obstruents or (
          ipa_index < len(ipa) - 2 and ipa_chars[ipa_index + 1] in stress_mark and ipa_chars[ipa_index + 2] in obstruents
        )

      # Correct devoiced IPA obstruent to voiced equivalent as appropriate.
      if ipa_cons in unvoiced_to_voiced and check_next_voicing(unvoiced_obstruent) and (
        pagetitle_cons == unvoiced_to_voiced[ipa_cons]
      ):
        new_ipa_cons = unvoiced_to_voiced[ipa_cons]
        pagemsg(u"Replacing unvoiced IPA %s before unvoiced obstruent with %s at index %s in %s based on pagetitle cons at index %s" %
          (ipa_cons, new_ipa_cons, ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = new_ipa_cons
      # Correct voiced IPA obstruent to unvoiced equivalent as appropriate.
      elif ipa_cons in voiced_to_unvoiced and check_next_voicing(voiced_obstruent) and (
        pagetitle_cons == voiced_to_unvoiced[ipa_cons]
      ):
        new_ipa_cons = voiced_to_unvoiced[ipa_cons]
        pagemsg(u"Replacing voiced IPA %s before voiced obstruent with %s at index %s in %s based on pagetitle cons at index %s" %
          (ipa_cons, new_ipa_cons, ipa_index, ipa, pagetitle_index))
        ipa_chars[ipa_index] = new_ipa_cons

  ipa = "".join(ipa_chars)

  ########## See if explicit syllable division needed
  # We do this by moving the temporarily moving the accent where it would automatically go and see if this matches
  # what we had before moving accents after vowels.
  auto_stress_ipa = ipa.replace(PRIMARY, "").replace(SECONDARY, "")
  # First, move leftwards over the vowel.
  auto_stress_ipa = re.sub(u"(" + V + ")(" + accent_c + ")", r"\2\1", auto_stress_ipa)
  # Then, move leftwards over й or soft sign.
  auto_stress_ipa = re.sub(u"([йь])(" + accent_c + ")", r"\2\1", auto_stress_ipa)
  # Then, move leftwards over a single consonant.
  auto_stress_ipa = re.sub(u"(" + C + ")(" + accent_c + ")", r"\2\1", auto_stress_ipa)
  # Then, move leftwards over Cl/Cr combinations where C is an obstruent.
  auto_stress_ipa = re.sub(u"([бдгпткхфв]" + ")(" + accent_c + u")([рл])", r"\2\1\3", auto_stress_ipa)
  # Then, move leftwards over kv/gv.
  auto_stress_ipa = re.sub(u"([кг]" + ")(" + accent_c + u")(в)", r"\2\1\3", auto_stress_ipa)
  # Then, move leftwards over sC combinations, where C is a stop or resonant.
  auto_stress_ipa = re.sub(u"([сз]" + ")(" + accent_c + u")([бдгптквлрмн])", r"\2\1\3", auto_stress_ipa)
  # Then, move leftwards over affricates not followed by a consonant.
  auto_stress_ipa = re.sub(u"([тд])(" + accent_c + u")([сзшж]" + V + ")", r"\2\1\3", auto_stress_ipa)
  # Then, move leftwards over any remaining consonants at the beginning of a word.
  auto_stress_ipa = re.sub(r"\b(" + C + "*)(" + accent_c + ")", r"\2\1", auto_stress_ipa, 0, re.U)
  # Then correct for known prefixes.
  for prefix in prefixes:
    m = re.search("^(.*?)(" + C + "*)$", prefix)
    prefix_prefix, prefix_final_cons = m.groups()
    if prefix_final_cons:
      # Check for accent moved too far to the left into a prefix, e.g. безбрачие accented as беˈзбрачие instead of безˈбрачие
      auto_stress_ipa = re.sub(r"\b(" + prefix_prefix + ")(" + accent_c + ")(" + prefix_final_cons + ")", r"\1\3\2",
          auto_stress_ipa, 0, re.U)

  ipa_with_orig_accents = ipa.replace(ACUTE, "").replace(GRAVE, "")
  ipa = ipa.replace(PRIMARY, "").replace(SECONDARY, "")

  # Now apply special-case replacements.
  for special_from, special_to in special_case_replacements:
    auto_stress_special_from = r"\b" + special_from.replace(".", "(" + accent_c + ")")
    auto_stress_special_to = special_to.replace(".", r"\1")
    ipa_special_from = r"\b" + special_from.replace(".", "")
    ipa_special_to = special_to
    if re.search(auto_stress_special_from, auto_stress_ipa, re.U):
      auto_stress_ipa = re.sub(auto_stress_special_from, auto_stress_special_to, auto_stress_ipa, 0, re.U)
      ipa = re.sub(ipa_special_from, ipa_special_to, ipa, 0, re.U)
      pagemsg("Applying special-case replacement %s -> %s, producing IPA %s" % (special_from, special_to, ipa))
      break

  auto_stress_ipa = auto_stress_ipa.replace(ACUTE, PRIMARY).replace(GRAVE, SECONDARY)
  if ipa_with_orig_accents != auto_stress_ipa:
    pagemsg("WARNING: IPA before accent moving %s not same as auto-stressed IPA %s" %
      (ipa_with_orig_accents, auto_stress_ipa))

  ########## Finally, check to see whether respelling matches pagetitle except in accents.
  pagetitle_from_ipa = re.sub(accent_c, "", ipa).replace(".", "")
  if pagetitle_from_ipa != pagetitle:
    pagemsg("WARNING: Inferred respelling %s from IPA %s, does not match pagetitle" %
      (ipa, orig_ipa))
    return None, False
  return ipa, endschwa

def process_text_on_page(index, pagetitle, text):
  global args
  def pagemsg(txt):
    msg("Page %s %s: %s" % (index, pagetitle, txt))

  notes = []

  if pagetitle in deny_list:
    pagemsg("WARNING: Skipping because in deny list")
    return

  retval = blib.find_modifiable_lang_section(text, None if args.partial_page else "Bulgarian", pagemsg,
    force_final_nls=True)
  if retval is None:
    return
  sections, j, secbody, sectail, has_non_lang = retval

  parsed = blib.parse_text(secbody)

  to_substitute = []

  for t in parsed.filter_templates():
    tn = tname(t)
    if tn == "IPA" and getparam(t, "1") == "bg":
      origt = str(t)
      ipas = blib.fetch_param_chain(t, "2")
      must_continue = False
      for param in t.params:
        pn = pname(param)
        pv = str(param.value)
        if not re.search("^[0-9]+$", pn):
          pagemsg("WARNING: Saw unrecognized param %s=%s in raw IPA, skipping: %s" % (pn, pv, origt))
          must_continue = True
          break
      if must_continue:
        continue
      must_continue = False
      this_notes = []
      respellings = []
      for ipa in ipas:
        ipa = re.sub("^/(.*)/$", r"\1", ipa)
        ipa = re.sub(r"^\[(.*)\]$", r"\1", ipa)
        respelling, endschwa = convert_bg_manual_ipa(ipa, pagetitle, pagemsg)
        if respelling is None:
          must_continue = True
          break
        new_respelling = (respelling, endschwa)
        if new_respelling not in respellings:
          respellings.append(new_respelling)
          endschwa_note = " with endschwa=1" if endschwa else ""
          pagemsg("Converting IPA %s to respelling %s%s" % (ipa, respelling, endschwa_note))
          this_notes.append("convert Bulgarian manual IPA %s to respelling %s%s" % (ipa, respelling, endschwa_note))
      if must_continue:
        continue
      if len(respellings) == 1:
        # Replace directly if only one respelling, to reduce cases where we get "Already found replacement text" messages.
        blib.set_template_name(t, "bg-IPA")
        del t.params[:]
        respelling, endschwa = respellings[0]
        t.add("1", respelling)
        if endschwa:
          t.add("endschwa", "1")
        pagemsg("Replaced %s with %s directly" % (origt, str(t)))
      else:
        replacement_parts = []
        annparam = "|ann=1" if len(respellings) > 1 else ""
        for respelling, endschwa in respellings:
          endschwa_param = "|endschwa=1" if endschwa else ""
          replacement_parts.append("{{bg-IPA|%s%s%s}}" % (respelling, endschwa_param, annparam))
        replacement_text = "\n* ".join(replacement_parts)
        to_substitute.append((origt, replacement_text))
      notes.extend(this_notes)

  secbody = str(parsed)
  for fromtext, totext in to_substitute:
    secbody, replaced = blib.replace_in_text(secbody, fromtext, totext, pagemsg, abort_if_warning=True)
    if not replaced:
      return
    pagemsg("Replaced %s with %s using textual substitution" % (fromtext, totext.replace("\n", r"\n")))

  # Strip extra newlines added to secbody
  sections[j] = secbody.rstrip("\n") + sectail
  return "".join(sections), notes

parser = blib.create_argparser("Convert manual Bulgarian IPA pronunciations to bg-IPA", include_pagefile=True,
    include_stdin=True)
parser.add_argument("--partial-page", action="store_true", help="Input was generated with 'find_regex.py --lang LANG' and has no ==LANG== header.")
args = parser.parse_args()
start, end = blib.parse_start_end(args.start, args.end)

blib.do_pagefile_cats_refs(args, start, end, process_text_on_page,
    default_cats=["Bulgarian terms with IPA pronunciation"], edit=True, stdin=True)
